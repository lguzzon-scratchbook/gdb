var globalCrypto =
  typeof globalThis === 'object' && 'crypto' in globalThis
    ? globalThis.crypto
    : void 0
function isUint8Array(data) {
  return (
    data instanceof Uint8Array ||
    (ArrayBuffer.isView(data) && data.constructor.name === 'Uint8Array')
  )
}
function assertPositiveInteger(number) {
  if (!Number.isSafeInteger(number) || number < 0)
    throw new Error(`positive integer expected, got ${number}`)
}
function assertUint8Array(data, ...expectedLengths) {
  if (!isUint8Array(data)) throw new Error('Uint8Array expected')
  if (expectedLengths.length > 0 && !expectedLengths.includes(data.length))
    throw new Error(
      `Uint8Array expected of length ${expectedLengths}, got length=${data.length}`
    )
}
function assertHash(hashFunction) {
  if (
    typeof hashFunction !== 'function' ||
    typeof hashFunction.create !== 'function'
  )
    throw new Error('Hash should be wrapped by utils.createHasher')
  assertPositiveInteger(hashFunction.outputLen),
    assertPositiveInteger(hashFunction.blockLen)
}
function assertHashState(hashInstance, checkFinished = true) {
  if (hashInstance.destroyed)
    throw new Error('Hash instance has been destroyed')
  if (checkFinished && hashInstance.finished)
    throw new Error('Hash#digest() has already been called')
}
function assertDigestBuffer(buffer, hashFunction) {
  assertUint8Array(buffer)
  const outputLength = hashFunction.outputLen
  if (buffer.length < outputLength)
    throw new Error(
      `digestInto() expects output buffer of length at least ${outputLength}`
    )
}
function cleanBuffers(...buffers) {
  for (let bufferIndex = 0; bufferIndex < buffers.length; bufferIndex++)
    buffers[bufferIndex].fill(0)
}
function createDataView(array) {
  return new DataView(array.buffer, array.byteOffset, array.byteLength)
}
function rotl32(value, shiftBits) {
  return (value << (32 - shiftBits)) | (value >>> shiftBits)
}
function bytesToHex(bytes) {
  if ((assertUint8Array(bytes), supportsNativeHex)) return bytes.toHex()
  let hexString = ''
  for (let index = 0; index < bytes.length; index++)
    hexString += hexLookupTable[bytes[index]]
  return hexString
}
var hexCharToByte = (char) => {
  if (char >= hexChars._0 && char <= hexChars._9)
    return char - hexChars._0
  if (char >= hexChars.A && char <= hexChars.F)
    return char - (hexChars.A - 10)
  if (char >= hexChars.a && char <= hexChars.f)
    return char - (hexChars.a - 10)
  return
}
function hexToBytes(hexString) {
  if (typeof hexString !== 'string')
    throw new Error(`hex string expected, got ${typeof hexString}`)
  if (supportsNativeHex) return Uint8Array.fromHex(hexString)
  const hexLength = hexString.length,
    byteLength = hexLength / 2
  if (hexLength % 2)
    throw new Error(
      `hex string expected, got unpadded hex of length ${hexLength}`
    )
  const bytes = new Uint8Array(byteLength)
  for (
    let byteIndex = 0, charIndex = 0;
    byteIndex < byteLength;
    byteIndex++, charIndex += 2
  ) {
    const highNibble = hexCharToByte(hexString.charCodeAt(charIndex)),
      lowNibble = hexCharToByte(hexString.charCodeAt(charIndex + 1))
    if (highNibble === void 0 || lowNibble === void 0) {
      const charPair = hexString[charIndex] + hexString[charIndex + 1]
      throw new Error(
        `hex string expected, got non-hex character "${charPair}" at index ${charIndex}`
      )
    }
    bytes[byteIndex] = highNibble * 16 + lowNibble
  }
  return bytes
}
function stringToBytes(inputString) {
  if (typeof inputString !== 'string') throw new Error('string expected')
  return new Uint8Array(new TextEncoder().encode(inputString))
}
function ensureBytes(data) {
  if (typeof data === 'string') data = stringToBytes(data)
  return assertUint8Array(data), data
}
function concatBytes(...arrays) {
  let totalLength = 0
  for (let index = 0; index < arrays.length; index++) {
    const array = arrays[index]
    assertUint8Array(array), (totalLength += array.length)
  }
  const result = new Uint8Array(totalLength)
  for (
    let index = 0, offset = 0;
    index < arrays.length;
    index++
  ) {
    const array = arrays[index]
    result.set(array, offset), (offset += array.length)
  }
  return result
}
function createHasher(hashConstructor) {
  const hasher = (data) => hashConstructor().update(ensureBytes(data)).digest(),
    instance = hashConstructor()
  return (
    (hasher.outputLen = instance.outputLen),
    (hasher.blockLen = instance.blockLen),
    (hasher.create = () => hashConstructor()),
    hasher
  )
}
function _randomBytes(length = 32) {
  if (globalCrypto && typeof globalCrypto.getRandomValues === 'function')
    return globalCrypto.getRandomValues(new Uint8Array(length))
  if (globalCrypto && typeof globalCrypto.randomBytes === 'function')
    return Uint8Array.from(globalCrypto.randomBytes(length))
  throw new Error('crypto.getRandomValues must be defined')
} /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var supportsNativeHex = (() =>
    typeof Uint8Array.from([]).toHex === 'function' &&
    typeof Uint8Array.fromHex === 'function')(),
  hexLookupTable = Array.from({ length: 256 }, (_, index) =>
    index.toString(16).padStart(2, '0')
  ),
  hexChars = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 }
class HashBase {}
function setBigUint64(dataView, offset, value, isLittleEndian) {
  if (typeof dataView.setBigUint64 === 'function')
    return dataView.setBigUint64(offset, value, isLittleEndian)
  const shift32 = BigInt(32),
    mask32 = BigInt(4294967295),
    highWord = Number((value >> shift32) & mask32),
    lowWord = Number(value & mask32),
    highOffset = isLittleEndian ? 4 : 0,
    lowOffset = isLittleEndian ? 0 : 4
  dataView.setUint32(offset + highOffset, highWord, isLittleEndian),
    dataView.setUint32(offset + lowOffset, lowWord, isLittleEndian)
}
function _ch(x, y, z) {
  return (x & y) ^ (~x & z)
}
function majority(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z)
}
class SHA2 extends HashBase {
  constructor(blockSize, digestSize, padOffset, isLittleEndian) {
    super()
    ;(this.finished = !1),
      (this.length = 0),
      (this.pos = 0),
      (this.destroyed = !1),
      (this.blockLen = blockSize),
      (this.outputLen = digestSize),
      (this.padOffset = padOffset),
      (this.isLE = isLittleEndian),
      (this.buffer = new Uint8Array(blockSize)),
      (this.view = createDataView(this.buffer))
  }
  update(data) {
    assertHashState(this), (data = ensureBytes(data)), assertUint8Array(data)
    const { view: dataView, buffer: blockBuffer, blockLen: blockSize } = this,
      dataLength = data.length
    for (let offset = 0; offset < dataLength; ) {
      const chunkSize = Math.min(blockSize - this.pos, dataLength - offset)
      if (chunkSize === blockSize) {
        const chunkView = createDataView(data)
        for (; blockSize <= dataLength - offset; offset += blockSize)
          this.process(chunkView, offset)
        continue
      }
      if (
        (blockBuffer.set(data.subarray(offset, offset + chunkSize), this.pos),
        (this.pos += chunkSize),
        (offset += chunkSize),
        this.pos === blockSize)
      )
        this.process(dataView, 0), (this.pos = 0)
    }
    return (this.length += data.length), this.roundClean(), this
  }
  digestInto(outputBuffer) {
    assertHashState(this),
      assertDigestBuffer(outputBuffer, this),
      (this.finished = !0)
    const {
      buffer: blockBuffer,
      view: dataView,
      blockLen: blockSize,
      isLE: isLittleEndian
    } = this
    let { pos: position } = this
    if (
      ((blockBuffer[position++] = 128),
      cleanBuffers(this.buffer.subarray(position)),
      this.padOffset > blockSize - position)
    )
      this.process(dataView, 0), (position = 0)
    for (let index = position; index < blockSize; index++) blockBuffer[index] = 0
    setBigUint64(
      dataView,
      blockSize - 8,
      BigInt(this.length * 8),
      isLittleEndian
    ),
      this.process(dataView, 0)
    const outputView = createDataView(outputBuffer),
      outputLength = this.outputLen
    if (outputLength % 4)
      throw new Error('_sha2: outputLen should be aligned to 32bit')
    const stateSize = outputLength / 4,
      state = this.get()
    if (stateSize > state.length)
      throw new Error('_sha2: outputLen bigger than state')
    for (let index = 0; index < stateSize; index++)
      outputView.setUint32(4 * index, state[index], isLittleEndian)
  }
  digest() {
    const { buffer: blockBuffer, outputLen: digestSize } = this
    this.digestInto(blockBuffer)
    const result = blockBuffer.slice(0, digestSize)
    return this.destroy(), result
  }
  _cloneInto(destination) {
    destination || (destination = new this.constructor()),
      destination.set(...this.get())
    const {
      blockLen: blockSize,
      buffer: blockBuffer,
      length: dataLength,
      finished: isFinished,
      destroyed: isDestroyed,
      pos: position
    } = this
    if (
      ((destination.destroyed = isDestroyed),
      (destination.finished = isFinished),
      (destination.length = dataLength),
      (destination.pos = position),
      dataLength % blockSize)
    )
      destination.buffer.set(blockBuffer)
    return destination
  }
  clone() {
    return this._cloneInto()
  }
}
var SHA256_INITIAL_HASH = Uint32Array.from([
  1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924,
  528734635, 1541459225
])
var SHA256_ROUND_CONSTANTS = Uint32Array.from([
    1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
    2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
    1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774,
    264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
    2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711,
    113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
    1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
    3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
    430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
    1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424,
    2428436474, 2756734187, 3204031479, 3329325298
  ]),
  SHA256_WORKING_BUFFER = new Uint32Array(64)
class SHA256 extends SHA2 {
  constructor(digestSize = 32) {
    super(64, digestSize, 8, !1)
    ;(this.A = SHA256_INITIAL_HASH[0] | 0),
      (this.B = SHA256_INITIAL_HASH[1] | 0),
      (this.C = SHA256_INITIAL_HASH[2] | 0),
      (this.D = SHA256_INITIAL_HASH[3] | 0),
      (this.E = SHA256_INITIAL_HASH[4] | 0),
      (this.F = SHA256_INITIAL_HASH[5] | 0),
      (this.G = SHA256_INITIAL_HASH[6] | 0),
      (this.H = SHA256_INITIAL_HASH[7] | 0)
  }
  get() {
    const { A: stateA, B: stateB, C: stateC, D: stateD, E: stateE, F: stateF, G: stateG, H: stateH } = this
    return [stateA, stateB, stateC, stateD, stateE, stateF, stateG, stateH]
  }
  set(stateA, stateB, stateC, stateD, stateE, stateF, stateG, stateH) {
    ;(this.A = stateA | 0),
      (this.B = stateB | 0),
      (this.C = stateC | 0),
      (this.D = stateD | 0),
      (this.E = stateE | 0),
      (this.F = stateF | 0),
      (this.G = stateG | 0),
      (this.H = stateH | 0)
  }
  process(dataView, offset) {
    for (let index = 0; index < 16; index++, offset += 4)
      SHA256_WORKING_BUFFER[index] = dataView.getUint32(offset, !1)
    for (let index = 16; index < 64; index++) {
      const s0 = SHA256_WORKING_BUFFER[index - 15],
        s1 = SHA256_WORKING_BUFFER[index - 2],
        sigma0 = rotl32(s0, 7) ^ rotl32(s0, 18) ^ (s0 >>> 3),
        sigma1 = rotl32(s1, 17) ^ rotl32(s1, 19) ^ (s1 >>> 10)
      SHA256_WORKING_BUFFER[index] =
        (sigma1 +
          SHA256_WORKING_BUFFER[index - 7] +
          sigma0 +
          SHA256_WORKING_BUFFER[index - 16]) |
        0
    }
    let { A: stateA, B: stateB, C: stateC, D: stateD, E: stateE, F: stateF, G: stateG, H: stateH } = this
    for (let index = 0; index < 64; index++) {
      const S1 = rotl32(stateE, 6) ^ rotl32(stateE, 11) ^ rotl32(stateE, 25),
        choice =
          (stateH +
            S1 +
            _ch(stateE, stateF, stateG) +
            SHA256_ROUND_CONSTANTS[index] +
            SHA256_WORKING_BUFFER[index]) |
          0,
        S0 = ((rotl32(stateA, 2) ^ rotl32(stateA, 13) ^ rotl32(stateA, 22)) + majority(stateA, stateB, stateC)) | 0
      ;(stateH = stateG),
        (stateG = stateF),
        (stateF = stateE),
        (stateE = (stateD + choice) | 0),
        (stateD = stateC),
        (stateC = stateB),
        (stateB = stateA),
        (stateA = (choice + S0) | 0)
    }
    ;(stateA = (stateA + this.A) | 0),
      (stateB = (stateB + this.B) | 0),
      (stateC = (stateC + this.C) | 0),
      (stateD = (stateD + this.D) | 0),
      (stateE = (stateE + this.E) | 0),
      (stateF = (stateF + this.F) | 0),
      (stateG = (stateG + this.G) | 0),
      (stateH = (stateH + this.H) | 0),
      this.set(stateA, stateB, stateC, stateD, stateE, stateF, stateG, stateH)
  }
  roundClean() {
    cleanBuffers(SHA256_WORKING_BUFFER)
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), cleanBuffers(this.buffer)
  }
}
var _sha256 = createHasher(() => new SHA256())
class HMAC extends HashBase {
  constructor(hashConstructor, key) {
    super()
    ;(this.finished = !1), (this.destroyed = !1), assertHash(hashConstructor)
    const keyBytes = ensureBytes(key)
    if (
      ((this.innerHash = hashConstructor.create()),
      typeof this.innerHash.update !== 'function')
    )
      throw new Error('Expected instance of class which extends utils.Hash')
    ;(this.blockLen = this.innerHash.blockLen),
      (this.outputLen = this.innerHash.outputLen)
    const blockSize = this.blockLen,
      ipad = new Uint8Array(blockSize)
    ipad.set(
      keyBytes.length > blockSize
        ? hashConstructor.create().update(keyBytes).digest()
        : keyBytes
    )
    for (let i = 0; i < ipad.length; i++) ipad[i] ^= 54
    this.innerHash.update(ipad), (this.outerHash = hashConstructor.create())
    for (let i = 0; i < ipad.length; i++) ipad[i] ^= 54 ^ 92
    this.outerHash.update(ipad), cleanBuffers(ipad)
  }
  update(data) {
    return assertHashState(this), this.innerHash.update(data), this
  }
  digestInto(outputBuffer) {
    assertHashState(this),
      assertUint8Array(outputBuffer, this.outputLen),
      (this.finished = !0),
      this.innerHash.digestInto(outputBuffer),
      this.outerHash.update(outputBuffer),
      this.outerHash.digestInto(outputBuffer),
      this.destroy()
  }
  digest() {
    const outputBuffer = new Uint8Array(this.outerHash.outputLen)
    return this.digestInto(outputBuffer), outputBuffer
  }
  _cloneInto(destination) {
    destination ||
      (destination = Object.create(Object.getPrototypeOf(this), {}))
    const {
      oHash: outerHash,
      iHash: innerHash,
      finished: isFinished,
      destroyed: isDestroyed,
      blockLen: blockSize,
      outputLen: outputLength
    } = this
    return (
      (destination = destination),
      (destination.finished = isFinished),
      (destination.destroyed = isDestroyed),
      (destination.blockLen = blockSize),
      (destination.outputLen = outputLength),
      (destination.oHash = outerHash._cloneInto(destination.oHash)),
      (destination.iHash = innerHash._cloneInto(destination.iHash)),
      destination
    )
  }
  clone() {
    return this._cloneInto()
  }
  destroy() {
    ;(this.destroyed = !0), this.outerHash.destroy(), this.innerHash.destroy()
  }
}
var hmac = (hashConstructor, key, data) =>
  new HMAC(hashConstructor, key).update(data).digest()
hmac.create = (hashConstructor, key) => new HMAC(hashConstructor, key)
function assertBoolean(value, name = '') {
  if (typeof value !== 'boolean') {
    const message = name && `"${name}"`
    throw new Error(`${message}expected boolean, got type=${typeof value}`)
  }
  return value
}
function _assertBytes(data, expectedLength, name = '') {
  const isArray = isUint8Array(data),
    dataLength = data?.length,
    hasLength = expectedLength !== void 0
  if (!isArray || (hasLength && dataLength !== expectedLength)) {
    const message = name && `"${name}" `,
      lengthInfo = hasLength ? ` of length ${expectedLength}` : '',
      typeInfo = isArray ? `length=${dataLength}` : `type=${typeof data}`
    throw new Error(
      `${message}expected Uint8Array${lengthInfo}, got ${typeInfo}`
    )
  }
  return data
}
function _bytesToHexMinimal(bytes) {
  const hexString = bytes.toString(16)
  return hexString.length & 1 ? `0${hexString}` : hexString
}
function hexToBigInt(hexString) {
  if (typeof hexString !== 'string')
    throw new Error(`hex string expected, got ${typeof hexString}`)
  return hexString === '' ? ZERO : BigInt(`0x${hexString}`)
}
function bytesToBigInt(bytes) {
  return hexToBigInt(bytesToHex(bytes))
}
function bytesToBigIntLE(bytes) {
  return (
    assertUint8Array(bytes),
    hexToBigInt(bytesToHex(Uint8Array.from(bytes).reverse()))
  )
}
function bigIntToBytesBE(value, byteLength) {
  return hexToBytes(value.toString(16).padStart(byteLength * 2, '0'))
}
function bigIntToBytesLE(value, byteLength) {
  return bigIntToBytesBE(value, byteLength).reverse()
}
function ensureBytesOrHex(name, data, expectedLength) {
  let bytes
  if (typeof data === 'string')
    try {
      bytes = hexToBytes(data)
    } catch (error) {
      throw new Error(
        `${name} must be hex string or Uint8Array, cause: ${error}`
      )
    }
  else if (isUint8Array(data)) bytes = Uint8Array.from(data)
  else throw new Error(`${name} must be hex string or Uint8Array`)
  const dataLength = bytes.length
  if (typeof expectedLength === 'number' && dataLength !== expectedLength)
    throw new Error(
      `${name} of length ${expectedLength} expected, got ${dataLength}`
    )
  return bytes
}
function isInRange(value, min, max) {
  return (
    isBigInt(value) &&
    isBigInt(min) &&
    isBigInt(max) &&
    min <= value &&
    value < max
  )
}
function _assertInRange(name, value, min, max) {
  if (!isInRange(value, min, max))
    throw new Error(
      `expected valid ${name}: ${min} <= n < ${max}, got ${value}`
    )
}
function getBitLength(value) {
  let bitLength
  for (bitLength = 0; value > ZERO; value >>= ONE, bitLength += 1);
  return bitLength
}
function _createDRBG(digestSize, scalarSize, hmacFn) {
  if (typeof digestSize !== 'number' || digestSize < 2)
    throw new Error('hashLen must be a number')
  if (typeof scalarSize !== 'number' || scalarSize < 2)
    throw new Error('qByteLen must be a number')
  if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function')
  const createUint8Array = (length) => new Uint8Array(length),
    createSingleByte = (byte) => Uint8Array.of(byte)
  let v = createUint8Array(digestSize),
    k = createUint8Array(digestSize),
    reseedCounter = 0
  const reset = () => {
      v.fill(1), k.fill(0), (reseedCounter = 0)
    },
    hmac = (...data) => hmacFn(k, v, ...data),
    update = (entropy = createUint8Array(0)) => {
      if (
        ((k = hmac(createSingleByte(0), entropy)),
        (v = hmac()),
        entropy.length === 0)
      )
        return
      ;(k = hmac(createSingleByte(1), entropy)), (v = hmac())
    },
    generate = () => {
      if (reseedCounter++ >= 1000) throw new Error('drbg: tried 1000 values')
      let outputLength = 0
      const data = []
      while (outputLength < scalarSize) {
        v = hmac()
        const chunk = v.slice()
        data.push(chunk), (outputLength += v.length)
      }
      return concatBytes(...data)
    }
  return (entropy, predictionResistance) => {
    reset(), update(entropy)
    let result = void 0
    while (!(result = predictionResistance(generate()))) update()
    return reset(), result
  }
}
function validateOptions(options, required, optional = {}) {
  if (!options || typeof options !== 'object')
    throw new Error('expected valid options object')
  function validateParam(name, type, isOptional) {
    const value = options[name]
    if (isOptional && value === void 0) return
    const valueType = typeof value
    if (valueType !== type || value === null)
      throw new Error(
        `param "${name}" is invalid: expected ${type}, got ${valueType}`
      )
  }
  Object.entries(required).forEach(([name, type]) =>
    validateParam(name, type, !1)
  ),
    Object.entries(optional).forEach(([name, type]) =>
      validateParam(name, type, !0)
    )
}
function _memoize(fn) {
  const cache = new WeakMap()
  return (key, ...args) => {
    const cached = cache.get(key)
    if (cached !== void 0) return cached
    const result = fn(key, ...args)
    return cache.set(key, result), result
  }
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var ZERO = BigInt(0),
  ONE = BigInt(1),
  isBigInt = (value) => typeof value === 'bigint' && ZERO <= value,
  createMask = (bits) => (ONE << BigInt(bits)) - ONE
function mod(value, modulus) {
  const result = value % modulus
  return result >= ZERO ? result : modulus + result
}
function _pow(base, exponent, modulus) {
  let result = base
  while (exponent-- > ZERO) (result *= result), (result %= modulus)
  return result
}
function invert(number, modulus) {
  if (number === ZERO) throw new Error('invert: expected non-zero number')
  if (modulus <= ZERO)
    throw new Error(`invert: expected positive modulus, got ${modulus}`)
  let a = mod(number, modulus),
    b = modulus,
    x0 = ZERO,
    y0 = ONE,
    x1 = ONE,
    y1 = ZERO
  while (a !== ZERO) {
    const q = b / a,
      r = b % a,
      newX = x0 - x1 * q,
      newY = y0 - y1 * q
    ;(b = a), (a = r), (x0 = x1), (y0 = y1), (x1 = newX), (y1 = newY)
  }
  if (b !== ONE) throw new Error('invert: does not exist')
  return mod(x0, modulus)
}
var validateSquareRoot = (field, value, square) => {
    if (!field.eql(field.sqr(value), square))
      throw new Error('Cannot find square root')
  },
  tonelliShanks = (field, value) => {
    const exponent = (field.ORDER + ONE) / FOUR,
      result = field.pow(value, exponent)
    return validateSquareRoot(field, result, value), result
  },
  sqrtMod3 = (field, value) => {
    const exponent = (field.ORDER - FIVE) / EIGHT,
      temp = field.mul(value, TWO),
      result = field.pow(temp, exponent),
      temp2 = field.mul(value, result),
      temp3 = field.mul(field.mul(temp2, TWO), result),
      finalResult = field.mul(temp2, field.sub(temp3, field.ONE))
    return validateSquareRoot(field, finalResult, value), finalResult
  },
  sqrtMod5 = (field) => {
    const fieldInfo = createField(field),
      sqrtFn = createSquareRoot(field),
      beta = sqrtFn(fieldInfo, fieldInfo.neg(fieldInfo.ONE)),
      beta2 = sqrtFn(fieldInfo, beta),
      beta3 = sqrtFn(fieldInfo, fieldInfo.neg(beta)),
      exponent = (field + SEVEN) / SIXTEEN
    return (field, value) => {
      let result = field.pow(value, exponent),
        temp = field.mul(result, beta)
      const temp2 = field.mul(result, beta2),
        temp3 = field.mul(result, beta3),
        isCorrect1 = field.eql(field.sqr(temp), value),
        isCorrect2 = field.eql(field.sqr(temp2), value)
      ;(result = field.cmov(result, temp, isCorrect1)),
        (temp = field.cmov(temp3, temp2, isCorrect2))
      const isCorrect3 = field.eql(field.sqr(temp), value),
        finalResult = field.cmov(result, temp, isCorrect3)
      return validateSquareRoot(field, finalResult, value), finalResult
    }
  }
function createSquareRoot(prime) {
  if (prime < THREE) throw new Error('sqrt is not defined for small field')
  let q = prime - ONE,
    s = 0
  while (q % TWO === ZERO) (q /= TWO), s++
  let z = TWO
  const field = createField(prime)
  while (legendreSymbol(field, z) === 1)
    if (z++ > 1000)
      throw new Error('Cannot find square root: probably non-prime P')
  if (s === 1) return tonelliShanks
  const _c = field.pow(z, q)
  const t = (q + ONE) / TWO
  return function tonelliShanksAlgorithm(field, value) {
    if (field.is0(value)) return value
    if (legendreSymbol(field, value) !== 1)
      throw new Error('Cannot find square root')
    let m = s,
      c = field.mul(field.ONE, _c),
      x = field.pow(value, q),
      b = field.pow(value, t)
    while (!field.eql(b, field.ONE)) {
      if (field.is0(b)) return field.ZERO
      let r = 1,
        d = field.sqr(b)
      while (!field.eql(d, field.ONE))
        if ((r++, (d = field.sqr(d)), r === m))
          throw new Error('Cannot find square root')
      const e = ONE << BigInt(m - r - 1),
        g = field.pow(c, e)
      ;(m = r), (c = field.sqr(g)), (b = field.mul(b, c)), (x = field.mul(x, g))
    }
    return x
  }
}
function getSquareRootMethod(prime) {
  if (prime % FOUR === THREE) return tonelliShanks
  if (prime % EIGHT === FIVE) return sqrtMod3
  if (prime % SIXTEEN === NINE) return sqrtMod5(prime)
  return createSquareRoot(prime)
}
function validateField(field) {
  const required = {
      ORDER: 'bigint',
      MASK: 'bigint',
      BYTES: 'number',
      BITS: 'number'
    },
    optional = FIELD_METHODS.reduce((obj, method) => {
      return (obj[method] = 'function'), obj
    }, required)
  return validateOptions(field, optional), field
}
function powMod(field, base, exponent) {
  if (exponent < ZERO)
    throw new Error('invalid exponent, negatives unsupported')
  if (exponent === ZERO) return field.ONE
  if (exponent === ONE) return base
  let result = field.ONE,
    current = base
  while (exponent > ZERO) {
    if (exponent & ONE) result = field.mul(result, current)
    ;(current = field.sqr(current)), (exponent >>= ONE)
  }
  return result
}
function invertBatch(field, values, zeroDefault = !1) {
  const partial = new Array(values.length).fill(
      zeroDefault ? field.ZERO : void 0
    ),
    product = values.reduce((acc, value, index) => {
      if (field.is0(value)) return acc
      return (partial[index] = acc), field.mul(acc, value)
    }, field.ONE),
    inverse = field.inv(product)
  return (
    values.reduceRight((acc, value, index) => {
      if (field.is0(value)) return acc
      return (
        (partial[index] = field.mul(acc, partial[index])), field.mul(acc, value)
      )
    }, inverse),
    partial
  )
}
function legendreSymbol(field, value) {
  const exponent = (field.ORDER - ONE) / TWO,
    result = field.pow(value, exponent),
    isOne = field.eql(result, field.ONE),
    isZero = field.eql(result, field.ZERO),
    isNegOne = field.eql(result, field.neg(field.ONE))
  if (!isOne && !isZero && !isNegOne)
    throw new Error('invalid Legendre symbol result')
  return isOne ? 1 : isZero ? 0 : -1
}
function getBitLengthInfo(value, bitLength) {
  if (bitLength !== void 0) assertPositiveInteger(bitLength)
  const bits = bitLength !== void 0 ? bitLength : value.toString(2).length,
    bytes = Math.ceil(bits / 8)
  return { nBitLength: bits, nByteLength: bytes }
}
function createField(
  order,
  options,
  isLittleEndian = !1,
  additionalOptions = {}
) {
  if (order <= ZERO)
    throw new Error(`invalid field: expected ORDER > 0, got ${order}`)
  let bitLength = void 0,
    sqrtFn = void 0,
    modFromBytes = !1,
    allowedLengths = void 0
  if (typeof options === 'object' && options != null) {
    if (additionalOptions.sqrt || isLittleEndian)
      throw new Error('cannot specify opts in two arguments')
    const opts = options
    if (opts.BITS) bitLength = opts.BITS
    if (opts.sqrt) sqrtFn = opts.sqrt
    if (typeof opts.isLE === 'boolean') isLittleEndian = opts.isLE
    if (typeof opts.modFromBytes === 'boolean') modFromBytes = opts.modFromBytes
    allowedLengths = opts.allowedLengths
  } else {
    if (typeof options === 'number') bitLength = options
    if (additionalOptions.sqrt) sqrtFn = additionalOptions.sqrt
  }
  const { nBitLength: bits, nByteLength: bytes } = getBitLengthInfo(
    order,
    bitLength
  )
  if (bytes > 2048)
    throw new Error('invalid field: expected ORDER of <= 2048 bytes')
  let sqrtMethod
  const field = Object.freeze({
    ORDER: order,
    isLE: isLittleEndian,
    BITS: bits,
    BYTES: bytes,
    MASK: createMask(bits),
    ZERO: ZERO,
    ONE: ONE,
    allowedLengths: allowedLengths,
    create: (value) => mod(value, order),
    isValid: (value) => {
      if (typeof value !== 'bigint')
        throw new Error(
          `invalid field element: expected bigint, got ${typeof value}`
        )
      return ZERO <= value && value < order
    },
    is0: (value) => value === ZERO,
    isValidNot0: (value) => !field.is0(value) && field.isValid(value),
    isOdd: (value) => (value & ONE) === ONE,
    neg: (value) => mod(-value, order),
    eql: (value1, value2) => value1 === value2,
    sqr: (value) => mod(value * value, order),
    add: (value1, value2) => mod(value1 + value2, order),
    sub: (value1, value2) => mod(value1 - value2, order),
    mul: (value1, value2) => mod(value1 * value2, order),
    pow: (base, exponent) => powMod(field, base, exponent),
    div: (numerator, denominator) =>
      mod(numerator * invert(denominator, order), order),
    sqrN: (value) => value * value,
    addN: (value1, value2) => value1 + value2,
    subN: (value1, value2) => value1 - value2,
    mulN: (value1, value2) => value1 * value2,
    inv: (value) => invert(value, order),
    sqrt:
      sqrtFn ||
      ((value) => {
        if (!sqrtMethod) sqrtMethod = getSquareRootMethod(order)
        return sqrtMethod(field, value)
      }),
    toBytes: (value) =>
      isLittleEndian
        ? bigIntToBytesLE(value, bytes)
        : bigIntToBytesBE(value, bytes),
    fromBytes: (inputBytes, validate = !0) => {
      if (allowedLengths) {
        if (!allowedLengths.includes(inputBytes.length) || inputBytes.length > bytes)
          throw new Error(
            `Field.fromBytes: expected ${allowedLengths} bytes, got ${inputBytes.length}`
          )
        const padded = new Uint8Array(bytes)
        padded.set(inputBytes, isLittleEndian ? 0 : padded.length - inputBytes.length),
          (inputBytes = padded)
      }
      if (inputBytes.length !== bytes)
        throw new Error(
          `Field.fromBytes: expected ${bytes} bytes, got ${inputBytes.length}`
        )
      let value = isLittleEndian ? bytesToBigIntLE(inputBytes) : bytesToBigInt(inputBytes)
      if (modFromBytes) value = mod(value, order)
      if (!validate) {
        if (!field.isValid(value))
          throw new Error('invalid field element: outside of range 0..ORDER')
      }
      return value
    },
    invertBatch: (values) => invertBatch(field, values),
    cmov: (value1, value2, condition) => (condition ? value2 : value1)
  })
  return Object.freeze(field)
}
function getFieldByteLength(order) {
  if (typeof order !== 'bigint') throw new Error('field order must be bigint')
  const bitLength = order.toString(2).length
  return Math.ceil(bitLength / 8)
}
function getScalarByteLength(order) {
  const fieldByteLength = getFieldByteLength(order)
  return fieldByteLength + Math.ceil(fieldByteLength / 2)
}
function _hashToScalar(input, order, isLittleEndian = !1) {
  const inputLength = input.length,
    fieldByteLength = getFieldByteLength(order),
    scalarByteLength = getScalarByteLength(order)
  if (inputLength < 16 || inputLength < scalarByteLength || inputLength > 1024)
    throw new Error(
      `expected ${scalarByteLength}-1024 bytes of input, got ${inputLength}`
    )
  const value = isLittleEndian ? bytesToBigIntLE(input) : bytesToBigInt(input),
    scalar = mod(value, order - ONE) + ONE
  return isLittleEndian
    ? bigIntToBytesLE(scalar, fieldByteLength)
    : bigIntToBytesBE(scalar, fieldByteLength)
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var ZERO = BigInt(0),
  ONE = BigInt(1),
  TWO = BigInt(2),
  THREE = BigInt(3),
  FOUR = BigInt(4),
  FIVE = BigInt(5),
  SEVEN = BigInt(7),
  EIGHT = BigInt(8),
  NINE = BigInt(9),
  SIXTEEN = BigInt(16)
var FIELD_METHODS = [
  'create',
  'isValid',
  'is0',
  'neg',
  'inv',
  'sqrt',
  'sqr',
  'eql',
  'add',
  'sub',
  'mul',
  'pow',
  'div',
  'addN',
  'subN',
  'mulN',
  'sqrN'
]
function selectByCondition(condition, value) {
  const negated = value.negate()
  return condition ? negated : value
}
function _normalizePoints(curve, points) {
  const inverses = invertBatch(
    curve.Fp,
    points.map((point) => point.Z)
  )
  return points.map((point, index) =>
    curve.fromAffine(point.toAffine(inverses[index]))
  )
}
var validateWindowSize = (windowSize, maxWindowSize) => {
    if (
      !Number.isSafeInteger(windowSize) ||
      windowSize <= 0 ||
      windowSize > maxWindowSize
    )
      throw new Error(
        `invalid window size, expected [1..${maxWindowSize}], got W=${windowSize}`
      )
  },
  getWindowConfig = (windowSize, bitLength) => {
    validateWindowSize(windowSize, bitLength)
    const windows = Math.ceil(bitLength / windowSize) + 1,
      windowSizeHalf = 2 ** (windowSize - 1),
      windowSizeFull = 2 ** windowSize,
      mask = createMask(windowSize),
      shiftBy = BigInt(windowSize)
    return {
      windows: windows,
      windowSize: windowSizeHalf,
      mask: mask,
      maxNumber: windowSizeFull,
      shiftBy: shiftBy
    }
  },
  getWindowDecomposition = (scalar, windowSize, config) => {
    const { windowSize: windowSizeHalf, mask, maxNumber, shiftBy } = config
    let value = Number(scalar & mask),
      nextScalar = scalar >> shiftBy
    if (value > windowSizeHalf) (value -= maxNumber), (nextScalar += ONE)
    const offset = windowSize * windowSizeHalf,
      index = offset + Math.abs(value) - 1,
      isZero = value === 0,
      isNeg = value < 0,
      isNegF = windowSize % 2 !== 0
    return {
      nextN: nextScalar,
      offset: index,
      isZero: isZero,
      isNeg: isNeg,
      isNegF: isNegF,
      offsetF: offset
    }
  },
  validatePoints = (points, pointClass) => {
    if (!Array.isArray(points)) throw new Error('array expected')
    points.forEach((point, index) => {
      if (!(point instanceof pointClass))
        throw new Error(`invalid point at index ${index}`)
    })
  },
  validateScalars = (scalars, field) => {
    if (!Array.isArray(scalars)) throw new Error('array of scalars expected')
    scalars.forEach((scalar, index) => {
      if (!field.isValid(scalar))
        throw new Error(`invalid scalar at index ${index}`)
    })
  },
  getPrecomputeWindowSize = (point) => WINDOW_SIZE_CACHE.get(point) || 1,
  validateWNAF = (point) => {
    if (point !== ZERO_POINT) throw new Error('invalid wNAF')
  }
function _doubleScalarBaseMul(curve, basePoint, scalar1, scalar2) {
  let point = basePoint,
    result1 = curve.ZERO,
    result2 = curve.ZERO
  while (scalar1 > ZERO || scalar2 > ZERO) {
    if (scalar1 & ONE) result1 = result1.add(point)
    if (scalar2 & ONE) result2 = result2.add(point)
    ;(point = point.double()), (scalar1 >>= ONE), (scalar2 >>= ONE)
  }
  return { p1: result1, p2: result2 }
}
function _multiScalarMul(curve, field, points, scalars) {
  validatePoints(points, curve), validateScalars(scalars, field)
  const numPoints = points.length,
    numScalars = scalars.length
  if (numPoints !== numScalars)
    throw new Error('arrays of points and scalars must have equal length')
  const result = curve.ZERO,
    bitLength = getBitLength(BigInt(numPoints))
  let windowSize = 1
  if (bitLength > 12) windowSize = bitLength - 3
  else if (bitLength > 4) windowSize = bitLength - 2
  else if (bitLength > 0) windowSize = 2
  const mask = createMask(windowSize),
    buckets = new Array(Number(mask) + 1).fill(result),
    maxBit = Math.floor((field.BITS - 1) / windowSize) * windowSize
  let acc = result
  for (let bit = maxBit; bit >= 0; bit -= windowSize) {
    buckets.fill(result)
    for (let index = 0; index < numScalars; index++) {
      const scalar = scalars[index],
        bucketIndex = Number((scalar >> BigInt(bit)) & mask)
      buckets[bucketIndex] = buckets[bucketIndex].add(points[index])
    }
    let sum = result
    for (let index = buckets.length - 1, temp = result; index > 0; index--)
      (temp = temp.add(buckets[index])), (sum = sum.add(temp))
    if (((acc = acc.add(sum)), bit !== 0))
      for (let index = 0; index < windowSize; index++) acc = acc.double()
  }
  return acc
}
var createFieldFromOptions = (order, fieldOptions, isLittleEndian) => {
  if (fieldOptions) {
    if (fieldOptions.ORDER !== order)
      throw new Error('Field.ORDER must match order: Fp == p, Fn == n')
    return validateField(fieldOptions), fieldOptions
  } else return createField(order, { isLE: isLittleEndian })
}
function _validateCurve(curveType, curve, options = {}, isLittleEndian) {
  if (isLittleEndian === void 0) isLittleEndian = curveType === 'edwards'
  if (!curve || typeof curve !== 'object')
    throw new Error(`expected valid ${curveType} CURVE object`)
  for (const param of ['p', 'n', 'h']) {
    const value = curve[param]
    if (!(typeof value === 'bigint' && value > ZERO))
      throw new Error(`CURVE.${param} must be positive bigint`)
  }
  const Fp = createFieldFromOptions(curve.p, options.Fp, isLittleEndian),
    Fn = createFieldFromOptions(curve.n, options.Fn, isLittleEndian),
    requiredParams = ['Gx', 'Gy', 'a', curveType === 'weierstrass' ? 'b' : 'd']
  for (const param of requiredParams)
    if (!Fp.isValid(curve[param]))
      throw new Error(`CURVE.${param} must be valid field element of CURVE.Fp`)
  return (
    (curve = Object.freeze(Object.assign({}, curve))),
    { CURVE: curve, Fp: Fp, Fn: Fn }
  )
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var ZERO_POINT = BigInt(0),
  ONE = BigInt(1),
  POINT_CACHE = new WeakMap(),
  WINDOW_SIZE_CACHE = new WeakMap()
class WNAF {
  constructor(pointClass, bitLength) {
    ;(this.BASE = pointClass.BASE),
      (this.ZERO = pointClass.ZERO),
      (this.Fn = pointClass.Fn),
      (this.bits = bitLength)
  }
  _unsafeLadder(point, scalar, result = this.ZERO) {
    let current = point
    while (scalar > ZERO) {
      if (scalar & ONE) result = result.add(current)
      ;(current = current.double()), (scalar >>= ONE)
    }
    return result
  }
  precomputeWindow(point, windowSize) {
    const { windows, windowSize: windowSizeHalf } = getWindowConfig(
        windowSize,
        this.bits
      ),
      precomputed = []
    let current = point,
      accumulator = current
    for (let windowIndex = 0; windowIndex < windows; windowIndex++) {
      ;(accumulator = current), precomputed.push(accumulator)
      for (let index = 1; index < windowSizeHalf; index++)
        (accumulator = accumulator.add(current)), precomputed.push(accumulator)
      current = accumulator.double()
    }
    return precomputed
  }
  wNAF(windowSize, precomputed, scalar) {
    if (!this.Fn.isValid(scalar)) throw new Error('invalid scalar')
    let result = this.ZERO,
      accumulatedBase = this.BASE
    const config = getWindowConfig(windowSize, this.bits)
    for (let windowIndex = 0; windowIndex < config.windows; windowIndex++) {
      const {
        nextN: nextScalar,
        offset,
        isZero,
        isNeg,
        isNegF,
        offsetF
      } = getWindowDecomposition(scalar, windowIndex, config)
      if (((scalar = nextScalar), isZero))
        accumulatedBase = accumulatedBase.add(
          selectByCondition(isNegF, precomputed[offsetF])
        )
      else result = result.add(selectByCondition(isNeg, precomputed[offset]))
    }
    return validateWNAF(scalar), { p: result, f: accumulatedBase }
  }
  wNAFUnsafe(windowSize, precomputed, scalar, result = this.ZERO) {
    const config = getWindowConfig(windowSize, this.bits)
    for (let windowIndex = 0; windowIndex < config.windows; windowIndex++) {
      if (scalar === ZERO) break
      const {
        nextN: nextScalar,
        offset,
        isZero,
        isNeg
      } = getWindowDecomposition(scalar, windowIndex, config)
      if (((scalar = nextScalar), isZero)) continue
      else {
        const point = precomputed[offset]
        result = result.add(isNeg ? point.negate() : point)
      }
    }
    return validateWNAF(scalar), result
  }
  getPrecomputes(windowSize, point, postprocess) {
    let precomputed = POINT_CACHE.get(point)
    if (!precomputed) {
      if (
        ((precomputed = this.precomputeWindow(point, windowSize)),
        windowSize !== 1)
      ) {
        if (typeof postprocess === 'function')
          precomputed = postprocess(precomputed)
        POINT_CACHE.set(point, precomputed)
      }
    }
    return precomputed
  }
  cached(windowSize, scalar, postprocess) {
    const actualWindowSize = getPrecomputeWindowSize(windowSize)
    return this.wNAF(
      actualWindowSize,
      this.getPrecomputes(actualWindowSize, windowSize, postprocess),
      scalar
    )
  }
  unsafe(windowSize, scalar, postprocess, result) {
    const actualWindowSize = getPrecomputeWindowSize(windowSize)
    if (actualWindowSize === 1)
      return this._unsafeLadder(windowSize, scalar, result)
    return this.wNAFUnsafe(
      actualWindowSize,
      this.getPrecomputes(actualWindowSize, windowSize, postprocess),
      scalar,
      result
    )
  }
  createCache(point, windowSize) {
    validateWindowSize(windowSize, this.bits),
      WINDOW_SIZE_CACHE.set(point, windowSize),
      POINT_CACHE.delete(point)
  }
  hasCache(windowSize) {
    return getPrecomputeWindowSize(windowSize) !== 1
  }
}
function _splitScalarEndomorphism(scalar, basises, field) {
  const [[beta1, beta2], [lambda1, lambda2]] = basises,
    term1 = mod(lambda2 * scalar, field),
    term2 = mod(-beta2 * scalar, field)
  let k1 = scalar - term1 * beta1 - term2 * lambda1,
    k2 = -term1 * beta2 - term2 * lambda2
  const k1neg = k1 < ZERO,
    k2neg = k2 < ZERO
  if (k1neg) k1 = -k1
  if (k2neg) k2 = -k2
  const maxScalar = createMask(Math.ceil(getBitLength(field) / 2)) + ONE
  if (k1 < ZERO || k1 >= maxScalar || k2 < ZERO || k2 >= maxScalar)
    throw new Error(`splitScalar (endomorphism): failed, k=${scalar}`)
  return { k1neg: k1neg, k1: k1, k2neg: k2neg, k2: k2 }
}
var validateSignatureFormat = (format) => {
    if (!['compact', 'recovered', 'der'].includes(format))
      throw new Error(
        'Signature format must be "compact", "recovered", or "der"'
      )
    return format
  },
  _mergeSignatureOptions = (options, defaults) => {
    const merged = {}
    for (const key of Object.keys(defaults))
      merged[key] = options[key] === void 0 ? defaults[key] : options[key]
    if (
      (assertBoolean(merged.lowS, 'lowS'),
      assertBoolean(merged.prehash, 'prehash'),
      merged.format !== void 0)
    )
      validateSignatureFormat(merged.format)
    return merged
  }
function _normalizePrivateKey(field, privateKey) {
  const { BYTES: byteLength } = field
  let scalar
  if (typeof privateKey === 'bigint') scalar = privateKey
  else {
    const privateKeyBytes = ensureBytesOrHex('private key', privateKey)
    try {
      scalar = field.fromBytes(privateKeyBytes)
    } catch (_error) {
      throw new Error(
        `invalid private key: expected ui8a of size ${byteLength}, got ${typeof privateKey}`
      )
    }
  }
  if (!field.isValidNot0(scalar))
    throw new Error('invalid private key: out of range [1..N-1]')
  return scalar
}
function createWeierstrassCurve(curveConfig, options = {}) {
  const validatedCurve = f$('weierstrass', curveConfig, options),
    { Fp: fieldPrime, Fn: fieldOrder } = validatedCurve
  const curve = validatedCurve.CURVE
  const { h: cofactor, n: order } = curve
  validateOptions(
    options,
    {},
    {
      allowInfinityPoint: 'boolean',
      clearCofactor: 'function',
      isTorsionFree: 'function',
      fromBytes: 'function',
      toBytes: 'function',
      endo: 'object',
      wrapPrivateKey: 'boolean'
    }
  )
  const { endo: endomorphism } = options
  if (endomorphism) {
    if (!fieldPrime.is0(curve.a) || typeof endomorphism.beta !== 'bigint' || !Array.isArray(endomorphism.basises))
      throw new Error(
        'invalid endo: expected "beta": bigint and "basises": array'
      )
  }
  const lengths = y$(fieldPrime, fieldOrder)
  function checkCompressionSupport() {
    if (!fieldPrime.isOdd)
      throw new Error(
        'compression is not supported: Field does not have .isOdd()'
      )
  }
  function pointToBytes(point, isCompressed, validate) {
    const { x: pointX, y: pointY } = point.toAffine(),
      xBytes = fieldPrime.toBytes(pointX)
    if ((assertBoolean(isCompressed, 'isCompressed'), isCompressed)) {
      checkCompressionSupport()
      const isEven = !fieldPrime.isOdd(pointY)
      return concatBytes(g$(isEven), xBytes)
    } else return concatBytes(Uint8Array.of(4), xBytes, fieldPrime.toBytes(pointY))
  }
  function bytesToPoint(bytes) {
    assertUint8Array(bytes, void 0, 'Point')
    const { publicKey: publicKeyLength, publicKeyUncompressed: uncompressedLength } = lengths,
      bytesLength = bytes.length,
      prefixByte = bytes[0],
      dataBytes = bytes.subarray(1)
    if (bytesLength === publicKeyLength && (prefixByte === 2 || prefixByte === 3)) {
      const x = fieldPrime.fromBytes(dataBytes)
      if (!fieldPrime.isValid(x)) throw new Error('bad point: is not on curve, wrong x')
      const ySquared = computeYSquared(x)
      let y
      try {
        y = fieldPrime.sqrt(ySquared)
      } catch (error) {
        const errorMsg = error instanceof Error ? `: ${error.message}` : ''
        throw new Error(`bad point: is not on curve, sqrt error${errorMsg}`)
      }
      checkCompressionSupport()
      const isOdd = fieldPrime.isOdd(y)
      if (((prefixByte & 1) === 1) !== isOdd) y = fieldPrime.neg(y)
      return { x, y }
    } else if (bytesLength === uncompressedLength && prefixByte === 4) {
      const fieldBytes = fieldPrime.BYTES,
        x = fieldPrime.fromBytes(dataBytes.subarray(0, fieldBytes)),
        y = fieldPrime.fromBytes(dataBytes.subarray(fieldBytes, fieldBytes * 2))
      if (!isPointOnCurve(x, y)) throw new Error('bad point: is not on curve')
      return { x, y }
    } else
      throw new Error(
        `bad point: got length ${bytesLength}, expected compressed=${publicKeyLength} or uncompressed=${uncompressedLength}`
      )
  }
  const pointToBytesFn = options.toBytes || pointToBytes,
    bytesToPointFn = options.fromBytes || bytesToPoint
  function computeYSquared(x) {
    const xSquared = fieldPrime.sqr(x),
      xCubed = fieldPrime.mul(xSquared, x)
    return fieldPrime.add(fieldPrime.add(xCubed, fieldPrime.mul(x, curve.a)), curve.b)
  }
  function isPointOnCurve(x, y) {
    const ySquared = fieldPrime.sqr(y),
      ySquaredExpected = computeYSquared(x)
    return fieldPrime.eql(ySquared, ySquaredExpected)
  }
  if (!isPointOnCurve(curve.Gx, curve.Gy)) throw new Error('bad curve params: generator point')
  const discriminantCheck1 = fieldPrime.mul(fieldPrime.pow(curve.a, THREE), FOUR),
    discriminantCheck2 = fieldPrime.mul(fieldPrime.sqr(curve.b), BigInt(27))
  if (fieldPrime.is0(fieldPrime.add(discriminantCheck1, discriminantCheck2))) throw new Error('bad curve params: a or b')
  function validateCoordinate(name, value, allowZero = !1) {
    if (!fieldPrime.isValid(value) || (allowZero && fieldPrime.is0(value)))
      throw new Error(`bad point coordinate ${name}`)
    return value
  }
  function assertProjectivePoint(point) {
    if (!(point instanceof ProjectivePoint)) throw new Error('ProjectivePoint expected')
  }
  function splitScalar(scalar) {
    if (!endomorphism || !endomorphism.basises) throw new Error('no endo')
    return bQ(scalar, endomorphism.basises, fieldOrder.ORDER)
  }
  const toAffineMemoized = m8((point, invZ) => {
      const { X: pointX, Y: pointY, Z: pointZ } = point
      if (fieldPrime.eql(pointZ, fieldPrime.ONE)) return { x: pointX, y: pointY }
      const isZero = point.is0()
      if (invZ == null) invZ = isZero ? fieldPrime.ONE : fieldPrime.inv(pointZ)
      const affineX = fieldPrime.mul(pointX, invZ),
        affineY = fieldPrime.mul(pointY, invZ),
        checkZ = fieldPrime.mul(pointZ, invZ)
      if (isZero) return { x: fieldPrime.ZERO, y: fieldPrime.ZERO }
      if (!fieldPrime.eql(checkZ, fieldPrime.ONE)) throw new Error('invZ was invalid')
      return { x: affineX, y: affineY }
    }),
    assertPointValid = m8((point) => {
      if (point.is0()) {
        if (options.allowInfinityPoint && !fieldPrime.is0(point.Y)) return
        throw new Error('bad point: ZERO')
      }
      const { x: pointX, y: pointY } = point.toAffine()
      if (!fieldPrime.isValid(pointX) || !fieldPrime.isValid(pointY))
        throw new Error('bad point: x or y not field elements')
      if (!isPointOnCurve(pointX, pointY)) throw new Error('bad point: equation left != right')
      if (!point.isTorsionFree())
        throw new Error('bad point: not in prime-order subgroup')
      return !0
    })
  function combineEndomorphismPoints(beta, point1, point2, k1neg, k2neg) {
    return (
      (point2 = new ProjectivePoint(fieldPrime.mul(point2.X, beta), point2.Y, point2.Z)),
      (point1 = k1neg ? point1.negate() : point1),
      (point2 = k2neg ? point2.negate() : point2),
      point1.add(point2)
    )
  }
  class ProjectivePoint {
    constructor(x, y, z) {
      ;(this.X = validateCoordinate('x', x)),
        (this.Y = validateCoordinate('y', y, !0)),
        (this.Z = validateCoordinate('z', z)),
        Object.freeze(this)
    }
    static CURVE() {
      return curve
    }
    static fromAffine(point) {
      const { x: pointX, y: pointY } = point || {}
      if (!point || !fieldPrime.isValid(pointX) || !fieldPrime.isValid(pointY))
        throw new Error('invalid affine point')
      if (point instanceof ProjectivePoint) throw new Error('projective point not allowed')
      if (fieldPrime.is0(pointX) && fieldPrime.is0(pointY)) return ProjectivePoint.ZERO
      return new ProjectivePoint(pointX, pointY, fieldPrime.ONE)
    }
    static fromBytes(bytes) {
      const point = ProjectivePoint.fromAffine(bytesToPointFn(assertUint8Array(bytes, void 0, 'point')))
      return point.assertValidity(), point
    }
    static fromHex(hex) {
      return ProjectivePoint.fromBytes(ensureBytesOrHex('pointHex', hex))
    }
    get x() {
      return this.toAffine().x
    }
    get y() {
      return this.toAffine().y
    }
    precompute(windowSize = 8, forceMultiply = !0) {
      if ((wnaf.createCache(this, windowSize), !forceMultiply)) this.multiply(THREE)
      return this
    }
    assertValidity() {
      assertPointValid(this)
    }
    hasEvenY() {
      const { y: pointY } = this.toAffine()
      if (!fieldPrime.isOdd) throw new Error("Field doesn't support isOdd")
      return !fieldPrime.isOdd(pointY)
    }
    equals(point) {
      assertProjectivePoint(point)
      const { X: thisX, Y: thisY, Z: thisZ } = this,
        { X: pointX, Y: pointY, Z: pointZ } = point,
        xEqual = fieldPrime.eql(fieldPrime.mul(thisX, pointZ), fieldPrime.mul(pointX, thisZ)),
        yEqual = fieldPrime.eql(fieldPrime.mul(thisY, pointZ), fieldPrime.mul(pointY, thisZ))
      return xEqual && yEqual
    }
    negate() {
      return new ProjectivePoint(this.X, fieldPrime.neg(this.Y), this.Z)
    }
    double() {
      const { a: curveA, b: curveB } = curve,
        bTimes3 = fieldPrime.mul(curveB, THREE),
        { X: pointX, Y: pointY, Z: pointZ } = this
      let { ZERO: newX, ZERO: newY, ZERO: newZ } = fieldPrime,
        xSquared = fieldPrime.mul(pointX, pointX),
        ySquared = fieldPrime.mul(pointY, pointY),
        zSquared = fieldPrime.mul(pointZ, pointZ),
        xy = fieldPrime.mul(pointX, pointY)
      return (
        (xy = fieldPrime.add(xy, xy)),
        (newZ = fieldPrime.mul(pointX, pointZ)),
        (newZ = fieldPrime.add(newZ, newZ)),
        (newX = fieldPrime.mul(curveA, newZ)),
        (newY = fieldPrime.mul(bTimes3, zSquared)),
        (newY = fieldPrime.add(newX, newY)),
        (newX = fieldPrime.sub(ySquared, newY)),
        (newY = fieldPrime.add(ySquared, newY)),
        (newY = fieldPrime.mul(newX, newY)),
        (newX = fieldPrime.mul(xy, newX)),
        (newZ = fieldPrime.mul(bTimes3, newZ)),
        (zSquared = fieldPrime.mul(curveA, zSquared)),
        (xy = fieldPrime.sub(xSquared, zSquared)),
        (xy = fieldPrime.mul(curveA, xy)),
        (xy = fieldPrime.add(xy, newZ)),
        (newZ = fieldPrime.add(xSquared, xSquared)),
        (xSquared = fieldPrime.add(newZ, xSquared)),
        (xSquared = fieldPrime.add(xSquared, zSquared)),
        (xSquared = fieldPrime.mul(xSquared, xy)),
        (newY = fieldPrime.add(newY, xSquared)),
        (zSquared = fieldPrime.mul(pointY, pointZ)),
        (zSquared = fieldPrime.add(zSquared, zSquared)),
        (xSquared = fieldPrime.mul(zSquared, xy)),
        (newX = fieldPrime.sub(newX, xSquared)),
        (newZ = fieldPrime.mul(zSquared, ySquared)),
        (newZ = fieldPrime.add(newZ, newZ)),
        (newZ = fieldPrime.add(newZ, newZ)),
        new ProjectivePoint(newX, newY, newZ)
      )
    }
    add(point) {
      assertProjectivePoint(point)
      const { X: thisX, Y: thisY, Z: thisZ } = this,
        { X: pointX, Y: pointY, Z: pointZ } = point
      let { ZERO: newX, ZERO: newY, ZERO: newZ } = fieldPrime
      const curveA = curve.a,
        bTimes3 = fieldPrime.mul(curve.b, THREE)
      let x1x2 = fieldPrime.mul(thisX, pointX),
        y1y2 = fieldPrime.mul(thisY, pointY),
        z1z2 = fieldPrime.mul(thisZ, pointZ),
        x1y1 = fieldPrime.add(thisX, thisY),
        x2y2 = fieldPrime.add(pointX, pointY)
      ;(x1y1 = fieldPrime.mul(x1y1, x2y2)),
        (x2y2 = fieldPrime.add(x1x2, y1y2)),
        (x1y1 = fieldPrime.sub(x1y1, x2y2)),
        (x2y2 = fieldPrime.add(thisX, thisZ))
      let y1z1 = fieldPrime.add(pointY, pointZ)
      return (
        (x2y2 = fieldPrime.mul(x2y2, y1z1)),
        (y1z1 = fieldPrime.add(x1x2, z1z2)),
        (x2y2 = fieldPrime.sub(x2y2, y1z1)),
        (y1z1 = fieldPrime.add(thisY, thisZ)),
        (newX = fieldPrime.add(pointY, pointZ)),
        (y1z1 = fieldPrime.mul(y1z1, newX)),
        (newX = fieldPrime.add(y1y2, z1z2)),
        (y1z1 = fieldPrime.sub(y1z1, newX)),
        (newZ = fieldPrime.mul(curveA, x2y2)),
        (newX = fieldPrime.mul(bTimes3, z1z2)),
        (newZ = fieldPrime.add(newX, newZ)),
        (newX = fieldPrime.sub(y1y2, newZ)),
        (newZ = fieldPrime.add(y1y2, newZ)),
        (newY = fieldPrime.mul(newX, newZ)),
        (y1y2 = fieldPrime.add(x1x2, x1x2)),
        (y1y2 = fieldPrime.add(y1y2, x1x2)),
        (z1z2 = fieldPrime.mul(curveA, z1z2)),
        (x2y2 = fieldPrime.mul(bTimes3, x2y2)),
        (y1y2 = fieldPrime.add(y1y2, z1z2)),
        (z1z2 = fieldPrime.sub(x1x2, z1z2)),
        (z1z2 = fieldPrime.mul(curveA, z1z2)),
        (x2y2 = fieldPrime.add(x2y2, z1z2)),
        (x1x2 = fieldPrime.mul(y1y2, x2y2)),
        (newY = fieldPrime.add(newY, x1x2)),
        (x1x2 = fieldPrime.mul(y1z1, x2y2)),
        (newX = fieldPrime.mul(x1y1, newX)),
        (newX = fieldPrime.sub(newX, x1x2)),
        (x1x2 = fieldPrime.mul(x1y1, y1y2)),
        (newZ = fieldPrime.mul(y1z1, newZ)),
        (newZ = fieldPrime.add(newZ, x1x2)),
        new ProjectivePoint(newX, newY, newZ)
      )
    }
    subtract(point) {
      return this.add(point.negate())
    }
    is0() {
      return this.equals(ProjectivePoint.ZERO)
    }
    multiply(scalar) {
      const { endo: endomorphism } = options
      if (!fieldOrder.isValidNot0(scalar)) throw new Error('invalid scalar: out of range')
      let result, accumulated
      const multiplyWithCache = (scalar) => wnaf.cached(this, scalar, (points) => _normalizePoints(ProjectivePoint, points))
      if (endomorphism) {
        const { k1neg: k1neg, k1: k1, k2neg: k2neg, k2: k2 } = splitScalar(scalar),
          { p: point1, f: accumulated1 } = multiplyWithCache(k1),
          { p: point2, f: accumulated2 } = multiplyWithCache(k2)
        ;(accumulated = accumulated1.add(accumulated2)), (result = combineEndomorphismPoints(endomorphism.beta, point1, point2, k1neg, k2neg))
      } else {
        const { p: point, f: accumulatedBase } = multiplyWithCache(scalar)
        ;(result = point), (accumulated = accumulatedBase)
      }
      return _normalizePoints(ProjectivePoint, [result, accumulated])[0]
    }
    multiplyUnsafe(scalar) {
      const { endo: endomorphism } = options
      if (!fieldOrder.isValid(scalar)) throw new Error('invalid scalar: out of range')
      if (scalar === ZERO || this.is0()) return ProjectivePoint.ZERO
      if (scalar === ONE) return this
      if (wnaf.hasCache(this)) return this.multiply(scalar)
      if (endomorphism) {
        const { k1neg: k1neg, k1: k1, k2neg: k2neg, k2: k2 } = splitScalar(scalar),
          { p1: point1, p2: point2 } = _doubleScalarBaseMul(ProjectivePoint, this, k1, k2)
        return combineEndomorphismPoints(endomorphism.beta, point1, point2, k1neg, k2neg)
      } else return wnaf.unsafe(this, scalar)
    }
    multiplyAndAddUnsafe(point, scalar1, scalar2) {
      const result = this.multiplyUnsafe(scalar1).add(point.multiplyUnsafe(scalar2))
      return result.is0() ? void 0 : result
    }
    toAffine(invZ) {
      return toAffineMemoized(this, invZ)
    }
    isTorsionFree() {
      const { isTorsionFree: isTorsionFreeFn } = options
      if (cofactor === ONE) return !0
      if (isTorsionFreeFn) return isTorsionFreeFn(ProjectivePoint, this)
      return wnaf.unsafe(this, order).is0()
    }
    clearCofactor() {
      const { clearCofactor: clearCofactorFn } = options
      if (cofactor === ONE) return this
      if (clearCofactorFn) return clearCofactorFn(ProjectivePoint, this)
      return this.multiplyUnsafe(cofactor)
    }
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0()
    }
    toBytes(isCompressed = !0) {
      return assertBoolean(isCompressed, 'isCompressed'), this.assertValidity(), pointToBytesFn(ProjectivePoint, this, isCompressed)
    }
    toHex(isCompressed = !0) {
      return bytesToHex(this.toBytes(isCompressed))
    }
    toString() {
      return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`
    }
    get px() {
      return this.X
    }
    get py() {
      return this.Y
    }
    get pz() {
      return this.Z
    }
    toRawBytes(isCompressed = !0) {
      return this.toBytes(isCompressed)
    }
    _setWindowSize(windowSize) {
      this.precompute(windowSize)
    }
    static normalizeZ(points) {
      return _normalizePoints(ProjectivePoint, points)
    }
    static msm(points, scalars) {
      return _multiScalarMul(ProjectivePoint, fieldOrder, points, scalars)
    }
    static fromPrivateKey(privateKey) {
      return ProjectivePoint.BASE.multiply(_normalizePrivateKey(fieldOrder, privateKey))
    }
  }
  ;(ProjectivePoint.BASE = new ProjectivePoint(curve.Gx, curve.Gy, fieldPrime.ONE)),
    (ProjectivePoint.ZERO = new ProjectivePoint(fieldPrime.ZERO, fieldPrime.ONE, fieldPrime.ZERO)),
    (ProjectivePoint.Fp = fieldPrime),
    (ProjectivePoint.Fn = fieldOrder)
  const fieldBits = fieldOrder.BITS,
    wnaf = new WNAF(ProjectivePoint, options.endo ? Math.ceil(fieldBits / 2) : fieldBits)
  return ProjectivePoint.BASE.precompute(8), ProjectivePoint
}
var getCompressionPrefix = (isEven) => Uint8Array.of(isEven ? 2 : 3)
var getKeyLengths = (fieldPrime, fieldOrder) => ({
  secretKey: fieldOrder.BYTES,
  publicKey: 1 + fieldPrime.BYTES,
  publicKeyUncompressed: 1 + 2 * fieldPrime.BYTES,
  publicKeyHasPrefix: !0,
  signature: 2 * fieldOrder.BYTES
})
function createECDH(curvePoint, options = {}) {
  const { Fn: fieldOrder } = curvePoint,
    randomBytes = options.randomBytes || _randomBytes,
    lengths = Object.assign(getKeyLengths(curvePoint.Fp, fieldOrder), { seed: getScalarByteLength(fieldOrder.ORDER) })
  function isValidSecretKey(privateKey) {
    try {
      return !!_normalizePrivateKey(fieldOrder, privateKey)
    } catch (_error) {
      return !1
    }
  }
  function isValidPublicKey(publicKey, isCompressed) {
    const { publicKey: compressedLength, publicKeyUncompressed: uncompressedLength } = lengths
    try {
      const keyLength = publicKey.length
      if (isCompressed === !0 && keyLength !== compressedLength) return !1
      if (isCompressed === !1 && keyLength !== uncompressedLength) return !1
      return !!curvePoint.fromBytes(publicKey)
    } catch (_error) {
      return !1
    }
  }
  function randomSecretKey(seed = randomBytes(lengths.seed)) {
    return _hashToScalar(assertUint8Array(seed, lengths.seed, 'seed'), fieldOrder.ORDER)
  }
  function getPublicKey(privateKey, isCompressed = !0) {
    return curvePoint.BASE.multiply(_normalizePrivateKey(fieldOrder, privateKey)).toBytes(isCompressed)
  }
  function keygen(seed) {
    const privateKey = randomSecretKey(seed)
    return { secretKey: privateKey, publicKey: getPublicKey(privateKey) }
  }
  function isPrivateKey(key) {
    if (typeof key === 'bigint') return !1
    if (key instanceof curvePoint) return !0
    const { secretKey: secretKeyLength, publicKey: compressedLength, publicKeyUncompressed: uncompressedLength } = lengths
    if (fieldOrder.allowedLengths || secretKeyLength === compressedLength) return
    const keyLength = ensureBytesOrHex('key', key).length
    return keyLength === compressedLength || keyLength === uncompressedLength
  }
  function getSharedSecret(privateKey, publicKey, isCompressed = !0) {
    if (isPrivateKey(privateKey) === !0) throw new Error('first arg must be private key')
    if (isPrivateKey(publicKey) === !1) throw new Error('second arg must be public key')
    const scalar = _normalizePrivateKey(fieldOrder, privateKey)
    return curvePoint.fromHex(publicKey).multiply(scalar).toBytes(isCompressed)
  }
  return Object.freeze({
    getPublicKey: getPublicKey,
    getSharedSecret: getSharedSecret,
    keygen: keygen,
    Point: curvePoint,
    utils: {
      isValidSecretKey: isValidSecretKey,
      isValidPublicKey: isValidPublicKey,
      randomSecretKey: randomSecretKey,
      isValidPrivateKey: isValidSecretKey,
      randomPrivateKey: randomSecretKey,
      normPrivateKeyToScalar: (privateKey) => _normalizePrivateKey(fieldOrder, privateKey),
      precompute(windowSize = 8, point = curvePoint.BASE) {
        return point.precompute(windowSize, !1)
      }
    },
    lengths: lengths
  })
}
function createECDSA(curvePoint, hashFn, options = {}) {
  assertHash(hashFn),
    validateOptions(
      options,
      {},
      {
        hmac: 'function',
        lowS: 'boolean',
        randomBytes: 'function',
        bits2int: 'function',
        bits2int_modN: 'function'
      }
    )
  const randomBytes = options.randomBytes || _randomBytes,
    hmacFn = options.hmac || ((key, ...data) => hmac(hashFn, key, concatBytes(...data))),
    { Fp: fieldPrime, Fn: fieldOrder } = curvePoint,
    { ORDER: order, BITS: orderBits } = fieldOrder,
    {
      keygen: keygen,
      getPublicKey: getPublicKey,
      getSharedSecret: getSharedSecret,
      utils: utils,
      lengths: lengths
    } = createECDH(curvePoint, options),
    defaultOptions = {
      prehash: !1,
      lowS: typeof options.lowS === 'boolean' ? options.lowS : !1,
      format: void 0,
      extraEntropy: !1
    },
    defaultFormat = 'compact'
  function hasHighS(s) {
    const halfOrder = order >> ONE
    return s > halfOrder
  }
  function validateSignatureComponent(name, value) {
    if (!fieldOrder.isValidNot0(value))
      throw new Error(`invalid signature ${name}: out of range 1..Point.Fn.ORDER`)
    return value
  }
  function assertSignatureBytes(signature, format) {
    validateSignatureFormat(format)
    const expectedLength = lengths.signature,
      actualLength = format === 'compact' ? expectedLength : format === 'recovered' ? expectedLength + 1 : void 0
    return assertUint8Array(signature, actualLength, `${format} signature`)
  }
  class Signature {
    constructor(r, s, recovery) {
      if (((this.r = validateSignatureComponent('r', r)), (this.s = validateSignatureComponent('s', s)), recovery != null))
        this.recovery = recovery
      Object.freeze(this)
    }
    static fromBytes(signature, format = defaultFormat) {
      assertSignatureBytes(signature, format)
      let recovery
      if (format === 'der') {
        const { r: rValue, s: sValue } = D0.toSig(assertUint8Array(signature))
        return new Signature(rValue, sValue)
      }
      if (format === 'recovered') (recovery = signature[0]), (format = 'compact'), (signature = signature.subarray(1))
      const fieldBytes = fieldOrder.BYTES,
        rBytes = signature.subarray(0, fieldBytes),
        sBytes = signature.subarray(fieldBytes, fieldBytes * 2)
      return new Signature(fieldOrder.fromBytes(rBytes), fieldOrder.fromBytes(sBytes), recovery)
    }
    static fromHex(hex, format) {
      return Signature.fromBytes(hexToBytes(hex), format)
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery)
    }
    recoverPublicKey(messageHash) {
      const primeOrder = fieldPrime.ORDER,
        { r: rValue, s: sValue, recovery: recoveryId } = this
      if (recoveryId == null || ![0, 1, 2, 3].includes(recoveryId))
        throw new Error('recovery id invalid')
      if (order * TWO < primeOrder && recoveryId > 1)
        throw new Error('recovery id is ambiguous for h>1 curve')
      const x = recoveryId === 2 || recoveryId === 3 ? rValue + order : rValue
      if (!fieldPrime.isValid(x)) throw new Error('recovery id 2 or 3 invalid')
      const xBytes = fieldPrime.toBytes(x),
        point = curvePoint.fromBytes(concatBytes(getCompressionPrefix((recoveryId & 1) === 0), xBytes)),
        rInv = fieldOrder.inv(x),
        messageScalar = _hashToScalar(ensureBytesOrHex('msgHash', messageHash)),
        u1 = fieldOrder.create(-messageScalar * rInv),
        u2 = fieldOrder.create(sValue * rInv),
        pointResult = curvePoint.BASE.multiplyUnsafe(u1).add(point.multiplyUnsafe(u2))
      if (pointResult.is0()) throw new Error('point at infinify')
      return pointResult.assertValidity(), pointResult
    }
    hasHighS() {
      return hasHighS(this.s)
    }
    toBytes(format = defaultFormat) {
      if ((validateSignatureFormat(format), format === 'der')) return hexToBytes(D0.hexFromSig(this))
      const rBytes = fieldOrder.toBytes(this.r),
        sBytes = fieldOrder.toBytes(this.s)
      if (format === 'recovered') {
        if (this.recovery == null)
          throw new Error('recovery bit must be present')
        return concatBytes(Uint8Array.of(this.recovery), rBytes, sBytes)
      }
      return concatBytes(rBytes, sBytes)
    }
    toHex(format) {
      return bytesToHex(this.toBytes(format))
    }
    assertValidity() {}
    static fromCompact(signature) {
      return Signature.fromBytes(ensureBytesOrHex('sig', signature), 'compact')
    }
    static fromDER(signature) {
      return Signature.fromBytes(ensureBytesOrHex('sig', signature), 'der')
    }
    normalizeS() {
      return this.hasHighS()
        ? new Signature(this.r, fieldOrder.neg(this.s), this.recovery)
        : this
    }
    toDERRawBytes() {
      return this.toBytes('der')
    }
    toDERHex() {
      return bytesToHex(this.toBytes('der'))
    }
    toCompactRawBytes() {
      return this.toBytes('compact')
    }
    toCompactHex() {
      return bytesToHex(this.toBytes('compact'))
    }
  }
  const bits2int =
      options.bits2int ||
      function bytesToInt(bytes) {
        if (bytes.length > 8192) throw new Error('input is too large')
        const value = bytesToBigInt(bytes),
          shiftBits = bytes.length * 8 - orderBits
        return shiftBits > 0 ? value >> BigInt(shiftBits) : value
      },
    bits2int_modN =
      options.bits2int_modN ||
      function bytesToIntModN(bytes) {
        return fieldOrder.create(bits2int(bytes))
      },
    bits2int_modN_bytes = _hashToScalar(orderBits)
  function intToBytes(num) {
    return _assertInRange(`num < 2^${orderBits}`, num, ZERO, bits2int_modN_bytes), fieldOrder.toBytes(num)
  }
  function prepareMessage(message, prehash) {
    return (
      ensureBytes(message, void 0, 'message'), prehash ? ensureBytes(hashFn(message), void 0, 'prehashed message') : message
    )
  }
  function signWithK(message, privateKey, options) {
    if (['recovered', 'canonical'].some((option) => option in options))
      throw new Error('sign() legacy options not supported')
    const { lowS: lowS, prehash: prehash, extraEntropy: extraEntropy } = _mergeSignatureOptions(options, defaultOptions)
    message = prepareMessage(message, prehash)
    const messageInt = bits2int_modN(message),
      privateKeyInt = _normalizePrivateKey(fieldOrder, privateKey),
      seed = [intToBytes(privateKeyInt), intToBytes(messageInt)]
    if (extraEntropy != null && extraEntropy !== !1) {
      const entropyBytes = extraEntropy === !0 ? randomBytes(lengths.secretKey) : extraEntropy
      seed.push(ensureBytesOrHex('extraEntropy', entropyBytes))
    }
    const seedBytes = concatBytes(...seed),
      messageIntForK = messageInt
    function k2sig(kBytes) {
      const k = bits2int(kBytes)
      if (!fieldOrder.isValidNot0(k)) return
      const kInv = fieldOrder.inv(k),
        point = curvePoint.BASE.multiply(k).toAffine(),
        rx = fieldOrder.create(point.x)
      if (rx === ZERO) return
      const s = fieldOrder.create(kInv * fieldOrder.create(messageIntForK + rx * privateKeyInt))
      if (s === ZERO) return
      let recovery = (point.x === rx ? 0 : 2) | Number(point.y & ONE),
        r = s
      if (lowS && hasHighS(s)) (r = fieldOrder.neg(s)), (recovery ^= 1)
      return new Signature(rx, r, recovery)
    }
    return { seed: seedBytes, k2sig: k2sig }
  }
  function sign(message, privateKey, options = {}) {
    message = ensureBytesOrHex('message', message)
    const { seed: seedBytes, k2sig: k2sigFn } = signWithK(message, privateKey, options)
    return _createDRBG(hashFn.outputLen, fieldOrder.BYTES, hmacFn)(seedBytes, k2sigFn)
  }
  function parseSignature(signature) {
    let sig = void 0
    const isString = typeof signature === 'string' || isUint8Array(signature),
      isObject =
        !isString &&
        signature !== null &&
        typeof signature === 'object' &&
        typeof signature.r === 'bigint' &&
        typeof signature.s === 'bigint'
    if (!isString && !isObject)
      throw new Error(
        'invalid signature, expected Uint8Array, hex string or Signature instance'
      )
    if (isObject) sig = new Signature(signature.r, signature.s)
    else if (isString) {
      try {
        sig = Signature.fromBytes(ensureBytesOrHex('sig', signature), 'der')
      } catch (error) {
        if (!(error instanceof D0.Err)) throw error
      }
      if (!sig)
        try {
          sig = Signature.fromBytes(ensureBytesOrHex('sig', signature), 'compact')
        } catch (_error) {
          return !1
        }
    }
    if (!sig) return !1
    return sig
  }
  function verify(signature, message, publicKey, options = {}) {
    const { lowS: lowS, prehash: prehash, format: format } = _mergeSignatureOptions(options, defaultOptions)
    if (((publicKey = ensureBytesOrHex('publicKey', publicKey)), (message = prepareMessage(ensureBytesOrHex('message', message), prehash)), 'strict' in options))
      throw new Error('options.strict was renamed to lowS')
    const sig = format === void 0 ? parseSignature(signature) : Signature.fromBytes(ensureBytesOrHex('sig', signature), format)
    if (sig === !1) return !1
    try {
      const point = curvePoint.fromBytes(publicKey)
      if (lowS && sig.hasHighS()) return !1
      const { r: rValue, s: sValue } = sig,
        messageInt = bits2int_modN(message),
        sInv = fieldOrder.inv(sValue),
        u1 = fieldOrder.create(messageInt * sInv),
        u2 = fieldOrder.create(rValue * sInv),
        pointResult = curvePoint.BASE.multiplyUnsafe(u1).add(point.multiplyUnsafe(u2))
      if (pointResult.is0()) return !1
      return fieldOrder.create(pointResult.x) === rValue
    } catch (_error) {
      return !1
    }
  }
  function recoverPublicKey(signature, message, options = {}) {
    const { prehash: prehash } = _mergeSignatureOptions(options, defaultOptions)
    return (
      (message = prepareMessage(message, prehash)), Signature.fromBytes(signature, 'recovered').recoverPublicKey(message).toBytes()
    )
  }
  return Object.freeze({
    keygen: keygen,
    getPublicKey: getPublicKey,
    getSharedSecret: getSharedSecret,
    utils: utils,
    lengths: lengths,
    Point: curvePoint,
    sign: sign,
    verify: verify,
    recoverPublicKey: recoverPublicKey,
    Signature: Signature,
    hash: hashFn
  })
}
var getCurveOptions = (curve) => {
    const curveParams = {
        a: curve.a,
        b: curve.b,
        p: curve.Fp.ORDER,
        n: curve.n,
        h: curve.h,
        Gx: curve.Gx,
        Gy: curve.Gy
      },
      fieldPrime = curve.Fp
    const allowedLengths = curve.allowedPrivateKeyLengths
      ? Array.from(
          new Set(curve.allowedPrivateKeyLengths.map((length) => Math.ceil(length / 2)))
        )
      : void 0
    const fieldOrder = createField(curveParams.n, {
        BITS: curve.nBitLength,
        allowedLengths: allowedLengths,
        modFromBytes: curve.wrapPrivateKey
      }),
      curveOptions = {
        Fp: fieldPrime,
        Fn: fieldOrder,
        allowInfinityPoint: curve.allowInfinityPoint,
        endo: curve.endo,
        isTorsionFree: curve.isTorsionFree,
        clearCofactor: curve.clearCofactor,
        fromBytes: curve.fromBytes,
        toBytes: curve.toBytes
      }
    return { CURVE: curveParams, curveOpts: curveOptions }
  },
  getECDSAOptions = (curve) => {
    const { CURVE: curveParams, curveOpts: curveOptions } = getCurveOptions(curve),
      ecdsaOptions = {
        hmac: curve.hmac,
        randomBytes: curve.randomBytes,
        lowS: curve.lowS,
        bits2int: curve.bits2int,
        bits2int_modN: curve.bits2int_modN
      }
    return { CURVE: curveParams, curveOpts: curveOptions, hash: curve.hash, ecdsaOpts: ecdsaOptions }
  }
var finalizeCurve = (curve, ecdsa) => {
  const pointClass = ecdsa.Point
  return Object.assign({}, ecdsa, {
    ProjectivePoint: pointClass,
    CURVE: Object.assign({}, curve, createField(pointClass.Fn.ORDER, pointClass.Fn.BITS))
  })
}
function createCurve(curve) {
  const { CURVE: curveParams, curveOpts: curveOptions, hash: hashFn, ecdsaOpts: ecdsaOptions } = getECDSAOptions(curve),
    weierstrassCurve = createWeierstrassCurve(curveParams, curveOptions),
    ecdsa = createECDSA(weierstrassCurve, hashFn, ecdsaOptions)
  return finalizeCurve(curve, ecdsa)
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var normalizeMod = (value, modulus) => (value + (value >= 0 ? modulus : -modulus) / TWO) / modulus
class DERError extends Error {
  constructor(message = '') {
    super(message)
  }
}
var DERUtils = {
    Err: DERError,
    _tlv: {
      encode: (tag, data) => {
        const { Err: ErrorClass } = DERUtils
        if (tag < 0 || tag > 256) throw new ErrorClass('tlv.encode: wrong tag')
        if (data.length & 1) throw new ErrorClass('tlv.encode: unpadded data')
        const dataLength = data.length / 2,
          lengthHex = bytesToHex(dataLength)
        if ((lengthHex.length / 2) & 128)
          throw new ErrorClass('tlv.encode: long form length too big')
        const lengthPrefix = dataLength > 127 ? bytesToHex((lengthHex.length / 2) | 128) : ''
        return bytesToHex(tag) + lengthPrefix + lengthHex + data
      },
      decode: (tag, data) => {
        const { Err: ErrorClass } = DERUtils
        let offset = 0
        if (tag < 0 || tag > 256) throw new ErrorClass('tlv.encode: wrong tag')
        if (data.length < 2 || data[offset++] !== tag) throw new ErrorClass('tlv.decode: wrong tlv')
        const lengthByte = data[offset++],
          isLongForm = !!(lengthByte & 128)
        let valueLength = 0
        if (!isLongForm) valueLength = lengthByte
        else {
          const lengthBytesCount = lengthByte & 127
          if (!lengthBytesCount)
            throw new ErrorClass('tlv.decode(long): indefinite length not supported')
          if (lengthBytesCount > 4) throw new ErrorClass('tlv.decode(long): byte length is too big')
          const lengthBytes = data.subarray(offset, offset + lengthBytesCount)
          if (lengthBytes.length !== lengthBytesCount)
            throw new ErrorClass('tlv.decode: length bytes not complete')
          if (lengthBytes[0] === 0) throw new ErrorClass('tlv.decode(long): zero leftmost byte')
          for (const byte of lengthBytes) valueLength = (valueLength << 8) | byte
          if (((offset += lengthBytesCount), valueLength < 128))
            throw new ErrorClass('tlv.decode(long): not minimal encoding')
        }
        const value = data.subarray(offset, offset + valueLength)
        if (value.length !== valueLength) throw new ErrorClass('tlv.decode: wrong value length')
        return { v: value, l: data.subarray(offset + valueLength) }
      }
    },
    _int: {
      encode: (value) => {
        const { Err: ErrorClass } = DERUtils
        if (value < ZERO) throw new ErrorClass('integer: negative integers are not allowed')
        let hex = bytesToHex(value)
        if (Number.parseInt(hex[0], 16) & 8) hex = `00${hex}`
        if (hex.length & 1)
          throw new ErrorClass('unexpected DER parsing assertion: unpadded hex')
        return hex
      },
      decode: (data) => {
        const { Err: ErrorClass } = DERUtils
        if (data[0] & 128) throw new ErrorClass('invalid signature integer: negative')
        if (data[0] === 0 && !!(data[1] & 128))
          throw new ErrorClass('invalid signature integer: unnecessary leading zero')
        return hexToBigInt(data)
      }
    },
    toSig: (data) => {
      const { Err: ErrorClass, _int: intUtils, _tlv: tlvUtils } = DERUtils,
        signatureData = ensureBytes('signature', data),
        { v: sequenceData, l: remaining } = tlvUtils.decode(48, signatureData)
      if (remaining.length) throw new ErrorClass('invalid signature: left bytes after parsing')
      const { v: rData, l: remainingAfterR } = tlvUtils.decode(2, sequenceData),
        { v: sData, l: remainingAfterS } = tlvUtils.decode(2, remainingAfterR)
      if (remainingAfterS.length) throw new ErrorClass('invalid signature: left bytes after parsing')
      return { r: intUtils.decode(rData), s: intUtils.decode(sData) }
    },
    hexFromSig: (signature) => {
      const { _tlv: tlvUtils, _int: intUtils } = DERUtils,
        rHex = tlvUtils.encode(2, intUtils.encode(signature.r)),
        sHex = tlvUtils.encode(2, intUtils.encode(signature.s)),
        combined = rHex + sHex
      return tlvUtils.encode(48, combined)
    }
  },
  ZERO = BigInt(0),
  ONE = BigInt(1),
  TWO = BigInt(2),
  THREE = BigInt(3),
  FOUR = BigInt(4)
function createCurveWithHash(curveConfig, hashFn) {
  const createWithHash = (hash) => createCurve({ ...curveConfig, hash: hash })
  return { ...createWithHash(hashFn), create: createWithHash }
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var sqrtModP = (value) => {
    const prime = secp256k1Curve.p,
      three = BigInt(3),
      six = BigInt(6),
      eleven = BigInt(11),
      twentyTwo = BigInt(22),
      twentyThree = BigInt(23),
      fortyFour = BigInt(44),
      eightyEight = BigInt(88),
      v1 = (value * value * value) % prime,
      v2 = (v1 * v1 * value) % prime,
      v3 = (powMod(v2, three, prime) * v2) % prime,
      v4 = (powMod(v3, three, prime) * v2) % prime,
      v5 = (powMod(v4, TWO, prime) * v1) % prime,
      v6 = (powMod(v5, eleven, prime) * v5) % prime,
      v7 = (powMod(v6, twentyTwo, prime) * v6) % prime,
      v8 = (powMod(v7, fortyFour, prime) * v7) % prime,
      v9 = (powMod(v8, eightyEight, prime) * v8) % prime,
      v10 = (powMod(v9, fortyFour, prime) * v7) % prime,
      v11 = (powMod(v10, three, prime) * v2) % prime,
      v12 = (powMod(v11, twentyThree, prime) * v6) % prime,
      v13 = (powMod(v12, six, prime) * v1) % prime,
      result = powMod(v13, TWO, prime)
    if (!secp256k1Field.eql(secp256k1Field.sqr(result), value)) throw new Error('Cannot find square root')
    return result
  },
  taggedHash = (tag, ...data) => {
    let hash = hashCache[tag]
    if (hash === void 0) {
      const tagHash = sha256(hexToBytes(tag))
      ;(hash = sha256(concatBytes(tagHash, tagHash))), (hashCache[tag] = hash)
    }
    return sha256(concatBytes(hash, ...data))
  },
  pointFromScalar = (scalar) => {
    const { Fn: fieldOrder, BASE: basePoint } = secp256k1Point,
      normalizedScalar = normalizePrivateKey(fieldOrder, scalar),
      point = basePoint.multiply(normalizedScalar)
    return { scalar: isEven(point.y) ? normalizedScalar : fieldOrder.neg(normalizedScalar), bytes: pointToBytes(point) }
  },
  liftX = (x) => {
    const field = secp256k1Field
    if (!field.isValidNot0(x)) throw new Error('invalid x: Fail if x \u2265 p')
    const xSquared = field.create(x * x),
      ySquared = field.create(xSquared * x + BigInt(7))
    let y = field.sqrt(ySquared)
    if (!isEven(y)) y = field.neg(y)
    const point = secp256k1Point.fromAffine({ x: x, y: y })
    return point.assertValidity(), point
  },
  createChallenge = (...data) => secp256k1Point.Fn.create(hexToBigInt(taggedHash('BIP0340/challenge', ...data))),
  pointToBytes = (scalar) => pointFromScalar(scalar).bytes,
  sign = (message, privateKey, auxRand = randomBytes(32)) => {
    const { Fn: fieldOrder } = secp256k1Point,
      messageBytes = ensureBytes('message', message),
      { bytes: publicKeyBytes, scalar: secretKey } = pointFromScalar(privateKey),
      auxRandBytes = ensureBytes('auxRand', auxRand, 32),
      tweakedKey = fieldOrder.toBytes(secretKey ^ hexToBigInt(taggedHash('BIP0340/aux', auxRandBytes))),
      nonceHash = taggedHash('BIP0340/nonce', tweakedKey, publicKeyBytes, messageBytes),
      { bytes: nonceBytes, scalar: nonce } = pointFromScalar(nonceHash),
      challenge = createChallenge(nonceBytes, publicKeyBytes, messageBytes),
      signature = new Uint8Array(64)
    if ((signature.set(nonceBytes, 0), signature.set(fieldOrder.toBytes(fieldOrder.create(nonce + challenge * secretKey)), 32), !verifySignature(signature, messageBytes, publicKeyBytes)))
      throw new Error('sign: Invalid signature produced')
    return signature
  },
  verifySignature = (signature, message, publicKey) => {
    const { Fn: fieldOrder, BASE: basePoint } = secp256k1Point,
      signatureBytes = ensureBytes('signature', signature, 64),
      messageBytes = ensureBytes('message', message),
      publicKeyBytes = ensureBytes('publicKey', publicKey, 32)
    try {
      const point = liftX(hexToBigInt(publicKeyBytes)),
        rx = hexToBigInt(signatureBytes.subarray(0, 32))
      if (!isInRange(rx, ZERO, secp256k1Curve.p)) return !1
      const s = hexToBigInt(signatureBytes.subarray(32, 64))
      if (!isInRange(s, ZERO, secp256k1Curve.n)) return !1
      const challenge = createChallenge(fieldOrder.toBytes(rx), pointToBytes(point), messageBytes),
        computedPoint = basePoint.multiplyUnsafe(s).add(point.multiplyUnsafe(fieldOrder.neg(challenge))),
        { x: computedX, y: computedY } = computedPoint.toAffine()
      if (computedPoint.is0() || !isEven(computedY) || computedX !== rx) return !1
      return !0
    } catch (_error) {
      return !1
    }
  } /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var secp256k1Curve = {
    p: BigInt(
      '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'
    ),
    n: BigInt(
      '0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'
    ),
    h: BigInt(1),
    a: BigInt(0),
    b: BigInt(7),
    Gx: BigInt(
      '0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'
    ),
    Gy: BigInt(
      '0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8'
    )
  },
  secp256k1Endomorphism = {
    beta: BigInt(
      '0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'
    ),
    basises: [
      [
        BigInt('0x3086d221a7d46bcde86c90e49284eb15'),
        -BigInt('0xe4437ed6010e88286f547fa90abfe4c3')
      ],
      [
        BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8'),
        BigInt('0x3086d221a7d46bcde86c90e49284eb15')
      ]
    ]
  },
  ZERO = BigInt(0),
  ONE = BigInt(1),
  TWO = BigInt(2),
  secp256k1Field = createField(secp256k1Curve.p, { sqrt: sqrtModP }),
  secp256k1CurveWithHash = createCurveWithHash({ ...secp256k1Curve, Fp: secp256k1Field, lowS: !0, endo: secp256k1Endomorphism }, sha256),
  hashCache = {},
  pointToBytes = (point) => point.toBytes(!0).slice(1),
  secp256k1Point = (() => secp256k1CurveWithHash.Point)(),
  isEven = (value) => value % TWO === ZERO,
  hexToBigInt = bytesToBigInt,
  secp256k1 = (() => {
    const randomScalar = (seed = randomBytes(48)) => {
      return _hashToScalar(seed, secp256k1Curve.n)
    }
    secp256k1CurveWithHash.utils.randomSecretKey
    function keygen(seed) {
      const privateKey = randomScalar(seed)
      return { secretKey: privateKey, publicKey: pointToBytes(privateKey) }
    }
    return {
      keygen: keygen,
      getPublicKey: pointToBytes,
      sign: sign,
      verify: verifySignature,
      Point: secp256k1Point,
      utils: {
        randomSecretKey: randomScalar,
        randomPrivateKey: randomScalar,
        taggedHash: taggedHash,
        lift_x: liftX,
        pointToBytes: pointToBytes,
        numberToBytesBE: bigIntToBytesBE,
        bytesToNumberBE: bytesToBigInt,
        mod: mod
      },
      lengths: {
        secretKey: 32,
        publicKey: 32,
        publicKeyHasPrefix: !1,
        signature: 64,
        seed: 48
      }
    }
  })()
var textEncoder = new TextEncoder(),
  textDecoder = new TextDecoder(),
  encodeText = (text) => textEncoder.encode(text),
  decodeText = (data) => textDecoder.decode(data),
  bytesToHex = (bytes) => Array.from(bytes, (byte) => byte.toString(16).padStart(2, '0')).join(''),
  stringify = JSON.stringify,
  parse = JSON.parse,
  hashString = (str, max = Number.MAX_SAFE_INTEGER) =>
    str.split('').reduce((hash, char) => hash + char.charCodeAt(0), 0) % max
var AES_GCM = 'AES-GCM',
  hashCache = {},
  delimiter = '$',
  arraySeparator = ',',
  bytesToBase64 = (data) => {
    const uint8Array = new Uint8Array(data)
    let result = ''
    for (let i = 0; i < uint8Array.length; i += 32768)
      result += String.fromCharCode(...uint8Array.subarray(i, i + 32768))
    return btoa(result)
  },
  base64ToBuffer = (base64) => Uint8Array.from(atob(base64), (char) => char.charCodeAt(0)).buffer,
  getHash = (key) =>
    (hashCache[key] ??= crypto.subtle.digest('SHA-1', encodeText(key)).then((hash) => {
      const hashArray = new Uint8Array(hash),
      let hashString = ''
      for (const byte of hashArray) hashString += byte.toString(36)
      return hashString
    })),
  deriveKey = async (appId, roomId, password) => {
    const keyMaterial = await crypto.subtle.digest('SHA-256', encodeText(`${appId}:${roomId}:${password}`))
    return crypto.subtle.importKey('raw', keyMaterial, { name: AES_GCM }, !1, [
      'encrypt',
      'decrypt'
    ])
  },
  encrypt = async (key, data) => {
    const iv = crypto.getRandomValues(new Uint8Array(12)),
      keyMaterial = await key,
      encrypted = await crypto.subtle.encrypt({ name: AES_GCM, iv: iv }, keyMaterial, encodeText(data))
    return `${iv.join(arraySeparator)}${delimiter}${bytesToBase64(encrypted)}`
  },
  decrypt = async (key, encryptedData) => {
    const [ivString, encryptedString] = encryptedData.split(delimiter)
    if (!ivString || !encryptedString) throw new Error('Invalid encrypted payload format')
    const iv = Uint8Array.from(ivString.split(arraySeparator), Number),
      keyMaterial = await key,
      decrypted = await crypto.subtle.decrypt({ name: AES_GCM, iv: iv }, keyMaterial, base64ToBuffer(encryptedString))
    return decodeText(decrypted)
  }
var APP_NAME = 'GenosRTC',
  createArray = (length, fn) => Array.from({ length: length }, fn)
var randomString = (length) =>
    Array.from(
      crypto.getRandomValues(new Uint8Array(length)),
      (charIndex) =>
        '0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz'[
          charIndex %
            '0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz'
              .length
        ]
    ).join(''),
  SELF_ID = randomString(20),
  promiseAll = Promise.all.bind(Promise),
  isBrowser = typeof window !== 'undefined',
  { entries: objectEntries, fromEntries: objectFromEntries, keys: objectKeys } = Object,
  noop = () => {},
  createError = (message) => new Error(`GenosRTC: ${message}`),
  joinWithSeparator = (...parts) => parts.join('@'),
  shuffleArray = (array, seed) => {
    const result = [...array]
    let length = result.length
    const random = () => {
      const value = Math.sin(seed++) * 1e4
      return value - Math.floor(value)
    }
    while (length) {
      const value = Math.floor(random() * length--)
      ;[result[length], result[value]] = [result[value], result[length]]
    }
    return result
  }
var ICE_GATHERING_TIMEOUT = 5000,
  ICE_GATHERING_STATE_CHANGE = 'icegatheringstatechange',
  OFFER = 'offer',
  ANSWER = 'answer',
  DEFAULT_STUN_SERVERS = [
    ...createArray(3, (_, index) => `stun:stun${index || ''}.l.google.com:19302`),
    'stun:stun.cloudflare.com:3478'
  ].map((url) => ({ urls: url })),
  createPeerConnection = (isInitiator, { rtcConfig: config, rtcPolyfill: polyfill, turnConfig: turnServers }) => {
    const connection = new (polyfill || RTCPeerConnection)({
        iceServers: [...DEFAULT_STUN_SERVERS, ...(turnServers || [])],
        ...config
      }),
      handlers = {}
    let negotiating = !1,
      settingRemoteDescription = !1,
      dataChannel
    const setupDataChannel = (channel) =>
        Object.assign(channel, {
          binaryType: 'arraybuffer',
          bufferedAmountLowThreshold: 65535,
          onmessage: (event) => handlers.data?.(event.data),
          onopen: () => handlers.connect?.(),
          onclose: () => handlers.close?.(),
          onerror: (event) =>
            !event?.error?.message?.includes('User-Initiated Abort') && handlers.error?.(event)
        }),
      waitForIceGathering = () =>
        Promise.race([
          new Promise((resolve) => {
            const handler = () => {
              if (connection.iceGatheringState === 'complete')
                connection.removeEventListener(ICE_GATHERING_STATE_CHANGE, handler), resolve()
            }
            connection.addEventListener(ICE_GATHERING_STATE_CHANGE, handler), handler()
          }),
          new Promise((resolve) => setTimeout(resolve, ICE_GATHERING_TIMEOUT))
        ]).then(() => ({
          type: connection.localDescription.type,
          sdp: connection.localDescription.sdp.replace(/a=ice-options:trickle\s\n/g, '')
        }))
    if (
      (isInitiator
        ? setupDataChannel((dataChannel = connection.createDataChannel('data')))
        : (connection.ondatachannel = ({ channel: channel }) => setupDataChannel((dataChannel = channel))),
      (connection.onnegotiationneeded = async () => {
        try {
          ;(negotiating = !0), await connection.setLocalDescription(), handlers.signal?.(await waitForIceGathering())
        } catch (error) {
          handlers.error?.(error)
        } finally {
          negotiating = !1
        }
      }),
      (connection.onconnectionstatechange = () => {
        if (['disconnected', 'failed', 'closed'].includes(connection.connectionState))
          handlers.close?.()
      }),
      (connection.ontrack = (event) => {
        handlers.track?.(event.track, event.streams[0]), handlers.stream?.(event.streams[0])
      }),
      (connection.onremovestream = (event) => handlers.stream?.(event.stream)),
      isInitiator && !connection.canTrickleIceCandidates)
    )
      connection.onnegotiationneeded()
    const getSenders = () => connection.getSenders()
    return {
      created: Date.now(),
      connection: connection,
      get channel() {
        return dataChannel
      },
      get isDead() {
        return connection.connectionState === 'closed'
      },
      async signal(sessionDescription) {
        if (dataChannel?.readyState === 'open' && !sessionDescription.sdp?.includes('a=rtpmap')) return
        try {
          if (sessionDescription.type === OFFER) {
            if (negotiating || (connection.signalingState !== 'stable' && !settingRemoteDescription)) {
              if (isInitiator) return
              await promiseAll([
                connection.setLocalDescription({ type: 'rollback' }),
                connection.setRemoteDescription(sessionDescription)
              ])
            } else await connection.setRemoteDescription(sessionDescription)
            await connection.setLocalDescription()
            const localDescription = await waitForIceGathering()
            return handlers.signal?.(localDescription), localDescription
          }
          if (sessionDescription.type === ANSWER) {
            settingRemoteDescription = !0
            try {
              await connection.setRemoteDescription(sessionDescription)
            } finally {
              settingRemoteDescription = !1
            }
          }
        } catch (error) {
          handlers.error?.(error)
        }
      },
      sendData: (data) => dataChannel.send(data),
      destroy: () => {
        dataChannel?.close(), connection.close(), (negotiating = settingRemoteDescription = !1)
      },
      setHandlers: (newHandlers) => Object.assign(handlers, newHandlers),
      offerPromise: isInitiator
        ? new Promise((resolve) => (handlers.signal = (sessionDescription) => sessionDescription.type === OFFER && resolve(sessionDescription)))
        : Promise.resolve(),
      addStream: (stream) => stream.getTracks().forEach((track) => connection.addTrack(track, stream)),
      removeStream: (stream) =>
        getSenders()
          .filter((sender) => stream.getTracks().includes(sender.track))
          .forEach((sender) => connection.removeTrack(sender)),
      addTrack: (track, stream) => connection.addTrack(track, stream),
      removeTrack: (track) => {
        const sender = getSenders().find((sender) => sender.track === track)
        if (sender) connection.removeTrack(sender)
      },
      replaceTrack: (oldTrack, newTrack) =>
        getSenders()
          .find((sender) => sender.track === oldTrack)
          ?.replaceTrack(newTrack)
    }
  }
var uint8ArrayPrototype = Object.getPrototypeOf(Uint8Array),
  HEADER_SIZE = 12,
  TYPE_OFFSET = 0,
  NONCE_OFFSET = TYPE_OFFSET + HEADER_SIZE,
  FLAGS_OFFSET = NONCE_OFFSET + 1,
  PROGRESS_OFFSET = FLAGS_OFFSET + 1,
  DATA_OFFSET = PROGRESS_OFFSET + 1,
  MAX_CHUNK_SIZE = 16384 - DATA_OFFSET,
  MAX_PROGRESS = 255,
  BUFFERED_AMOUNT_LOW = 'bufferedamountlow',
  ACTION_PREFIX = ($) => `@_${$}`,
  MAX_CHUNKS = 100,
  MAX_RETRIES = 3,
  RETRY_DELAY = 200,
  createChannelManager = (onPeer, onLeave, cleanup) => {
    const peers = new Map(),
      peerData = new Map(),
      actionChannels = new Map(),
      peerHandlers = {},
      streamHandlers = {},
      trackHandlers = {},
      eventListeners = new Map(),
      addEventListener = (peerId, handler) => {
        if (!eventListeners.has(peerId)) eventListeners.set(peerId, new Set())
        eventListeners.get(peerId).add(handler)
      },
      removeEventListener = (peerId, handler) => eventListeners.get(peerId)?.delete(handler),
      emitEvent = (peerId, ...args) => eventListeners.get(peerId)?.forEach((handler) => handler(...args)),
      withPeers = (peerIds, callback) => {
        const ids = peerIds ? (Array.isArray(peerIds) ? peerIds : [peerIds]) : peers.keys()
        return Array.from(ids, (id) => {
          const peer = peers.get(id)
          if (!peer) return console.warn(`${APP_NAME}: no peer with id ${id}`), null
          return callback(id, peer)
        }).filter(Boolean)
      },
      removePeer = (peerId) => {
        if (!peers.has(peerId)) return
        peers.delete(peerId),
          delete peerHandlers[peerId],
          delete streamHandlers[peerId],
          delete trackHandlers[peerId],
          delete actionChannels[peerId],
          emitEvent('peer:leave', peerId),
        onLeave(peerId)
      },
      E = (Y) =>
        new Promise((D, C) => {
          const x = setTimeout(() => {
            Y.removeEventListener($$, T),
              C(new Error(`${a}: bufferLow timeout`))
          }, 5000)
          function T() {
            clearTimeout(x), Y.removeEventListener($$, T), D()
          }
          Y.addEventListener($$, T)
        }),
      v = (Y) => {
        if (z.has(Y)) return z.get(Y)
        if (!Y) throw J0('action type is required')
        const D = j0(Y)
        if (D.byteLength > w8)
          throw J0(`\u274C "${Y}" exceeds ${w8} bytes. Use a shorter name.`)
        const C = new Uint8Array(w8).map((_P, f) => D[f] || 0)
        let x = 0
        const T = new Map([
            ['message', new Set()],
            ['progress', new Set()]
          ]),
          R = (P, f) => T.get(P)?.add(f),
          g = (P, f) => T.get(P)?.delete(f),
          k = async (P, f, b, y) => {
            if (b && typeof b !== 'object') throw J0('meta must be object')
            if (P === void 0) throw J0('data cannot be undefined')
            const u = P instanceof Blob,
              F = u || P instanceof ArrayBuffer || P instanceof $J,
              t = typeof P !== 'string'
            if (b && !F) throw J0('meta only allowed with binary')
            const z0 = F
                ? new Uint8Array(u ? await P.arrayBuffer() : P)
                : j0(t ? e(P) : P),
              r = b ? j0(e(b)) : null,
              d = Math.ceil(z0.byteLength / J8) + (b ? 1 : 0) || 1
            if (d > Q$) throw J0(`Message too large, exceeds max chunks ${Q$}`)
            const G$ = F0(d, (_U8, U0) => {
              const c0 = U0 === d - 1,
                L0 = b && U0 === 0,
                j8 = L0
                  ? r
                  : z0.subarray(
                      b ? (U0 - 1) * J8 : U0 * J8,
                      b ? U0 * J8 : (U0 + 1) * J8
                    ),
                T0 = new Uint8Array(G8 + j8.byteLength)
              return (
                T0.set(C),
                T0.set([x], I8),
                T0.set([c0 | (L0 << 1) | (F << 2) | (t << 3)], k8),
                T0.set([Math.round(((U0 + 1) / d) * A8)], q8),
                T0.set(j8, G8),
                T0
              )
            })
            return (
              (x = (x + 1) & A8),
              V0(
                H(f, async (U8, U0) => {
                  const { channel: c0 } = U0
                  for (let L0 = 0; L0 < d; L0++) {
                    let j8 = 0
                    while (c0.bufferedAmount > c0.bufferedAmountLowThreshold) {
                      if (j8++ > QJ)
                        throw J0(
                          `${a}: send buffer full, max retries reached for peer ${U8}`
                        )
                      try {
                        await E(c0)
                      } catch (T0) {
                        console.warn(T0.message),
                          await new Promise((HQ) => setTimeout(HQ, JJ))
                      }
                    }
                    if (!Q.has(U8)) break
                    U0.sendData(G$[L0]), y?.(G$[L0][q8] / A8, U8, b)
                  }
                })
              )
            )
          }
        G.set(Y, { listeners: T, send: k })
        const w = { send: k, on: R, off: g }
        return z.set(Y, w), w
      },
      q0 = (Y, D) => {
        try {
          const C = new Uint8Array(D),
            x = f0(C.subarray(GQ, I8)).replace(/ /g, '')
          if (!G.has(x)) return console.warn(`${a}: unregistered type (${x})`)
          const [T] = C.subarray(I8, k8),
            [R] = C.subarray(k8, q8),
            [g] = C.subarray(q8, G8),
            k = C.subarray(G8),
            w = Boolean(R & 1),
            P = Boolean(R & 2),
            f = Boolean(R & 4),
            b = Boolean(R & 8),
            y = G.get(x),
            u = ((U[Y] ||= {})[x] ||= {})
          if (u[T]?.chunks?.length > Q$) {
            console.warn(
              `${a}: peer ${Y} sent too many chunks for nonce ${T}, ignoring.`
            )
            return
          }
          const F = (u[T] ||= { chunks: [] })
          if (P)
            try {
              F.meta = v0(f0(k))
            } catch {
              console.warn(
                `${a}: failed to parse meta from peer ${Y} for type ${x}`
              )
              return
            }
          else F.chunks.push(k)
          if (
            (y.listeners.get('progress').forEach((r) => {
              try {
                r(g / A8, Y, F.meta)
              } catch (d) {
                console.error(d)
              }
            }),
            !w)
          )
            return
          const t = new Uint8Array(
            F.chunks.reduce((r, d) => r + d.byteLength, 0)
          )
          F.chunks.reduce((r, d) => (t.set(d, r), r + d.byteLength), 0),
            delete u[T]
          let z0
          if (f) z0 = t
          else if (b)
            try {
              z0 = v0(f0(t))
            } catch {
              console.warn(
                `${a}: failed to parse JSON message data from peer ${Y} for type ${x}`
              )
              return
            }
          else z0 = f0(t)
          y.listeners.get('message').forEach((r) => {
            try {
              r(z0, Y, F.meta)
            } catch (d) {
              console.error(d)
            }
          })
        } catch (C) {
          console.error(`${a}: error handling data from peer ${Y}:`, C)
        }
      },
      _ = async () => {
        try {
          await M(''), await new Promise((Y) => setTimeout(Y, 99))
        } catch (Y) {
          console.warn(`${a}: error sending leave`, Y)
        }
        for (const [Y, D] of Q) {
          try {
            D.destroy()
          } catch {}
          Q.delete(Y)
        }
        q()
      },
      { send: n, on: c } = v(h0('ping')),
      { send: s, on: C0 } = v(h0('pong')),
      { send: G0, on: I } = v(h0('signal')),
      { send: Y0, on: S } = v(h0('stream')),
      { send: W, on: O } = v(h0('track')),
      { send: M, on: B } = v(h0('leave'))
    if (
      ($((Y, D) => {
        if (Q.has(D)) return
        Q.set(D, Y),
          Y.setHandlers({
            data: (C) => q0(D, C),
            stream: (C) => {
              K('stream:add', C, D, Z[D]), delete Z[D]
            },
            track: (C, x) => {
              K('track:add', C, x, D, V[D]), delete V[D]
            },
            signal: (C) => G0(C, D),
            close: () => A(D),
            error: (C) => {
              console.error(`${a}: peer error for ${D}`, C), A(D)
            }
          }),
          K('peer:join', D)
      }),
      c('message', (_Y, D) => s('', D)),
      C0('message', (_Y, D) => {
        X[D]?.(), delete X[D]
      }),
      I('message', (Y, D) => Q.get(D)?.signal(Y)),
      S('message', (Y, D) => (Z[D] = Y)),
      O('message', (Y, D) => (V[D] = Y)),
      B('message', (_Y, D) => A(D)),
      t$)
    )
      addEventListener('beforeunload', _)
    return {
      on: L,
      off: j,
      channel: v,
      leave: _,
      ping: async (Y) => {
        if (!Y) throw J0('ping() requires target peer ID')
        const D = Date.now()
        return n('', Y), await new Promise((C) => (X[Y] = C)), Date.now() - D
      },
      getPeers: () => R8(Array.from(Q, ([Y, D]) => [Y, D.connection])),
      addStream: (Y, D, C) =>
        H(D, async (x, T) => {
          if (C) await Y0(C, x)
          T.addStream(Y)
        }),
      removeStream: (Y, D) => H(D, (_C, x) => x.removeStream(Y)),
      addTrack: (Y, D, C, x) =>
        H(C, async (T, R) => {
          if (x) await W(x, T)
          R.addTrack(Y, D)
        }),
      removeTrack: (Y, D) => H(D, (_C, x) => x.removeTrack(Y)),
      replaceTrack: (Y, D, C, x) =>
        H(C, async (T, R) => {
          if (x) await W(x, T)
          R.replaceTrack(Y, D)
        })
    }
  }
var qJ = 20,
  GJ = 5333,
  UQ = 57333,
  jQ = ({ init: $, subscribe: J, announce: q }) => {
    const Q = {}
    let G = !1,
      z,
      U
    return (X, Z, V) => {
      const { appId: N } = X
      if (Q[N]?.[Z]) return Q[N][Z]
      if (!X || !Z || (!N && !X.firebaseApp))
        throw J0(
          !X ? 'config required' : !Z ? 'roomId required' : 'appId missing'
        )
      let L = $Q
      if (!G) {
        const S = $(X)
        ;(U = F0(qJ, () => L8(!0, X))), (z = Array.isArray(S) ? S : [S])
        const W = setInterval(() => {
          U = U.filter((O) => {
            const M = Date.now() - O.created < UQ
            if (!M) O.destroy()
            return M
          })
        }, UQ)
        ;(Q.offerCleanupTimer ||= W), (G = !0)
      }
      const j = {},
        K = {},
        H = Q8(a, N, Z),
        A = e0(H),
        E = e0(Q8(H, N0)),
        v = a$(X.password || '', N, Z),
        q0 = (S) => async (W) => ({ type: W.type, sdp: await S(v, W.sdp) }),
        _ = q0(s$),
        n = q0(n$),
        c = (S, W) => {
          if (K[W] === S) return
          K[W]?.destroy(),
            (K[W] = S),
            L(S, W),
            j[W]?.forEach((O) => O !== S && O.destroy()),
            delete j[W]
        },
        s = (S, W) => {
          if (K[W] === S) delete K[W]
        },
        C0 = (S) => async (W, O, M) => {
          const [B, Y] = await V0([A, E])
          if (W !== B && W !== Y) return
          const {
            peerId: D,
            offer: C,
            answer: x
          } = typeof O === 'string' ? v0(O) : O
          if (D === N0 || K[D]) return
          if (C) {
            if (j[D]?.[S] && N0 > D) return
            const T = L8(!1, X)
            T.setHandlers({ connect: () => c(T, D), close: () => s(T, D) })
            try {
              const R = await _(C)
              if (T.isDead) return
              const [g, k] = await V0([e0(Q8(H, D)), T.signal(R).then(n)])
              M(g, e({ peerId: N0, answer: k }))
            } catch {
              V?.({
                error: 'decryption failed (offer)',
                appId: N,
                peerId: D,
                roomId: Z
              })
            }
          } else if (x) {
            const T = j[D]?.[S]
            if (!T || T.isDead) return
            T.setHandlers({ connect: () => c(T, D), close: () => s(T, D) })
            try {
              T.signal(await _(x))
            } catch {
              V?.({
                error: 'decryption failed (answer)',
                appId: N,
                peerId: D,
                roomId: Z
              })
            }
          } else {
            if (j[D]?.[S]) return
            const T = U.pop() || L8(!0, X),
              [R, { offer: g }] = await V0([
                e0(Q8(H, D)),
                T.offerPromise.then(n).then((k) => ({ offer: k }))
              ])
            ;(j[D] ||= []),
              (j[D][S] = T),
              T.setHandlers({ connect: () => c(T, D), close: () => s(T, D) }),
              M(R, e({ peerId: N0, offer: g, peer: T }))
          }
        },
        G0 = V0(z.map(async (S, W) => J(await S, await A, await E, C0(W)))),
        I = []
      G0.then((S) => {
        z.forEach((W, O) => {
          const M = async () => {
            const B = await q(await W, await A, await E)
            I[O] = setTimeout(M, typeof B === 'number' ? B : GJ)
          }
          M()
        }),
          (Q[N][Z].onCleanup = () => {
            if (
              (delete Q[N][Z],
              I.forEach(clearTimeout),
              S.forEach((W) => W()),
              Object.keys(Q).length === 0)
            )
              clearInterval(Q.offerCleanupTimer), delete Q.offerCleanupTimer
          })
      }),
        (Q[N] ||= {})
      const Y0 = zQ(
        (S) => (L = S),
        (S) => delete K[S],
        () => Y0.onCleanup?.()
      )
      return (Q[N][Z] = Y0)
    }
  }
var YQ = 3333,
  S8 = {},
  XQ = {},
  ZQ = ($, J) => {
    const q = {}
    let Q = null
    const G = () => {
      if (Q) clearTimeout(Q), (Q = null)
      const z = new WebSocket($)
      ;(z.onclose = () => {
        ;(S8[$] ??= YQ), (Q = setTimeout(G, S8[$])), (S8[$] *= 2)
      }),
        (z.onmessage = (U) => J(U.data)),
        (q.socket = z),
        (q.url = z.url),
        (q.ready = new Promise((U) => {
          z.onopen = () => {
            ;(S8[$] = YQ), U(q)
          }
        })),
        (q.send = (U) => {
          if (z.readyState === 1) z.send(U)
        })
    }
    return (q.forceReconnect = G), G(), (XQ[$] = q), q
  }
if (typeof window !== 'undefined') {
  const $ = () => {
    console.info(
      '\u26A1 [GenosRTC] Network event detected. Forcing reconnection\u2026'
    ),
      Object.values(XQ).forEach((J) => {
        if (
          J.socket &&
          J.socket.readyState !== WebSocket.OPEN &&
          J.socket.readyState !== WebSocket.CONNECTING
        )
          J.forceReconnect()
      })
  }
  window.addEventListener('online', () => {
    console.info('\u2705 Reconnected to the network.'), $()
  }),
    window.addEventListener('offline', async () => {
      console.info('\u274C Disconnected from the network.')
    }),
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') $()
    })
}
var KQ = ($) => () => R8(e$($).map(([J, q]) => [J, q.socket])),
  MQ = ($, J, q, Q) =>
    ($.relayUrls ?? (Q ? QQ(J, O8($.appId)) : J)).slice(
      0,
      $.relayUrls?.length ?? $.relayRedundancy ?? q
    )
var l0 = {},
  zJ = 5,
  VQ = 'x',
  CQ = 'EVENT',
  UJ = /pow:\s*(\d+)\s*bits needed\.?/i,
  J$ = new Set(),
  TQ = x8.utils.randomSecretKey(),
  jJ = H8(x8.getPublicKey(TQ)),
  q$ = {},
  z8 = {},
  YJ = {},
  BQ = () => Math.floor(Date.now() / 1000),
  xQ = ($) => (YJ[$] ??= O8($, 1e4) + 20000),
  P8 = ($) => $.replace(/\/$/, ''),
  XJ = [
    'wss://black.nostrcity.club',
    'wss://eu.purplerelay.com',
    'wss://ftp.halifax.rwth-aachen.de/nostr',
    'wss://nostr.cool110.xyz',
    'wss://nostr.data.haus',
    'wss://nostr.mom',
    'wss://nostr.oxtr.dev',
    'wss://nostr.sathoarder.com',
    'wss://nostr.vulpem.com',
    'wss://relay.agorist.space',
    'wss://relay.binaryrobot.com',
    'wss://relay.fountain.fm',
    'wss://relay.mostro.network',
    'wss://relay.nostraddress.com',
    'wss://relay.nostrdice.com',
    'wss://relay.nostromo.social',
    'wss://relay.oldenburg.cool',
    'wss://relay.snort.social',
    'wss://relay.verified-nostr.com',
    'wss://sendit.nosflare.com',
    'wss://yabu.me/v2',
    'wss://relay.damus.io'
  ],
  ZJ = ($, J) => {
    const [q, Q, G, z] = v0(J)
    if (q === CQ) return z8[Q]?.(q$[Q], G.content)
    if (q === 'NOTICE' || (q === 'OK' && !G)) {
      if (+((q === 'NOTICE' ? Q : z).match(UJ)?.[1] ?? 0) > 0) {
        const X = P8($)
        J$.add(X), l0[X]?.close?.(), delete l0[X]
      }
    }
  },
  KJ = ($) => {
    const J = P8($)
    if (l0[J]) return l0[J]
    const q = ZQ(J, (Q) => ZJ(J, Q))
    return (l0[J] = q)
  },
  DQ = async ($, J) => {
    const q = {
        kind: xQ($),
        content: J,
        pubkey: jJ,
        created_at: BQ(),
        tags: [[VQ, $]]
      },
      Q = j0(e([0, q.pubkey, q.created_at, q.kind, q.tags, q.content])),
      G = new Uint8Array(await crypto.subtle.digest('SHA-256', Q)),
      z = x8.sign(G, TQ)
    return e([CQ, { ...q, id: H8(G), sig: H8(z) }])
  },
  WQ = ($, J) => {
    return (
      (q$[$] = J),
      e(['REQ', $, { kinds: [xQ(J)], since: BQ(), [`#${VQ}`]: [J] }])
    )
  },
  NQ = ($) => {
    return delete q$[$], e(['CLOSE', $])
  },
  MJ = jQ({
    init: ($) => {
      const q = ($?.relayUrls?.length ? $.relayUrls : null) ?? XJ
      return MQ($, q, zJ, !0)
        .map(KJ)
        .map((G) => G.ready.then(() => G).catch(() => null))
    },
    subscribe: ($, J, q, Q) => {
      const G = $8(64),
        z = $8(64)
      return (
        (z8[G] = z8[z] =
          (U, X) =>
            Q(U, X, async (Z, V) => {
              if (J$.has(P8($.url))) return
              $.send(await DQ(Z, V))
            })),
        $.send(WQ(G, J)),
        $.send(WQ(z, q)),
        () => {
          $.send(NQ(G)), $.send(NQ(z)), delete z8[G], delete z8[z]
        }
      )
    },
    announce: async ($, J) => {
      if (J$.has(P8($.url))) return
      $.send(await DQ(J, e({ peerId: N0 })))
    }
  }),
  DJ = KQ(l0)
export { N0 as selfId, MJ as join, DJ as getRelaySockets }
