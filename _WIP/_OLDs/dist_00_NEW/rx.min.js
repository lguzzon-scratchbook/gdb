function S(H = {}) {
  let indexStore = {}
  let fragmentedIndexes = {}
  const maxIndexSize = H.maxSize || 1048576
  const encodeFunction = H.encode
  const decodeFunction = H.decode
  const compressionLibrary = H.pako
  function Z(key, value) {
    _(value).forEach((prefix) => {
      if (!indexStore[prefix]) {
        indexStore[prefix] = []
      }
      if (!indexStore[prefix].includes(key)) {
        indexStore[prefix].push(key)
      }
    })
    if (JSON.stringify(indexStore).length > maxIndexSize) {
      T()
    }
  }
  function X(key, value) {
    _(value).forEach((prefix) => {
      if (indexStore[prefix]) {
        indexStore[prefix] = indexStore[prefix].filter(
          (element) => element !== key
        )
        if (indexStore[prefix].length === 0) {
          delete indexStore[prefix]
        }
      }
    })
  }
  function _(input) {
    const prefixes = []
    if (typeof input === 'string') {
      for (let index = 1; index <= input.length; index++) {
        prefixes.push(input.substring(0, index))
      }
    } else if (typeof input === 'number') {
      prefixes.push(String(input))
    } else if (typeof input === 'object' && input !== null) {
      Object.keys(input).forEach((key) => {
        prefixes.push(key.toString())
        const propertyValue = input[key]
        if (
          typeof propertyValue === 'string' ||
          typeof propertyValue === 'number'
        ) {
          prefixes.push(`${key}:${propertyValue}`)
        }
      })
    }
    return prefixes
  }
  function T() {
    const allKeys = Object.keys(indexStore)
    const splitPoint = Math.ceil(allKeys.length / 2)
    const firstFragment = {}
    const secondFragment = {}
    allKeys.slice(0, splitPoint).forEach((key) => {
      firstFragment[key] = indexStore[key]
    })
    allKeys.slice(splitPoint).forEach((key) => {
      secondFragment[key] = indexStore[key]
    })
    fragmentedIndexes.fragment1 = firstFragment
    fragmentedIndexes.fragment2 = secondFragment
    indexStore = {}
  }
  function B() {
    for (const fragment of Object.values(fragmentedIndexes)) {
      Object.assign(indexStore, fragment)
    }
    fragmentedIndexes = {}
  }
  function O(prefix) {
    return indexStore[prefix] || []
  }
  function V(prefix) {
    return Object.keys(indexStore)
      .filter((key) => key.startsWith(prefix))
      .flatMap((key) => indexStore[key])
  }
  function D() {
    if (!encodeFunction || !compressionLibrary) {
      throw new Error('Radix: encode y pako deben estar en options')
    }
    const serializableData = {
      index: indexStore,
      fragmentedIndexes: fragmentedIndexes
    }
    return compressionLibrary.deflate(encodeFunction(serializableData))
  }
  function U(compressedData) {
    if (!decodeFunction || !compressionLibrary) {
      throw new Error('Radix: decode y pako deben estar en options')
    }
    const inflatedData = compressionLibrary.inflate(
      new Uint8Array(compressedData)
    )
    const parsedData = decodeFunction(inflatedData)
    indexStore = parsedData.index || {}
    fragmentedIndexes = parsedData.fragmentedIndexes || {}
  }
  function W() {
    if (JSON.stringify(indexStore).length > maxIndexSize) {
      throw new Error('Index too large')
    }
    if (!indexStore || typeof indexStore !== 'object') {
      indexStore = {}
    }
  }
  return {
    upsert: Z,
    remove: X,
    extractPrefixes: _,
    splitIndex: T,
    mergeFragments: B,
    searchByPrefix: O,
    searchAllByPrefix: V,
    serialize: D,
    deserialize: U,
    validateIndex: W
  }
}
function z(H) {
  const {
    worker: workerInstance,
    encode: encodeFunction,
    decode: decodeFunction,
    pako: compressionLibrary
  } = H
  const indexInstance = S({
    maxSize: H.maxSize || 1048576,
    encode: encodeFunction,
    decode: decodeFunction,
    pako: compressionLibrary
  })
  const indexFileName = H.indexFileName || 'graph_radix_index.msgpack'
  const debouncedSave = ((callback, delay) => {
    let timeoutId
    return (...args) => {
      clearTimeout(timeoutId)
      timeoutId = setTimeout(() => callback.apply(null, args), delay)
    }
  })(() => saveIndex(), 200)
  async function loadIndex() {
    try {
      const loadedData = await new Promise((resolve, reject) => {
        const messageHandler = (event) => {
          if (
            event.data.type === 'loaded' &&
            event.data.name === indexFileName
          ) {
            workerInstance.removeEventListener('message', messageHandler)
            resolve(new Uint8Array(event.data.data))
          } else if (event.data.type === 'error') {
            workerInstance.removeEventListener('message', messageHandler)
            reject(
              new Error(event.data.message || 'Error loading the Radix index')
            )
          }
        }
        workerInstance.addEventListener('message', messageHandler)
        workerInstance.postMessage({
          type: 'load',
          name: indexFileName
        })
      })
      if (loadedData.byteLength > 0) {
        indexInstance.deserialize(loadedData)
      }
    } catch {}
  }
  async function saveIndex() {
    try {
      const serializedData = indexInstance.serialize()
      await new Promise((resolve, reject) => {
        const messageHandler = (event) => {
          if (
            event.data.type === 'saved' &&
            event.data.name === indexFileName
          ) {
            workerInstance.removeEventListener('message', messageHandler)
            resolve()
          } else if (event.data.type === 'error') {
            workerInstance.removeEventListener('message', messageHandler)
            reject(
              new Error(event.data.message || 'Error saving the Radix index')
            )
          }
        }
        workerInstance.addEventListener('message', messageHandler)
        workerInstance.postMessage({
          type: 'save',
          name: indexFileName,
          content: serializedData
        })
      })
    } catch {}
  }
  async function populateIndex() {
    try {
      indexInstance.validateIndex()
      ;(typeof H.graph?.getAllNodes === 'function'
        ? await H.graph.getAllNodes()
        : Object.values(H.graph.nodes)
      ).forEach((node) => {
        indexInstance.upsert(node.id, node.value)
      })
    } catch {}
  }
  async function updateIndex(key, value, operation = 'insert') {
    switch (operation) {
      case 'insert':
        indexInstance.upsert(key, value)
        break
      case 'remove':
        indexInstance.remove(key, value)
        break
    }
    debouncedSave()
  }
  function searchByPrefix(prefix) {
    return indexInstance.searchAllByPrefix(prefix)
  }
  return {
    ready: loadIndex().then(populateIndex),
    updateIndex: updateIndex,
    searchByPrefix: searchByPrefix
  }
}
function R(H) {
  const indexerInstance = z(H)
  const originalPut = H.put
  H.put = async function (node, nodeId) {
    const existingNode = nodeId ? this.graph.get(nodeId) : null
    const newNodeId = await originalPut.call(this, node, nodeId)
    if (existingNode) {
      await indexerInstance.updateIndex(newNodeId, existingNode.value, 'remove')
    }
    await indexerInstance.updateIndex(newNodeId, node, 'insert')
    return newNodeId
  }
  const originalRemove = H.remove
  H.remove = async function (nodeId) {
    const nodeData = this.graph.get(nodeId)
    await originalRemove.call(this, nodeId)
    if (nodeData) {
      await indexerInstance.updateIndex(nodeId, nodeData.value, 'remove')
    }
  }
  const originalMap = H.map
  H.map = async function (...args) {
    const result = await originalMap.call(this, ...args)
    const queryObject = args.find((arg) => typeof arg === 'object')
    if (queryObject?.query?.id?.$startsWith) {
      const searchPrefix = queryObject.query.id.$startsWith
      const matchingIds = indexerInstance.searchByPrefix(searchPrefix)
      return result.filter((item) => matchingIds.includes(item.id))
    }
    return result
  }
  H.searchByPrefix = async function (prefix) {
    return indexerInstance
      .searchByPrefix(prefix)
      .map((nodeId) => this.graph.get(nodeId))
  }
  return H
}
var w = (config) => {
  console.log('ðŸŒ³ RadixIndexer module loaded.')
  return R(config)
}
export { R as withModule, w as init, z as RadixIndexer }
