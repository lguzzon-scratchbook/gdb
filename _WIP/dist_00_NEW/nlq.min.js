function wrapWithNLQProcessor(context) {
  const originalMap = context.map
  context.map = async function (...args) {
    let queryOptions = {}
    let callback = null
    args.forEach((arg) => {
      if (typeof arg === 'object') {
        queryOptions = {
          ...queryOptions,
          ...arg
        }
      }
      if (typeof arg === 'function') {
        callback = arg
      }
    })
    let shouldReturnDeepest = false
    if (queryOptions.prompt) {
      try {
        const parsedQuery = await parseNaturalLanguageQuery(queryOptions.prompt)
        console.log('Query generated from local DSL:', parsedQuery)
        queryOptions = {
          ...queryOptions,
          ...parsedQuery
        }
        if (parsedQuery.__nlqReturnDeepest) {
          shouldReturnDeepest = true
        }
        delete queryOptions.prompt
      } catch (error) {
        console.error('Error parsing prompt:', error.message)
        queryOptions.query = {}
      }
    }
    const enhancedCallback =
      shouldReturnDeepest && callback
        ? (result) => {
            try {
              const processedResult = processDeepestResults(result)
              if (callback) {
                callback(processedResult)
              }
            } catch {
              if (callback) {
                callback(result)
              }
            }
          }
        : callback
    const queryResult = await originalMap.call(
      this,
      queryOptions,
      enhancedCallback
    )
    if (
      shouldReturnDeepest &&
      queryResult &&
      Array.isArray(queryResult.results)
    ) {
      queryResult.results = processDeepestResults(queryResult.results)
    }
    return queryResult
  }
  return context
}
async function parseNaturalLanguageQuery(query) {
  return parseNaturalLanguage(query)
}
function parseNaturalLanguage(naturalQuery) {
  const normalizedInput = normalizeString(String(naturalQuery || ''))
  let remainingText = removeSearchTerms(normalizedInput)
  const result = {
    query: {}
  }
  const queryConditions = result.query
  const orConditions = parseOrConditions(remainingText)
  if (orConditions.length) {
    result.$_ors = []
    for (const condition of orConditions) {
      result.$_ors.push(condition.left, condition.right)
      remainingText = removeTextSpan(remainingText, condition.span)
    }
  }
  const exclusiveType = parseExclusiveType(remainingText)
  if (exclusiveType) {
    queryConditions.type = exclusiveType.type
    result.type = exclusiveType.type
    remainingText = removeTextSpan(remainingText, exclusiveType.span)
  }
  if (!queryConditions.type) {
    const articleType = parseArticleType(remainingText)
    if (articleType) {
      queryConditions.type = articleType.type
      result.type = articleType.type
      remainingText = removeTextSpan(remainingText, articleType.span)
    }
  }
  if (!queryConditions.type) {
    const leadingType = parseLeadingType(remainingText)
    if (leadingType) {
      queryConditions.type = leadingType.type
      result.type = leadingType.type
      remainingText = removeTextSpan(remainingText, leadingType.span)
    }
  }
  const edgeCondition = parseEdgeConditions(remainingText)
  if (edgeCondition?.edge) {
    queryConditions.$edge = edgeCondition.edge
    if (edgeCondition.span) {
      remainingText = removeTextSpan(remainingText, edgeCondition.span)
    }
  }
  if (
    edgeCondition?.edge &&
    /\bthen\s+finds?\s+(?:that\s+[A-Za-z]+s?\s+)?descendant\s+(?:named|called|with\s+name)\b/i.test(
      normalizedInput
    )
  ) {
    result.__nlqReturnDeepest = true
  }
  const includePatterns = parseIncludePatterns(remainingText)
  for (const pattern of includePatterns) {
    if (pattern.mode === 'in') {
      const values = pattern.values ?? [pattern.value]
      queryConditions[pattern.field] = {
        ...(queryConditions[pattern.field] || {}),
        $in: values
      }
    } else {
      queryConditions[pattern.field] = {
        ...(queryConditions[pattern.field] || {}),
        $contains: pattern.value
      }
    }
    remainingText = removeTextSpan(remainingText, pattern.span)
  }
  const startsWithPatterns = parseStartsWithPatterns(remainingText)
  for (const pattern of startsWithPatterns) {
    queryConditions[pattern.field] = {
      ...(queryConditions[pattern.field] || {}),
      $regex: `^${pattern.value}`
    }
    remainingText = removeTextSpan(remainingText, pattern.span)
  }
  const endsWithPatterns = parseEndsWithPatterns(remainingText)
  for (const pattern of endsWithPatterns) {
    queryConditions[pattern.field] = {
      ...(queryConditions[pattern.field] || {}),
      $regex: `${pattern.value}$`
    }
    remainingText = removeTextSpan(remainingText, pattern.span)
  }
  const likePatterns = parseLikePatterns(remainingText)
  for (const pattern of likePatterns) {
    queryConditions[pattern.field] = {
      ...(queryConditions[pattern.field] || {}),
      $like: pattern.value
    }
    remainingText = removeTextSpan(remainingText, pattern.span)
  }
  const textSearch = parseTextSearch(remainingText)
  if (textSearch) {
    const searchTerm = textSearch.value
    const searchConditions = [
      {
        name: {
          $regex: searchTerm
        }
      },
      {
        role: {
          $regex: searchTerm
        }
      },
      {
        level: {
          $regex: searchTerm
        }
      },
      {
        country: {
          $regex: searchTerm
        }
      },
      {
        title: {
          $regex: searchTerm
        }
      },
      {
        body: {
          $regex: searchTerm
        }
      },
      {
        tags: {
          $in: [searchTerm]
        }
      }
    ]
    result.query.$or = [...(result.query.$or || []), ...searchConditions]
    remainingText = removeTextSpan(remainingText, textSearch.span)
  } else if (hasSearchKeyword(remainingText)) {
    result.query.__nlq_no_match = '__NLQ_NO_MATCH__'
  }
  const existsPatterns = parseExistsPatterns(remainingText)
  for (const pattern of existsPatterns) {
    queryConditions[pattern.field] = {
      ...(queryConditions[pattern.field] || {}),
      $exists: true
    }
    remainingText = removeTextSpan(remainingText, pattern.span)
  }
  const pagination = parsePagination(remainingText)
  if (pagination.after) {
    result.$after = pagination.after
  }
  if (pagination.before) {
    result.$before = pagination.before
  }
  for (const span of pagination.spans) {
    remainingText = removeTextSpan(remainingText, span)
  }
  const withPatterns = parseWithPatterns(remainingText)
  for (const pattern of withPatterns) {
    queryConditions[pattern.field] = pattern.value
    remainingText = removeTextSpan(remainingText, pattern.span)
  }
  const namePatterns = parseNamePatterns(remainingText)
  for (const pattern of namePatterns) {
    queryConditions.name = pattern.value
    remainingText = removeTextSpan(remainingText, pattern.span)
  }
  const countryPatterns = parseCountryPatterns(remainingText)
  for (const pattern of countryPatterns) {
    queryConditions.country = pattern.value
    remainingText = removeTextSpan(remainingText, pattern.span)
  }
  const betweenPatterns = parseBetweenPatterns(remainingText)
  for (const pattern of betweenPatterns) {
    queryConditions[pattern.field] = {
      ...(queryConditions[pattern.field] || {}),
      $between: [pattern.min, pattern.max]
    }
    remainingText = removeTextSpan(remainingText, pattern.span)
  }
  const dateComparisons = parseDateComparisons(remainingText)
  for (const comparison of dateComparisons) {
    if (comparison.op === 'eq') {
      queryConditions[comparison.field] = comparison.value
    } else {
      queryConditions[comparison.field] = {
        ...(queryConditions[comparison.field] || {}),
        [comparison.op]: comparison.value
      }
    }
    remainingText = removeTextSpan(remainingText, comparison.span)
  }
  const numericComparisons = parseNumericComparisons(remainingText)
  for (const comparison of numericComparisons) {
    if (comparison.op === 'eq') {
      queryConditions[comparison.field] = comparison.value
    } else {
      queryConditions[comparison.field] = {
        ...(queryConditions[comparison.field] || {}),
        [comparison.op]: comparison.value
      }
    }
    remainingText = removeTextSpan(remainingText, comparison.span)
  }
  const notEqualPatterns = parseNotEqualPatterns(remainingText)
  for (const pattern of notEqualPatterns) {
    queryConditions[pattern.field] = {
      ...(queryConditions[pattern.field] || {}),
      $not: {
        $eq: pattern.value
      }
    }
    remainingText = removeTextSpan(remainingText, pattern.span)
  }
  const idPatterns = parseIdPatterns(remainingText)
  for (const pattern of idPatterns) {
    if (pattern.kind === 'in') {
      queryConditions.id = {
        ...(queryConditions.id || {}),
        $in: pattern.values
      }
    } else if (pattern.kind === 'eq') {
      queryConditions.id = pattern.value
    }
    remainingText = removeTextSpan(remainingText, pattern.span)
  }
  const inPatterns = parseInPatterns(remainingText)
  for (const pattern of inPatterns) {
    queryConditions[pattern.field] = {
      ...(queryConditions[pattern.field] || {}),
      $in: pattern.values
    }
    remainingText = removeTextSpan(remainingText, pattern.span)
  }
  const orderPattern = parseOrderPattern(remainingText)
  if (orderPattern) {
    result.order = orderPattern.order
    result.field = orderPattern.field
  }
  const limit = parseLimit(remainingText)
  if (limit != null) {
    result.$limit = limit
  }
  if (result.order && !result.field) {
    const firstField = Object.keys(queryConditions)[0]
    if (firstField) {
      result.field = firstField
    }
  }
  if (Object.keys(result.query).length === 0) {
    const hasOrder = !!result.order
    const hasLimit = result.$limit != null
    const hasPagination = !!result.$after || !!result.$before
    if (!hasOrder && !hasLimit && !hasPagination) {
      result.query.__nlq_no_match = '__NLQ_NO_MATCH__'
    }
  }
  if (result.$_ors?.length) {
    result.query.$or = [...(result.query.$or || []), ...result.$_ors]
    delete result.$_ors
  }
  result.query = processQueryObject(result.query)
  return result
}
function normalizeString(text) {
  return text.replace(/\s+/g, ' ').trim()
}
function removeTextSpan(text, span) {
  if (!span) {
    return text
  }
  return normalizeString(`${text.slice(0, span.start)} ${text.slice(span.end)}`)
}
function removeSearchTerms(text) {
  const searchKeywords =
    /^(?:searches\s+for|search\s+for|searches|search|finds?|gets?|lists?|returns?|shows?|filters?)\s+/i
  return text.replace(searchKeywords, '')
}
function parseIncludePatterns(text) {
  const patterns = []
  const regexConfigs = [
    {
      regex:
        /\bwhose\s+([a-z][\w.]*)\s+(includes|including|has)\s+((?:"[^"]+"|[A-Za-z0-9_-]+)(?:\s*,\s*(?:"[^"]+"|[A-Za-z0-9_-]+))*)/gi,
      mode: 'in',
      list: true
    },
    {
      regex:
        /\b([a-z][\w.]*)\s+(includes|including|has)\s+((?:"[^"]+"|[A-Za-z0-9_-]+)(?:\s*,\s*(?:"[^"]+"|[A-Za-z0-9_-]+))*)/gi,
      mode: 'in',
      list: true
    },
    {
      regex:
        /\bwhose\s+([a-z][\w.]*)\s+(?:contains|containing)\s+(?:the\s+(?:word|phrase|number|value|text|string|token|term|email|url|date|time|datetime)s?\s*:?\s*)?"([^"]+)"/gi,
      mode: 'contains'
    },
    {
      regex:
        /\bwhose\s+([a-z][\w.]*)\s+(?:contains|containing)\s+(?:the\s+(?:word|phrase|number|value|text|string|token|term|email|url|date|time|datetime)s?\s*:?\s*)?([A-Za-z0-9_-]+)/gi,
      mode: 'contains'
    },
    {
      regex:
        /\b([a-z][\w.]*)\s+(?:contains|containing)\s+(?:the\s+(?:word|phrase|number|value|text|string|token|term|email|url|date|time|datetime)s?\s*:?\s*)?"([^"]+)"/gi,
      mode: 'contains'
    },
    {
      regex:
        /\b([a-z][\w.]*)\s+(?:contains|containing)\s+(?:the\s+(?:word|phrase|number|value|text|string|token|term|email|url|date|time|datetime)s?\s*:?\s*)?([A-Za-z0-9_-]+)/gi,
      mode: 'contains'
    }
  ]
  for (const {
    regex: currentRegex,
    mode: currentMode,
    list: isList
  } of regexConfigs) {
    let match
    while ((match = currentRegex.exec(text)) !== null) {
      const fieldName = match[1]
      if (currentMode === 'in' && isList) {
        const values = match[3]
          .split(/\s*,\s*/)
          .map((value) => value.replace(/^"|"$/g, ''))
        patterns.push({
          field: fieldName,
          mode: 'in',
          values: values,
          span: {
            start: match.index,
            end: match.index + match[0].length
          }
        })
      } else if (currentMode === 'contains') {
        const searchValue = match[2]
        patterns.push({
          field: fieldName,
          mode: 'contains',
          value: searchValue,
          span: {
            start: match.index,
            end: match.index + match[0].length
          }
        })
      }
    }
  }
  return patterns
}
function parseStartsWithPatterns(text) {
  const patterns = []
  const quotedRegex =
    /\b(?:whose\s+)?([a-z][\w.]*)\s+starts\s+with\s+"([^"]+)"/gi
  let match
  while ((match = quotedRegex.exec(text)) !== null) {
    patterns.push({
      field: match[1],
      value: match[2],
      span: {
        start: match.index,
        end: match.index + match[0].length
      }
    })
  }
  const unquotedRegex =
    /\b(?:whose\s+)?([a-z][\w.]*)\s+starts\s+with\s+([A-Za-z0-9_-]+)/gi
  while ((match = unquotedRegex.exec(text)) !== null) {
    patterns.push({
      field: match[1],
      value: match[2],
      span: {
        start: match.index,
        end: match.index + match[0].length
      }
    })
  }
  return patterns
}
function parseEndsWithPatterns(text) {
  const patterns = []
  const quotedRegex = /\b(?:whose\s+)?([a-z][\w.]*)\s+ends\s+with\s+"([^"]+)"/gi
  let match
  while ((match = quotedRegex.exec(text)) !== null) {
    patterns.push({
      field: match[1],
      value: match[2],
      span: {
        start: match.index,
        end: match.index + match[0].length
      }
    })
  }
  const unquotedRegex =
    /\b(?:whose\s+)?([a-z][\w.]*)\s+ends\s+with\s+([A-Za-z0-9_-]+)/gi
  while ((match = unquotedRegex.exec(text)) !== null) {
    patterns.push({
      field: match[1],
      value: match[2],
      span: {
        start: match.index,
        end: match.index + match[0].length
      }
    })
  }
  return patterns
}
function d(j) {
  const H = []
  let _
  const Z = /\b(?:whose\s+)?([a-z][\w.]*)\s+like\s+"([^"]+)"/gi
  while ((_ = Z.exec(j)) !== null) {
    H.push({
      field: _[1],
      value: _[2],
      span: {
        start: _.index,
        end: _.index + _[0].length
      }
    })
  }
  const J = /\b(?:whose\s+)?([a-z][\w.]*)\s+like\s+([A-Za-z0-9_%\-.*]+)/gi
  while ((_ = J.exec(j)) !== null) {
    H.push({
      field: _[1],
      value: _[2],
      span: {
        start: _.index,
        end: _.index + _[0].length
      }
    })
  }
  return H
}
function parseTextSearch(text) {
  const match =
    /\b(?:full[-\s]?text\s+search|text\s+search)\s+(?:"([^"]+)"|([A-Za-z0-9_-]+))/i.exec(
      text
    )
  if (match) {
    return {
      value: match[1] || match[2],
      span: {
        start: match.index,
        end: match.index + match[0].length
      }
    }
  }
  return null
}
function hasSearchKeyword(text) {
  return /\b(?:full[-\s]?text\s+search|text\s+search|full[-\s]?text)\b/i.test(
    text
  )
}
function n(j) {
  const H = []
  let _
  const Z = /\b([a-z][\w.]*)\s*(?:!=|is\s+not|not\s+equals)\s+"([^"]+)"\b/gi
  while ((_ = Z.exec(j)) !== null) {
    H.push({
      field: _[1],
      value: _[2],
      span: {
        start: _.index,
        end: _.index + _[0].length
      }
    })
  }
  const J =
    /\b([a-z][\w.]*)\s*(?:!=|is\s+not|not\s+equals)\s+([A-Za-z0-9_\-.]+)\b/gi
  while ((_ = J.exec(j)) !== null) {
    H.push({
      field: _[1],
      value: K(_[2]),
      span: {
        start: _.index,
        end: _.index + _[0].length
      }
    })
  }
  return H
}
function s(j) {
  const H = []
  let _
  const Z =
    /\b([a-z][\w.]*)\s+is\s+([A-Za-z0-9_-]+)\s+or\s+([A-Za-z0-9_-]+)(?:\s+or\s+([A-Za-z0-9_-]+))*/gi
  while ((_ = Z.exec(j)) !== null) {
    const M = _[1]
    const F = _[0]
      .replace(new RegExp(`^${_[1]}\\s+is\\s+`, 'i'), '')
      .split(/\s+or\s+/i)
      .map((G) => G.trim().replace(/[,.]$/, ''))
    H.push({
      field: M,
      values: F,
      span: {
        start: _.index,
        end: _.index + _[0].length
      }
    })
  }
  const J =
    /\b([a-z][\w.]*)\s+in\s+((?:"[^"]+"|[A-Za-z0-9_-]+)(?:\s*,\s*(?:"[^"]+"|[A-Za-z0-9_-]+))*)/gi
  while ((_ = J.exec(j)) !== null) {
    const M = _[1]
    const G = _[2].split(/\s*,\s*/).map((Q) => Q.replace(/^"|"$/g, ''))
    H.push({
      field: M,
      values: G,
      span: {
        start: _.index,
        end: _.index + _[0].length
      }
    })
  }
  return H
}
function l(j) {
  const H = []
  let _
  const Z =
    /\b(?:has|with|having)\s+([a-z][\w.]*)\b(?!\s+(?:"[^"]+"|[A-Za-z0-9_\-.]+)\b)/gi
  while ((_ = Z.exec(j)) !== null) {
    H.push({
      field: _[1],
      span: {
        start: _.index,
        end: _.index + _[0].length
      }
    })
  }
  const J = /\b(?:has|with|having)\s+([a-z][\w.]*)\s+exists\b/gi
  while ((_ = J.exec(j)) !== null) {
    H.push({
      field: _[1],
      span: {
        start: _.index,
        end: _.index + _[0].length
      }
    })
  }
  const M = /\bwhose\s+([a-z][\w.]*)\s+exists\b/gi
  while ((_ = M.exec(j)) !== null) {
    H.push({
      field: _[1],
      span: {
        start: _.index,
        end: _.index + _[0].length
      }
    })
  }
  const F = /\b([a-z][\w.]*)\s+exists\b/gi
  while ((_ = F.exec(j)) !== null) {
    H.push({
      field: _[1],
      span: {
        start: _.index,
        end: _.index + _[0].length
      }
    })
  }
  return H
}
function m(j) {
  const H = []
  let _
  const Z = /\bwith\s+([a-z][\w.]*)\s+("[^"]+"|[A-Za-z0-9_\-.]+)\b/gi
  while ((_ = Z.exec(j)) !== null) {
    const J = _[1]
    const M = T(_[2])
    H.push({
      field: J,
      value: M,
      span: {
        start: _.index,
        end: _.index + _[0].length
      }
    })
  }
  return H
}
function _J1(j) {
  const H = []
  const _ = /\bname\s+(?:"([^"]+)"|(([A-Z][a-zA-Z]+)(?:\s+[A-Z][a-zA-Z]+)*))\b/g
  let Z
  while ((Z = _.exec(j)) !== null) {
    const J = Z[1] || (Z[2] ? Z[2].trim() : null)
    if (!J) {
      continue
    }
    H.push({
      value: J,
      span: {
        start: Z.index,
        end: Z.index + Z[0].length
      }
    })
  }
  return H
}
function _X1(j) {
  const H = []
  const _ = /\bfrom\s+(?:"([^"]+)"|([A-Za-z][A-Za-z]+))\b/gi
  let Z
  while ((Z = _.exec(j)) !== null) {
    const J = Z[1] || Z[2]
    H.push({
      value: J,
      span: {
        start: Z.index,
        end: Z.index + Z[0].length
      }
    })
  }
  return H
}
function a(j) {
  const H = []
  const _ =
    /\b([a-z][\w.]*)\s+between\s+(?:"([^"]+)"|([0-9]{4}-[0-9]{2}-[0-9]{2}[T\d:._+\-Z]*))\s*(?:and|,|to)\s*(?:"([^"]+)"|([0-9]{4}-[0-9]{2}-[0-9]{2}[T\d:._+\-Z]*))\b/gi
  let Z
  const J = []
  while ((Z = _.exec(j)) !== null) {
    const F = {
      start: Z.index,
      end: Z.index + Z[0].length
    }
    H.push({
      field: Z[1],
      min: Z[2] || Z[3],
      max: Z[4] || Z[5],
      span: F
    })
    J.push(F)
  }
  const M =
    /\b([a-z][\w.]*)\s+between\s+(-?\d+(?:\.\d+)?)\s*(?:and|,|to)\s*(-?\d+(?:\.\d+)?)\b/gi
  while ((Z = M.exec(j)) !== null) {
    const F = {
      start: Z.index,
      end: Z.index + Z[0].length
    }
    if (J.some((Q) => !(F.end <= Q.start) && !(F.start >= Q.end))) {
      continue
    }
    H.push({
      field: Z[1],
      min: K(Z[2]),
      max: K(Z[3]),
      span: F
    })
  }
  return H
}
function o(j) {
  const H = []
  const _ = /\bids?\b\s+((?:-?\d+(?:\.\d+)?\s*,\s*)+-?\d+(?:\.\d+)?)\b/gi
  let Z
  while ((Z = _.exec(j)) !== null) {
    const F = Z[1].split(/\s*,\s*/).map(K)
    H.push({
      kind: 'in',
      values: F,
      span: {
        start: Z.index,
        end: Z.index + Z[0].length
      }
    })
  }
  const J = /\bids?\b\s+(-?\d+(?:\.\d+)?)\b/gi
  while ((Z = J.exec(j)) !== null) {
    const M = {
      start: Z.index,
      end: Z.index + Z[0].length
    }
    if (!H.some((G) => !(M.end <= G.span.start) && !(M.start >= G.span.end))) {
      H.push({
        kind: 'eq',
        value: K(Z[1]),
        span: M
      })
    }
  }
  return H
}
function r(j) {
  const H = []
  let _
  const Z = /\b([a-z][\w.]*)\s*(?:>=|at\s+least)\s*(-?\d+(?:\.\d+)?)\b/gi
  while ((_ = Z.exec(j)) !== null) {
    H.push({
      field: _[1],
      op: '$gte',
      value: K(_[2]),
      span: {
        start: _.index,
        end: _.index + _[0].length
      }
    })
  }
  const J = /\b([a-z][\w.]*)\s*(?:<=|at\s+most)\s*(-?\d+(?:\.\d+)?)\b/gi
  while ((_ = J.exec(j)) !== null) {
    H.push({
      field: _[1],
      op: '$lte',
      value: K(_[2]),
      span: {
        start: _.index,
        end: _.index + _[0].length
      }
    })
  }
  const M =
    /\b([a-z][\w.]*)\s*(?:>|greater\s+than|more\s+than)\s*(-?\d+(?:\.\d+)?)\b/gi
  while ((_ = M.exec(j)) !== null) {
    H.push({
      field: _[1],
      op: '$gt',
      value: K(_[2]),
      span: {
        start: _.index,
        end: _.index + _[0].length
      }
    })
  }
  const F =
    /\b([a-z][\w.]*)\s*(?:<|less\s+than|fewer\s+than)\s*(-?\d+(?:\.\d+)?)\b/gi
  while ((_ = F.exec(j)) !== null) {
    H.push({
      field: _[1],
      op: '$lt',
      value: K(_[2]),
      span: {
        start: _.index,
        end: _.index + _[0].length
      }
    })
  }
  const G = /\b([a-z][\w.]*)\s*(?:=|equals|is)(?!\s+not)\s*"([^"]+)"\b/gi
  while ((_ = G.exec(j)) !== null) {
    H.push({
      field: _[1],
      op: 'eq',
      value: _[2],
      span: {
        start: _.index,
        end: _.index + _[0].length
      }
    })
  }
  const Q = /\b([a-z][\w.]*)\s*(?:=|equals|is)(?!\s+not)\s*([a-z0-9_\-.]+)\b/gi
  while ((_ = Q.exec(j)) !== null) {
    H.push({
      field: _[1],
      op: 'eq',
      value: K(_[2]),
      span: {
        start: _.index,
        end: _.index + _[0].length
      }
    })
  }
  return H
}
function _Y1(j) {
  const H = []
  let _
  const Z =
    /\b([a-z][\w.]*)\s+(on\s+or\s+after|on\s+or\s+before|after|before|on)\s+(?:"([^"]+)"|([0-9]{4}-[0-9]{2}-[0-9]{2}[T\d:._+\-Z]*))\b/gi
  while ((_ = Z.exec(j)) !== null) {
    const J = _[1]
    const M = _[2].toLowerCase().replace(/\s+/g, ' ')
    const F = _[3] || _[4]
    let G = '$gt'
    if (M === 'before') {
      G = '$lt'
    } else if (M === 'on') {
      G = 'eq'
    } else if (M === 'on or after') {
      G = '$gte'
    } else if (M === 'on or before') {
      G = '$lte'
    }
    H.push({
      field: J,
      op: G,
      value: F,
      span: {
        start: _.index,
        end: _.index + _[0].length
      }
    })
  }
  return H
}
function _$1(j) {
  const H = [
    {
      re: /\b(?:order|sort|sorted)\s+by\s+([a-z][\w.]*)\s*(asc|ascending|desc|descending)?\b/i,
      groups: {
        field: 1,
        dir: 2
      }
    },
    {
      re: /\b(?:order|sort|sorted)\s+(asc|ascending|desc|descending)\s+by\s+([a-z][\w.]*)\b/i,
      groups: {
        dir: 1,
        field: 2
      }
    }
  ]
  for (const _ of H) {
    const Z = j.match(_.re)
    if (Z) {
      const J = (Z[_.groups.dir] || 'asc').toLowerCase()
      const M = /desc|descending/.test(J) ? 'desc' : 'asc'
      return {
        field: Z[_.groups.field],
        order: M
      }
    }
  }
  return null
}
function _M1(j) {
  const H = j.match(/\blimit\s+(\d+)\b/i)
  if (H) {
    return Number(H[1])
  } else {
    return null
  }
}
function K(j) {
  const H = Number(j)
  if (Number.isFinite(H)) {
    return H
  } else {
    return j
  }
}
function _w(j) {
  if (!Array.isArray(j)) {
    return j
  }
  const H = []
  const _ = (Z) => {
    const J = Array.isArray(Z?._edgeResult) ? Z._edgeResult : null
    if (J?.length) {
      for (const M of J) {
        _(M)
      }
    } else {
      H.push(Z)
    }
  }
  for (const Z of j) {
    _(Z)
  }
  return H
}
function _U1(j) {
  const H = []
  let _
  const Z =
    /\b([a-z][\w.]*)\s*(=|is|equals)\s*("[^"]+"|[A-Za-z0-9_\-.]+)\s+or\s+\1\s*(=|is|equals)\s*("[^"]+"|[A-Za-z0-9_\-.]+)\b/gi
  while ((_ = Z.exec(j)) !== null) {
    const F = {
      [_[1]]: T(_[3])
    }
    const G = {
      [_[1]]: T(_[5])
    }
    H.push({
      left: F,
      right: G,
      span: {
        start: _.index,
        end: _.index + _[0].length
      }
    })
  }
  const J =
    /\b([a-z][\w.]*)\s+(?:contains|containing)\s+("[^"]+"|[A-Za-z0-9_\-.]+)\s+or\s+\1\s+(?:contains|containing)\s+("[^"]+"|[A-Za-z0-9_\-.]+)\b/gi
  while ((_ = J.exec(j)) !== null) {
    const F = {
      [_[1]]: {
        $contains: T(_[2])
      }
    }
    const G = {
      [_[1]]: {
        $contains: T(_[3])
      }
    }
    H.push({
      left: F,
      right: G,
      span: {
        start: _.index,
        end: _.index + _[0].length
      }
    })
  }
  const M =
    /\b([a-z][\w.]*)\s+starts\s+with\s+("[^"]+"|[A-Za-z0-9_-]+)\s+or\s+\1\s+starts\s+with\s+("[^"]+"|[A-Za-z0-9_-]+)\b/gi
  while ((_ = M.exec(j)) !== null) {
    const F = String(T(_[2]))
    const G = String(T(_[3]))
    const Q = {
      [_[1]]: {
        $regex: `^${F}`
      }
    }
    const B = {
      [_[1]]: {
        $regex: `^${G}`
      }
    }
    H.push({
      left: Q,
      right: B,
      span: {
        start: _.index,
        end: _.index + _[0].length
      }
    })
  }
  return H
}
function T(j) {
  if (!j) {
    return j
  }
  const H = j.replace(/^"|"$/g, '')
  return K(H)
}
function _F1(j) {
  if (!j || typeof j !== 'object') {
    return j
  }
  const { $edge: H, ..._ } = j
  const Z = H ? e(H) : undefined
  const J = Object.keys(_)
  if (J.length > 1) {
    const M = {}
    if (Z) {
      M.$edge = Z
    }
    M.$and = J.map((F) => ({
      [F]: _[F]
    }))
    return M
  }
  return {
    ..._,
    ...(H
      ? {
          $edge: Z
        }
      : {})
  }
}
function e(j) {
  if (!j || typeof j !== 'object') {
    return j
  }
  const { $edge: H, ..._ } = j
  const Z = Object.keys(_)
  const J = H ? e(H) : undefined
  if (Z.length > 1) {
    const M = {}
    if (J) {
      M.$edge = J
    }
    M.$and = Z.map((F) => ({
      [F]: _[F]
    }))
    return M
  }
  return {
    ..._,
    ...(J
      ? {
          $edge: J
        }
      : {})
  }
}
function _Q1(j) {
  const _ = /\bonly\s+([A-Z][a-zA-Z]+)s?\b/gi.exec(j)
  if (!_) {
    return null
  }
  return {
    type: O(_[1]),
    span: {
      start: _.index,
      end: _.index + _[0].length
    }
  }
}
function _G1(j) {
  const _ = /\b(?:a|an)\s+([A-Z][a-zA-Z]+)s?\b/gi.exec(j)
  if (!_) {
    return null
  }
  return {
    type: O(_[1]),
    span: {
      start: _.index,
      end: _.index + _[0].length
    }
  }
}
function _W1(j) {
  if (/^(?:full[-\s]?text\s+search|text\s+search)\b/i.test(j)) {
    return null
  }
  const H = j.match(/^([A-Z][a-zA-Z]+)s?\b/)
  if (!H) {
    return null
  }
  return {
    type: O(H[1]),
    span: {
      start: 0,
      end: H[0].length
    }
  }
}
function _B1(j) {
  const H = j
    .split(/\bthen\b/gi)
    .map((G) => G.trim())
    .filter(Boolean)
  let _ = null
  let Z = null
  let J = null
  let M = null
  for (const G of H) {
    const Q = x(G)
    const B = Z?.type ? 'type' : Z?.role ? 'role' : null
    const f = B ? String(Z[B]).toLowerCase() : null
    let Y = Q.match(/\bdescendant[s]?\s+of\s+type\s+([A-Za-z][A-Za-z]+)s?\b/i)
    let z = null
    let C = 'role'
    let $ = null
    let U = null
    let N = false
    let R = Q.match(
      /\b(?:that|this|those|their|its)\s+([A-Za-z][A-Za-z]+)\s*'s\s+descendant[s]?\b/i
    )
    if (!R) {
      R = Q.match(
        /\b(?:that|this|those|their|its)\s+([A-Za-z][A-Za-z]+)s?\s+descendant[s]?\b/i
      )
    }
    if (R) {
      const X = O(R[1]).toLowerCase()
      if (f && X === f) {
        N = true
        $ = R.index
        U = R.index + R[0].length
      }
    }
    if (Y) {
      z = O(Y[1])
      $ = Y.index
      U = Y.index + Y[0].length
      C = 'type'
    } else {
      Y =
        !N &&
        Q.match(
          /\b(?:that|this|those|their|its|a|an)?\s*([A-Za-z][A-Za-z]+)s?(?:'s)?\s+descendant[s]?\b/i
        )
      if (Y) {
        z = O(Y[1])
        $ = Y.index
        U = Y.index + Y[0].length
      } else {
        Y =
          !N &&
          Q.match(
            /\bdescendant[s]?\s+(?:of\s+)?(?!named\b|called\b|with\b)([A-Za-z][A-Za-z]+)s?\b/i
          )
        if (Y) {
          z = O(Y[1])
          $ = Y.index
          U = Y.index + Y[0].length
        } else {
          Y = Q.match(/\bchild(?:ren)?\s+of\s+type\s+([A-Za-z][A-Za-z]+)s?\b/i)
          if (Y) {
            z = O(Y[1])
            $ = Y.index
            U = Y.index + Y[0].length
            C = 'type'
          } else {
            Y = Q.match(/\bchild(?:ren)?\s+(?:of\s+)?([A-Za-z][A-Za-z]+)s?\b/i)
            if (Y) {
              z = O(Y[1])
              $ = Y.index
              U = Y.index + Y[0].length
            } else {
              Y = Q.match(
                /\b(?:that|this|those|their|its)?\s*([A-Za-z][A-Za-z]+)s?(?:'s)?\s+child(?:ren)?\b/i
              )
              if (Y) {
                z = O(Y[1])
                $ = Y.index
                U = Y.index + Y[0].length
              } else {
                Y = Q.match(
                  /\bgrandchild(?:ren)?\s+of\s+type\s+([A-Za-z][A-Za-z]+)s?\b/i
                )
                if (Y) {
                  z = O(Y[1])
                  $ = Y.index
                  U = Y.index + Y[0].length
                  C = 'type'
                } else {
                  Y = Q.match(
                    /\bgrandchild(?:ren)?\s+(?:of\s+)?([A-Za-z][A-Za-z]+)s?\b/i
                  )
                  if (Y) {
                    z = O(Y[1])
                    $ = Y.index
                    U = Y.index + Y[0].length
                  } else {
                    Y = Q.match(
                      /\b(?:that|this|those|their|its)?\s*([A-Za-z][A-Za-z]+)s?(?:'s)?\s+grandchild(?:ren)?\b/i
                    )
                    if (Y) {
                      z = O(Y[1])
                      $ = Y.index
                      U = Y.index + Y[0].length
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    const g = /\b(descendant|child|children|grandchild|grandchildren)\b/i.test(
      Q
    )
    let W = null
    if (z) {
      W = {
        [C]: z
      }
    } else if (g) {
      W = {}
    } else {
      continue
    }
    const D = Q.match(
      /\b(?:named|called)\s+"([^"]+)"|\b(?:named|called)\s+([A-Za-z0-9_-]+)\b|\bwith\s+name\s+"([^"]+)"|\bwith\s+name\s+([A-Za-z0-9_-]+)\b/i
    )
    if (D) {
      const X = D[1] || D[2] || D[3] || D[4]
      W.name = X
      const P = D.index
      const b = D[0].length
      if ($ === null || P < $) {
        $ = P
      }
      const A = P + b
      if (U === null || A > U) {
        U = A
      }
    }
    for (const X of p(Q)) {
      if (X.mode === 'in') {
        const P = X.values ?? [X.value]
        W[X.field] = {
          ...(W[X.field] || {}),
          $in: P
        }
      } else {
        W[X.field] = {
          ...(W[X.field] || {}),
          $contains: X.value
        }
      }
      $ = $ == null ? X.span.start : Math.min($, X.span.start)
      U = U == null ? X.span.end : Math.max(U, X.span.end)
    }
    for (const X of u(Q)) {
      W[X.field] = {
        ...(W[X.field] || {}),
        $regex: `^${X.value}`
      }
      $ = $ == null ? X.span.start : Math.min($, X.span.start)
      U = U == null ? X.span.end : Math.max(U, X.span.end)
    }
    for (const X of c(Q)) {
      W[X.field] = {
        ...(W[X.field] || {}),
        $regex: `${X.value}$`
      }
      $ = $ == null ? X.span.start : Math.min($, X.span.start)
      U = U == null ? X.span.end : Math.max(U, X.span.end)
    }
    for (const X of a(Q)) {
      W[X.field] = {
        ...(W[X.field] || {}),
        $between: [X.min, X.max]
      }
      $ = $ == null ? X.span.start : Math.min($, X.span.start)
      U = U == null ? X.span.end : Math.max(U, X.span.end)
    }
    for (const X of r(Q)) {
      if (X.op === 'eq') {
        W[X.field] = X.value
      } else {
        W[X.field] = {
          ...(W[X.field] || {}),
          [X.op]: X.value
        }
      }
      $ = $ == null ? X.span.start : Math.min($, X.span.start)
      U = U == null ? X.span.end : Math.max(U, X.span.end)
    }
    for (const X of n(Q)) {
      W[X.field] = {
        ...(W[X.field] || {}),
        $not: {
          $eq: X.value
        }
      }
      $ = $ == null ? X.span.start : Math.min($, X.span.start)
      U = U == null ? X.span.end : Math.max(U, X.span.end)
    }
    for (const X of s(Q)) {
      W[X.field] = {
        ...(W[X.field] || {}),
        $in: X.values
      }
      $ = $ == null ? X.span.start : Math.min($, X.span.start)
      U = U == null ? X.span.end : Math.max(U, X.span.end)
    }
    const v = l(Q)
    for (const X of v) {
      W[X.field] = {
        ...(W[X.field] || {}),
        $exists: true
      }
      $ = $ == null ? X.span.start : Math.min($, X.span.start)
      U = U == null ? X.span.end : Math.max(U, X.span.end)
    }
    const q = Q.replace(/\b(?:has|with|having)\s+[a-z][\w.]*\s+exists\b/gi, ' ')
      .replace(/\bwhose\s+[a-z][\w.]*\s+exists\b/gi, ' ')
      .replace(/\b([a-z][\w.]*)\s+exists\b/gi, ' ')
      .replace(
        /\b(?:whose\s+)?([a-z][\w.]*)\s+starts\s+with\s+(?:"[^"]+"|[A-Za-z0-9_-]+)/gi,
        ' '
      )
    for (const X of d(Q)) {
      W[X.field] = {
        ...(W[X.field] || {}),
        $like: X.value
      }
      $ = $ == null ? X.span.start : Math.min($, X.span.start)
      U = U == null ? X.span.end : Math.max(U, X.span.end)
    }
    for (const X of m(q)) {
      W[X.field] = X.value
      $ = $ == null ? X.span.start : Math.min($, X.span.start)
      U = U == null ? X.span.end : Math.max(U, X.span.end)
    }
    for (const X of o(Q)) {
      if (X.kind === 'in') {
        W.id = {
          ...(W.id || {}),
          $in: X.values
        }
      } else if (X.kind === 'eq') {
        W.id = X.value
      }
      $ = $ == null ? X.span.start : Math.min($, X.span.start)
      U = U == null ? X.span.end : Math.max(U, X.span.end)
    }
    if (!W || Object.keys(W).length === 0) {
      continue
    }
    if (!_) {
      _ = W
      Z = W
      J = J ?? j.indexOf(Q) + ($ ?? 0)
      M = j.indexOf(Q) + (U ?? 0)
    } else {
      const X = Z.type ? 'type' : Z.role ? 'role' : null
      const P = X ? String(Z[X]).toLowerCase() : null
      const b = W.type ? 'type' : W.role ? 'role' : null
      const A = b ? String(W[b]).toLowerCase() : null
      if (!Z.$edge || typeof Z.$edge !== 'object') {
        Z.$edge = {}
      }
      const L = Z.$edge
      const h = L.type ? 'type' : L.role ? 'role' : null
      const _z1 = h ? String(L[h]).toLowerCase() : null
      const y = (E) => {
        const k = {}
        for (const [I, t] of Object.entries(W)) {
          if (I === '$edge') {
            continue
          }
          if (E && (I === 'type' || I === 'role')) {
            continue
          }
          k[I] = t
        }
        return k
      }
      if (A && P && A === P) {
        Object.assign(L, y(true))
      } else if (A) {
        for (const E of ['type', 'role']) {
          delete L[E]
        }
        Object.assign(L, y(false))
      } else {
        Object.assign(L, y(false))
      }
      Z = Z.$edge
      const S = j.indexOf(Q)
      if (J === null) {
        J = S + ($ ?? 0)
      }
      M = S + (U ?? 0)
    }
  }
  if (!_) {
    return null
  }
  const F =
    J != null && M != null
      ? {
          start: J,
          end: M
        }
      : undefined
  return {
    edge: _,
    span: F
  }
}
function O(j) {
  if (!j) {
    return j
  }
  if (/ies$/i.test(j)) {
    return j.replace(/ies$/i, 'y')
  }
  if (/ses$/i.test(j)) {
    return j.replace(/es$/i, 'e')
  }
  if (/s$/i.test(j)) {
    return j.replace(/s$/i, '')
  }
  return j
}
function _V1(j) {
  const H = {
    after: null,
    before: null,
    spans: []
  }
  const _ = [
    {
      kind: 'after',
      re: /\b(?:start(?:ing)?\s+)?after\s+(?:id\s+)?(?:"([^"]+)"|([A-Za-z0-9_-]+))(?=\s|$)/gi
    },
    {
      kind: 'before',
      re: /\b(?:before|until)\s+(?:id\s+)?(?:"([^"]+)"|([A-Za-z0-9_-]+))(?=\s|$)/gi
    }
  ]
  for (const Z of _) {
    let J
    while ((J = Z.re.exec(j)) !== null) {
      const M = J[1] || J[2]
      if (Z.kind === 'after' && !H.after) {
        H.after = M
      }
      if (Z.kind === 'before' && !H.before) {
        H.before = M
      }
      H.spans.push({
        start: J.index,
        end: J.index + J[0].length
      })
    }
  }
  return H
}
var initModule = (context) => {
  console.log('🧠 NLQ module loaded (local DSL).')
  return wrapWithNLQProcessor(context)
}
export { wrapWithNLQProcessor as withModule, initModule as init }
