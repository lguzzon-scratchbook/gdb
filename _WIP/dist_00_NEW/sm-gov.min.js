var gdbInstance
var governanceRules = []
var governanceTimer
var isEngineActive = false
var processGovernanceRules = async () => {
  for (const rule of governanceRules) {
    try {
      const { results: queryResults = [] } = await gdbInstance.map({})
      if (!queryResults.length) {
        continue
      }
      await Promise.all(
        queryResults.map(async ({ id: recordId, timestamp: timestampData }) => {
          const [, userId] = recordId.split(':')
          if (
            !rule.offsetTimestamp ||
            timestampData.physical <= Date.now() - rule.offsetTimestamp
          ) {
            await assignRoleToUser(rule.then, userId)
          }
        })
      )
    } catch (error) {
      console.error('❌ GOVERNANCE ERROR: Failed to process rule.', {
        rule: rule,
        error: error.message
      })
    }
  }
}
var assignRoleToUser = async (ruleConfig, userId) => {
  if (!ruleConfig.assignRole) {
    return
  }
  const { result: userRecord } = await gdbInstance.get(`user:${userId}`)
  const currentRole = userRecord?.value?.role
  if (
    !currentRole ||
    currentRole === 'superadmin' ||
    currentRole === ruleConfig.assignRole
  ) {
    return
  }
  await gdbInstance.sm.executeWithPermission('assignRole')
  await gdbInstance.sm.assignRole(userId, ruleConfig.assignRole)
}
var activateGovernanceEngine = () => {
  if (isEngineActive) {
    return
  }
  console.log('✅ GOVERNANCE ENGINE: Activated. Starting periodic checks.')
  governanceTimer = setInterval(processGovernanceRules, 4000)
  isEngineActive = true
}
var deactivateGovernanceEngine = () => {
  if (!isEngineActive) {
    return
  }
  clearInterval(governanceTimer)
  governanceTimer = null
  isEngineActive = false
  console.log('🛑 GOVERNANCE ENGINE: Deactivated. Pausing checks.')
}
var initializeGovernanceEngine = (
  gdbInstanceParam,
  { governanceRules: rules, superAdmins: adminList } = {}
) => {
  if (!gdbInstanceParam || !rules) {
    return console.error(
      '❌ GOVERNANCE: Initialization failed: gdb instance and rules are required.'
    )
  }
  gdbInstance = gdbInstanceParam
  governanceRules = rules
  gdbInstance.sm.setGovernanceStateChangeCallback(
    async ({ isActive, activeAddress }) => {
      if (isActive && activeAddress && adminList.includes(activeAddress)) {
        await gdbInstance.sm.executeWithPermission('assignRole')
        activateGovernanceEngine()
      } else {
        deactivateGovernanceEngine()
      }
    }
  )
}
export { initializeGovernanceEngine as start }
