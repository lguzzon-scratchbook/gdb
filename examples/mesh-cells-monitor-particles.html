<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mesh Monitor - 3D Particles</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap');

    :root {
      --bg: #0a0a0f;
      --bg-card: #12121a;
      --bg-hover: #1a1a24;
      --border: #1f1f2e;
      --text: #e5e5e5;
      --text-dim: #6b6b80;
      --accent: #6366f1;
      --accent-dim: #4f46e5;
      --success: #10b981;
      --warning: #f59e0b;
      --error: #ef4444;
      --purple: #a855f7;
      --cyan: #06b6d4;
      --radius: 12px;
      --radius-sm: 8px;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      height: 100%;
      background: var(--bg);
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      color: var(--text);
      font-size: 14px;
      line-height: 1.5;
      -webkit-font-smoothing: antialiased;
      overflow: hidden;
    }

    .container {
      display: flex;
      flex-direction: column;
      height: 100vh;
      padding: 12px;
      gap: 12px;
    }

    /* Header */
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 16px;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      flex-shrink: 0;
      backdrop-filter: blur(10px);
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 16px;
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .logo-icon {
      width: 32px;
      height: 32px;
      background: linear-gradient(135deg, var(--accent), var(--purple));
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      box-shadow: 0 0 20px rgba(99, 102, 241, 0.4);
    }

    .logo-text {
      font-weight: 600;
      font-size: 16px;
      letter-spacing: -0.02em;
      background: linear-gradient(135deg, var(--text) 0%, var(--accent) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .status-badge {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      background: rgba(16, 185, 129, 0.1);
      border: 1px solid rgba(16, 185, 129, 0.2);
      border-radius: 20px;
      font-size: 12px;
      font-weight: 500;
      color: var(--success);
    }

    .status-badge.offline {
      background: rgba(239, 68, 68, 0.1);
      border-color: rgba(239, 68, 68, 0.2);
      color: var(--error);
    }

    .status-badge.connecting {
      background: rgba(245, 158, 11, 0.1);
      border-color: rgba(245, 158, 11, 0.2);
      color: var(--warning);
    }

    .status-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: currentColor;
      box-shadow: 0 0 8px currentColor;
    }

    .status-badge.connecting .status-dot {
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.3; transform: scale(0.8); }
    }

    .header-stats {
      display: flex;
      gap: 24px;
    }

    .header-stat {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
    }

    .header-stat-label {
      font-size: 11px;
      color: var(--text-dim);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .header-stat-value {
      font-size: 14px;
      font-weight: 500;
      color: var(--text);
    }

    /* Main area */
    .main {
      display: flex;
      flex: 1;
      gap: 12px;
      min-height: 0;
      overflow: hidden;
    }

    /* Graph Panel */
    .graph-panel {
      flex: 1;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
    }

    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      border-bottom: 1px solid var(--border);
      background: rgba(18, 18, 26, 0.8);
      backdrop-filter: blur(10px);
      z-index: 10;
    }

    .panel-title {
      font-weight: 500;
      font-size: 13px;
      color: var(--text-dim);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    #graphContainer {
      flex: 1;
      position: relative;
      overflow: hidden;
    }

    #canvas3d {
      width: 100%;
      height: 100%;
      cursor: grab;
    }

    #canvas3d:active {
      cursor: grabbing;
    }

    .graph-legend {
      position: absolute;
      bottom: 12px;
      left: 12px;
      display: flex;
      gap: 16px;
      font-size: 11px;
      color: var(--text-dim);
      background: rgba(10, 10, 15, 0.9);
      padding: 8px 14px;
      border-radius: 8px;
      border: 1px solid var(--border);
      backdrop-filter: blur(10px);
      z-index: 10;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .legend-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      box-shadow: 0 0 8px currentColor;
    }

    .legend-dot.you { background: #a855f7; }
    .legend-dot.peer { background: #10b981; }
    .legend-dot.bridge { background: #f59e0b; }
    .legend-dot.cell { background: #6366f1; }

    .controls-hint {
      position: absolute;
      top: 60px;
      right: 12px;
      font-size: 11px;
      color: var(--text-dim);
      background: rgba(10, 10, 15, 0.9);
      padding: 8px 12px;
      border-radius: 8px;
      border: 1px solid var(--border);
      z-index: 10;
    }

    /* Sidebar */
    .sidebar {
      width: 280px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-height: 0;
      overflow-y: auto;
      flex-shrink: 0;
    }

    .sidebar::-webkit-scrollbar {
      width: 4px;
    }

    .sidebar::-webkit-scrollbar-track {
      background: transparent;
    }

    .sidebar::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 2px;
    }

    .card {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      overflow: hidden;
    }

    .card-header {
      padding: 8px 12px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .card-icon {
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      opacity: 0.7;
    }

    .card-title {
      font-weight: 500;
      font-size: 12px;
      color: var(--text-dim);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .card-body {
      padding: 10px 14px;
    }

    .metric-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px 20px;
    }

    .metric-item {
      display: flex;
      flex-direction: column;
      gap: 2px;
      min-width: 0;
    }

    .metric-item.full {
      grid-column: 1 / -1;
    }

    .metric-label {
      font-size: 10px;
      color: var(--text-dim);
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }

    .metric-value {
      font-size: 15px;
      font-weight: 600;
      color: var(--text);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .metric-value.accent {
      color: var(--accent);
    }

    .metric-value.success {
      color: var(--success);
    }

    .metric-value.warning {
      color: var(--warning);
    }

    .metric-value.small {
      font-size: 13px;
      font-weight: 500;
    }

    /* Chat Panel */
    .chat-panel {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      display: flex;
      flex-direction: column;
    }

    .chat-log {
      height: 60px;
      padding: 8px 12px;
      overflow-y: auto;
      font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
      font-size: 11px;
      border-bottom: 1px solid var(--border);
    }

    .chat-entry {
      padding: 2px 0;
      color: var(--text-dim);
    }

    .chat-entry .time {
      color: var(--text-dim);
      opacity: 0.6;
    }

    .chat-entry .from {
      color: var(--accent);
    }

    .chat-entry .you {
      color: var(--purple);
    }

    .chat-entry .success {
      color: var(--success);
    }

    .chat-entry .error {
      color: var(--error);
    }

    .chat-input-row {
      display: flex;
      padding: 8px 12px;
      gap: 8px;
    }

    .chat-input-row input {
      flex: 1;
      background: var(--bg);
      border: 1px solid var(--border);
      color: var(--text);
      font-family: inherit;
      font-size: 12px;
      padding: 8px 12px;
      border-radius: var(--radius-sm);
      outline: none;
      transition: border-color 0.2s, box-shadow 0.2s;
    }

    .chat-input-row input::placeholder {
      color: var(--text-dim);
    }

    .chat-input-row input:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
    }

    .chat-input-row button {
      background: linear-gradient(135deg, var(--accent), var(--purple));
      color: white;
      border: none;
      padding: 8px 16px;
      font-family: inherit;
      font-size: 12px;
      font-weight: 500;
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .chat-input-row button:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
    }

    .chat-input-row button:disabled {
      background: var(--border);
      color: var(--text-dim);
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    @media (max-width: 768px) {
      .sidebar { display: none; }
      .header-stats { display: none; }
    }
  </style>
</head>

<body>
  <div class="container">
    <!-- Header -->
    <div class="header">
      <div class="header-left">
        <div class="logo">
          <div class="logo-icon">â—ˆ</div>
          <span class="logo-text">Mesh Monitor 3D</span>
        </div>
        <div class="status-badge connecting" id="statusBadge">
          <span class="status-dot"></span>
          <span id="connectionStatus">Connecting</span>
        </div>
      </div>
      <div class="header-stats">
        <div class="header-stat">
          <span class="header-stat-label">Cell</span>
          <span class="header-stat-value" id="cellId">---</span>
        </div>
        <div class="header-stat">
          <span class="header-stat-label">Size</span>
          <span class="header-stat-value" id="cellSize">--</span>
        </div>
        <div class="header-stat">
          <span class="header-stat-label">Role</span>
          <span class="header-stat-value" id="roleStatus">Peer</span>
        </div>
        <div class="header-stat">
          <span class="header-stat-label">Your ID</span>
          <span class="header-stat-value" id="yourId">---</span>
        </div>
        <div class="header-stat">
          <span class="header-stat-label">Nodes</span>
          <span class="header-stat-value" id="peerCount">0</span>
        </div>
      </div>
    </div>

    <!-- Main -->
    <div class="main">
      <!-- Graph -->
      <div class="graph-panel">
        <div class="panel-header">
          <span class="panel-title">3D Network Topology</span>
        </div>
        <div id="graphContainer">
          <canvas id="canvas3d"></canvas>
          <div class="graph-legend">
            <span class="legend-item"><span class="legend-dot you"></span> You</span>
            <span class="legend-item"><span class="legend-dot peer"></span> Peer</span>
            <span class="legend-item"><span class="legend-dot bridge"></span> Bridge</span>
            <span class="legend-item"><span class="legend-dot cell"></span> Cell</span>
          </div>
          <div class="controls-hint">ğŸ–±ï¸ Drag to rotate</div>
        </div>
      </div>

      <!-- Sidebar -->
      <div class="sidebar">
        <div class="card">
          <div class="card-header">
            <span class="card-icon">ğŸ“Š</span>
            <span class="card-title">Metrics</span>
          </div>
          <div class="card-body">
            <div class="metric-grid">
              <div class="metric-item">
                <span class="metric-label">Peers</span>
                <span class="metric-value" id="metricPeers">0</span>
              </div>
              <div class="metric-item">
                <span class="metric-label">Cells</span>
                <span class="metric-value" id="metricCells">0</span>
              </div>
              <div class="metric-item">
                <span class="metric-label">Bridges</span>
                <span class="metric-value" id="metricBridges">0</span>
              </div>
              <div class="metric-item">
                <span class="metric-label">Cell Size</span>
                <span class="metric-value" id="metricCellSize">--</span>
              </div>
            </div>
          </div>
        </div>

        <div class="card">
          <div class="card-header">
            <span class="card-icon">ğŸ”—</span>
            <span class="card-title">Connection</span>
          </div>
          <div class="card-body">
            <div class="metric-grid">
              <div class="metric-item">
                <span class="metric-label">Status</span>
                <span class="metric-value success" id="connStatus">Offline</span>
              </div>
              <div class="metric-item">
                <span class="metric-label">Uptime</span>
                <span class="metric-value" id="connUptime">00:00:00</span>
              </div>
              <div class="metric-item">
                <span class="metric-label">â†‘ Out</span>
                <span class="metric-value small" id="connBytesOut">0 B</span>
              </div>
              <div class="metric-item">
                <span class="metric-label">â†“ In</span>
                <span class="metric-value small" id="connBytesIn">0 B</span>
              </div>
            </div>
          </div>
        </div>

        <div class="card">
          <div class="card-header">
            <span class="card-icon">ğŸŒ</span>
            <span class="card-title">Network</span>
          </div>
          <div class="card-body">
            <div class="metric-grid">
              <div class="metric-item full">
                <span class="metric-label">Relay</span>
                <span class="metric-value small" id="netRelay">---</span>
              </div>
              <div class="metric-item full">
                <span class="metric-label">Room</span>
                <span class="metric-value small" id="netRoom">---</span>
              </div>
            </div>
          </div>
        </div>

        <div class="card">
          <div class="card-header">
            <span class="card-icon">âš™ï¸</span>
            <span class="card-title">System</span>
          </div>
          <div class="card-body">
            <div class="metric-grid">
              <div class="metric-item">
                <span class="metric-label">Memory</span>
                <span class="metric-value small" id="sysMemory">--</span>
              </div>
              <div class="metric-item">
                <span class="metric-label">FPS</span>
                <span class="metric-value accent" id="sysFps">--</span>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Chat -->
    <div class="chat-panel">
      <div class="panel-header">
        <span class="panel-title">Message Log</span>
      </div>
      <div class="chat-log" id="log"></div>
      <div class="chat-input-row">
        <input type="text" id="msgInput" placeholder="Type a message..." disabled />
        <button id="sendBtn" disabled>Send</button>
      </div>
    </div>
  </div>

  <!-- Three.js from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  
  <script type="module">
    import { gdb } from "../dist/index.js";

    let selfId = null;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // COLORS (3D Particle palette)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const COLORS = {
      cell: 0x6366f1,
      bridge: 0xf59e0b,
      peer: 0x10b981,
      self: 0xa855f7,
      link: 0x1f1f2e,
      bridgeLink: 0xf59e0b,
      pulse: 0x6366f1,
      message: 0x06b6d4,
      background: 0x0a0a0f
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // THREE.JS SETUP
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    let scene, camera, renderer, raycaster, mouse;
    let nodeObjects = new Map();
    let cellObjects = new Map();
    let linkObjects = [];
    let particleObjects = [];
    let pulseObjects = [];
    let rotationY = 0;
    let rotationX = 0.3;
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };
    let autoRotate = true;

    const graphEl = document.getElementById("graphContainer");

    function initThreeJS() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(COLORS.background);
      scene.fog = new THREE.Fog(COLORS.background, 200, 600);

      const rect = graphEl.getBoundingClientRect();
      camera = new THREE.PerspectiveCamera(60, rect.width / rect.height, 0.1, 1000);
      camera.position.z = 250;

      renderer = new THREE.WebGLRenderer({
        canvas: document.getElementById("canvas3d"),
        antialias: true,
        alpha: true
      });
      renderer.setSize(rect.width, rect.height);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

      // Ambient light
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
      scene.add(ambientLight);

      // Point lights
      const light1 = new THREE.PointLight(0x6366f1, 1, 500);
      light1.position.set(100, 100, 100);
      scene.add(light1);

      const light2 = new THREE.PointLight(0xa855f7, 0.8, 500);
      light2.position.set(-100, -100, 100);
      scene.add(light2);

      // Add background particles
      createBackgroundParticles();

      // Mouse controls
      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();

      const canvas = document.getElementById("canvas3d");
      canvas.addEventListener("mousedown", onMouseDown);
      canvas.addEventListener("mousemove", onMouseMove);
      canvas.addEventListener("mouseup", onMouseUp);
      canvas.addEventListener("mouseleave", onMouseUp);
      canvas.addEventListener("wheel", onMouseWheel);

      window.addEventListener("resize", onWindowResize);

      animate();
    }

    function createBackgroundParticles() {
      const geometry = new THREE.BufferGeometry();
      const positions = [];
      const colors = [];
      const sizes = [];

      for (let i = 0; i < 500; i++) {
        positions.push(
          (Math.random() - 0.5) * 800,
          (Math.random() - 0.5) * 600,
          (Math.random() - 0.5) * 400
        );
        
        const color = new THREE.Color();
        color.setHSL(0.7 + Math.random() * 0.1, 0.5, 0.3 + Math.random() * 0.2);
        colors.push(color.r, color.g, color.b);
        sizes.push(Math.random() * 2 + 0.5);
      }

      geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

      const material = new THREE.PointsMaterial({
        size: 2,
        vertexColors: true,
        transparent: true,
        opacity: 0.6,
        blending: THREE.AdditiveBlending
      });

      const particles = new THREE.Points(geometry, material);
      particles.userData.isBackground = true;
      scene.add(particles);
    }

    function onWindowResize() {
      const rect = graphEl.getBoundingClientRect();
      camera.aspect = rect.width / rect.height;
      camera.updateProjectionMatrix();
      renderer.setSize(rect.width, rect.height);
    }

    function onMouseDown(event) {
      isDragging = true;
      autoRotate = false;
      previousMousePosition = { x: event.clientX, y: event.clientY };
    }

    function onMouseMove(event) {
      if (!isDragging) return;
      
      const deltaX = event.clientX - previousMousePosition.x;
      const deltaY = event.clientY - previousMousePosition.y;
      
      rotationY += deltaX * 0.005;
      rotationX += deltaY * 0.005;
      rotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotationX));
      
      previousMousePosition = { x: event.clientX, y: event.clientY };
    }

    function onMouseUp() {
      isDragging = false;
      setTimeout(() => { autoRotate = true; }, 3000);
    }

    function onMouseWheel(event) {
      event.preventDefault();
      camera.position.z += event.deltaY * 0.5;
      camera.position.z = Math.max(100, Math.min(500, camera.position.z));
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 3D VISUALIZATION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function clearScene() {
      // Remove nodes
      for (const obj of nodeObjects.values()) {
        scene.remove(obj);
        if (obj.geometry) obj.geometry.dispose();
        if (obj.material) obj.material.dispose();
      }
      nodeObjects.clear();

      // Remove cells
      for (const obj of cellObjects.values()) {
        scene.remove(obj);
        if (obj.geometry) obj.geometry.dispose();
        if (obj.material) obj.material.dispose();
      }
      cellObjects.clear();

      // Remove links
      for (const obj of linkObjects) {
        scene.remove(obj);
        if (obj.geometry) obj.geometry.dispose();
        if (obj.material) obj.material.dispose();
      }
      linkObjects = [];

      // Remove particles and pulses
      for (const obj of particleObjects) {
        scene.remove(obj.mesh);
        if (obj.mesh.geometry) obj.mesh.geometry.dispose();
        if (obj.mesh.material) obj.mesh.material.dispose();
      }
      particleObjects = [];

      for (const obj of pulseObjects) {
        scene.remove(obj.mesh);
        if (obj.mesh.geometry) obj.mesh.geometry.dispose();
        if (obj.mesh.material) obj.mesh.material.dispose();
      }
      pulseObjects = [];
    }

    function createNodeMesh(x, y, z, color, size, isSelf = false) {
      const geometry = new THREE.SphereGeometry(size, 32, 32);
      const material = new THREE.MeshPhongMaterial({
        color: color,
        emissive: color,
        emissiveIntensity: isSelf ? 0.5 : 0.3,
        transparent: true,
        opacity: 0.9
      });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(x, y, z);

      // Add glow effect
      const glowGeometry = new THREE.SphereGeometry(size * 1.5, 32, 32);
      const glowMaterial = new THREE.MeshBasicMaterial({
        color: color,
        transparent: true,
        opacity: 0.2,
        side: THREE.BackSide
      });
      const glow = new THREE.Mesh(glowGeometry, glowMaterial);
      mesh.add(glow);

      scene.add(mesh);
      return mesh;
    }

    function createCellMesh(x, y, z, label) {
      const geometry = new THREE.OctahedronGeometry(15, 0);
      const material = new THREE.MeshPhongMaterial({
        color: COLORS.cell,
        emissive: COLORS.cell,
        emissiveIntensity: 0.3,
        transparent: true,
        opacity: 0.8,
        wireframe: false
      });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(x, y, z);

      // Add wireframe overlay
      const wireframeGeo = new THREE.OctahedronGeometry(16, 0);
      const wireframeMat = new THREE.MeshBasicMaterial({
        color: COLORS.cell,
        wireframe: true,
        transparent: true,
        opacity: 0.5
      });
      const wireframe = new THREE.Mesh(wireframeGeo, wireframeMat);
      mesh.add(wireframe);

      scene.add(mesh);
      return mesh;
    }

    function createLink(from, to, isBridge = false) {
      const geometry = new THREE.BufferGeometry().setFromPoints([from, to]);
      const material = new THREE.LineBasicMaterial({
        color: isBridge ? COLORS.bridgeLink : COLORS.link,
        transparent: true,
        opacity: isBridge ? 0.6 : 0.3,
        linewidth: isBridge ? 2 : 1
      });
      const line = new THREE.Line(geometry, material);
      scene.add(line);
      linkObjects.push(line);
      return line;
    }

    function create3DLayout() {
      clearScene();

      const allPeers = getAllPeers();
      const cells = new Map();

      for (const [pid, st] of allPeers) {
        const cellId = st.cellId || "cell-0";
        if (!cells.has(cellId)) cells.set(cellId, []);
        cells.get(cellId).push({ id: pid, ...st });
      }

      const sortedCells = [...cells.keys()].sort((a, b) => getCellIndex(a) - getCellIndex(b));
      const cellCount = Math.max(sortedCells.length, 1);
      const cellSpacing = 100;
      const startX = -(cellCount - 1) * cellSpacing / 2;

      // Create cells and peers in 3D space
      sortedCells.forEach((cellId, cellIndex) => {
        const cellX = startX + cellIndex * cellSpacing;
        const cellY = 0;
        const cellZ = 0;

        // Create cell
        const cellMesh = createCellMesh(cellX, cellY, cellZ, `C${getCellIndex(cellId)}`);
        cellObjects.set(cellId, cellMesh);

        // Create peers around cell
        const peers = cells.get(cellId) || [];
        const peerCount = peers.length;
        const radius = 40;

        peers.forEach((peer, peerIndex) => {
          const theta = (peerIndex / peerCount) * Math.PI * 2;
          const phi = (peerIndex % 3) * (Math.PI / 4) - Math.PI / 4;
          
          const px = cellX + Math.cos(theta) * Math.cos(phi) * radius;
          const py = cellY + Math.sin(phi) * radius * 0.8;
          const pz = cellZ + Math.sin(theta) * Math.cos(phi) * radius;

          const isSelf = peer.id === selfId;
          const isBridge = isSelf ? selfState.isBridge : isCachedBridge(peer.id);
          const color = isSelf ? COLORS.self : isBridge ? COLORS.bridge : COLORS.peer;
          const size = isSelf ? 8 : isBridge ? 6 : 5;

          const nodeMesh = createNodeMesh(px, py, pz, color, size, isSelf);
          nodeObjects.set(peer.id, nodeMesh);

          // Link peer to cell
          createLink(
            new THREE.Vector3(px, py, pz),
            new THREE.Vector3(cellX, cellY, cellZ)
          );
        });

        // Link to next cell
        if (cellIndex < sortedCells.length - 1) {
          const nextCellX = startX + (cellIndex + 1) * cellSpacing;
          createLink(
            new THREE.Vector3(cellX + 18, cellY, cellZ),
            new THREE.Vector3(nextCellX - 18, cellY, cellZ),
            true
          );
        }
      });

      // Create bridge links between peers in different cells
      const bridgeMap = computeAllBridges();
      for (const [pid, state] of allPeers) {
        if (bridgeMap.get(pid) && state.bridges?.length > 0) {
          const fromMesh = nodeObjects.get(pid);
          if (!fromMesh) continue;

          for (const targetId of state.bridges) {
            const toMesh = nodeObjects.get(targetId);
            const targetState = allPeers.get(targetId);
            if (toMesh && targetState?.cellId !== state.cellId) {
              if (getCellIndex(state.cellId) < getCellIndex(targetState.cellId)) {
                createLink(fromMesh.position.clone(), toMesh.position.clone(), true);
              }
            }
          }
        }
      }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 3D PARTICLE ANIMATIONS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function create3DPulse(position, color = COLORS.message) {
      const geometry = new THREE.SphereGeometry(5, 16, 16);
      const material = new THREE.MeshBasicMaterial({
        color: color,
        transparent: true,
        opacity: 0.8
      });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.copy(position);
      scene.add(mesh);

      pulseObjects.push({
        mesh,
        startTime: performance.now(),
        duration: 800
      });
    }

    function create3DParticle(path, color = COLORS.message) {
      if (path.length < 2) return;

      const geometry = new THREE.SphereGeometry(4, 16, 16);
      const material = new THREE.MeshBasicMaterial({
        color: color,
        transparent: true,
        opacity: 1
      });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.copy(path[0]);
      scene.add(mesh);

      // Add trail
      const trailGeometry = new THREE.BufferGeometry();
      const trailMaterial = new THREE.LineBasicMaterial({
        color: color,
        transparent: true,
        opacity: 0.5
      });
      const trail = new THREE.Line(trailGeometry, trailMaterial);
      scene.add(trail);

      particleObjects.push({
        mesh,
        trail,
        path: path.map(p => p.clone()),
        currentSegment: 0,
        progress: 0,
        startTime: performance.now()
      });
    }

    function animate3DMessage(fromId, fromCellId) {
      const fromMesh = nodeObjects.get(fromId);
      const fromCellMesh = cellObjects.get(fromCellId);

      if (fromMesh) {
        create3DPulse(fromMesh.position.clone(), COLORS.message);
      }

      // Animate to peers in same cell
      const sameCellPeers = getPeersInCell(fromCellId).filter(pid => pid !== fromId);
      sameCellPeers.forEach((peerId, idx) => {
        setTimeout(() => {
          const toMesh = nodeObjects.get(peerId);
          if (fromMesh && fromCellMesh && toMesh) {
            create3DParticle([
              fromMesh.position.clone(),
              fromCellMesh.position.clone(),
              toMesh.position.clone()
            ], COLORS.message);
          }
        }, idx * 100);
      });

      // Animate to other cells
      if (getBridgesPerEdge() > 0) {
        const allCells = getAllCellIds();
        const otherCells = allCells.filter(cid => cid !== fromCellId);

        otherCells.forEach((toCellId, cellIdx) => {
          setTimeout(() => {
            const path = build3DPath(fromId, fromCellId, toCellId);
            if (path.length >= 1) {
              const destPeers = getPeersInCell(toCellId);
              destPeers.forEach((destPeerId, peerIdx) => {
                setTimeout(() => {
                  const destMesh = nodeObjects.get(destPeerId);
                  if (destMesh) {
                    create3DParticle([...path, destMesh.position.clone()], COLORS.message);
                  }
                }, peerIdx * 80);
              });
            }
          }, (sameCellPeers.length * 100) + (cellIdx * 150));
        });
      }
    }

    function build3DPath(fromPeerId, fromCellId, toCellId) {
      const path = [];
      const fromMesh = nodeObjects.get(fromPeerId);
      if (fromMesh) path.push(fromMesh.position.clone());

      const fromCellMesh = cellObjects.get(fromCellId);
      if (fromCellMesh) path.push(fromCellMesh.position.clone());

      const fromIdx = getCellIndex(fromCellId);
      const toIdx = getCellIndex(toCellId);

      if (!Number.isNaN(fromIdx) && !Number.isNaN(toIdx) && fromIdx !== toIdx) {
        const step = fromIdx < toIdx ? 1 : -1;
        let currentIdx = fromIdx + step;
        while (currentIdx !== toIdx + step) {
          const cellId = `cell-${currentIdx}`;
          const cellMesh = cellObjects.get(cellId);
          if (cellMesh) path.push(cellMesh.position.clone());
          currentIdx += step;
        }
      }
      return path;
    }

    function updateParticles() {
      const now = performance.now();

      // Update pulses
      for (let i = pulseObjects.length - 1; i >= 0; i--) {
        const p = pulseObjects[i];
        const elapsed = now - p.startTime;
        const progress = elapsed / p.duration;

        if (progress >= 1) {
          scene.remove(p.mesh);
          p.mesh.geometry.dispose();
          p.mesh.material.dispose();
          pulseObjects.splice(i, 1);
        } else {
          const scale = 1 + progress * 4;
          p.mesh.scale.set(scale, scale, scale);
          p.mesh.material.opacity = 0.8 * (1 - progress);
        }
      }

      // Update particles
      for (let i = particleObjects.length - 1; i >= 0; i--) {
        const p = particleObjects[i];
        p.progress += 0.03;

        if (p.progress >= 1) {
          p.progress = 0;
          p.currentSegment++;

          if (p.currentSegment >= p.path.length - 1) {
            const lastPos = p.path[p.path.length - 1];
            create3DPulse(lastPos, COLORS.cell);
            
            scene.remove(p.mesh);
            scene.remove(p.trail);
            p.mesh.geometry.dispose();
            p.mesh.material.dispose();
            p.trail.geometry.dispose();
            p.trail.material.dispose();
            particleObjects.splice(i, 1);
            continue;
          }
        }

        if (p.currentSegment < p.path.length - 1) {
          const from = p.path[p.currentSegment];
          const to = p.path[p.currentSegment + 1];
          p.mesh.position.lerpVectors(from, to, p.progress);

          // Update trail
          const trailPoints = [];
          for (let j = 0; j <= p.currentSegment; j++) {
            trailPoints.push(p.path[j]);
          }
          trailPoints.push(p.mesh.position.clone());
          p.trail.geometry.setFromPoints(trailPoints);
        }
      }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ANIMATION LOOP
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function animate() {
      requestAnimationFrame(animate);

      // Auto-rotate
      if (autoRotate) {
        rotationY += 0.002;
      }

      // Rotate scene
      scene.rotation.y = rotationY;
      scene.rotation.x = rotationX;

      // Update particles
      updateParticles();

      // Animate cells
      for (const [, mesh] of cellObjects) {
        mesh.rotation.y += 0.01;
        mesh.rotation.x += 0.005;
      }

      // Animate nodes (pulsing)
      const time = performance.now() * 0.001;
      for (const [id, mesh] of nodeObjects) {
        const scale = 1 + Math.sin(time * 2 + id.charCodeAt(0)) * 0.1;
        mesh.scale.set(scale, scale, scale);
      }

      // Update background particles
      scene.children.forEach(child => {
        if (child.userData.isBackground) {
          child.rotation.y += 0.0002;
          child.rotation.x += 0.0001;
        }
      });

      renderer.render(scene, camera);
      trackFps();
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STATE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const $ = id => document.getElementById(id);
    const shortId = id => id?.length > 10 ? `${id.slice(0, 4)}..${id.slice(-4)}` : id;

    let db = null, room = null, mesh = null;

    const CELLS_CONFIG = {
      cellSize: 4,
      bridgesPerEdge: 2,
      maxCellSize: 50,
      targetCells: 100
    };

    let selfState = {
      cellId: null,
      isBridge: false,
      bridges: [],
      cellSize: CELLS_CONFIG.cellSize,
      bridgesPerEdge: CELLS_CONFIG.bridgesPerEdge
    };

    const remotePeerStates = new Map();

    let connectedAt = null;
    let stats = { msgSent: 0, msgRecv: 0, bytesOut: 0, bytesIn: 0 };
    let lastFrameTime = performance.now();
    let frameCount = 0;
    let currentFps = 0;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // HELPERS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const getCellIndex = cid => {
      const m = String(cid || "").match(/cell-(\d+)/);
      return m ? Number(m[1]) : NaN;
    };

    const neighborCells = cid => {
      const i = getCellIndex(cid);
      if (Number.isNaN(i)) return [];
      const arr = [];
      if (i > 0) arr.push(`cell-${i - 1}`);
      arr.push(`cell-${i + 1}`);
      return arr;
    };

    function getAllPeers() {
      const all = new Map();
      for (const [pid, state] of remotePeerStates) {
        all.set(pid, { ...state });
      }
      if (selfId) {
        all.set(selfId, {
          cellId: selfState.cellId,
          isBridge: selfState.isBridge,
          bridges: selfState.bridges || []
        });
      }
      return all;
    }

    function getBridgesPerEdge() {
      return selfState.bridgesPerEdge ?? CELLS_CONFIG.bridgesPerEdge;
    }

    function getCellSize() {
      return selfState.cellSize || CELLS_CONFIG.cellSize;
    }

    function getPeersInCell(cellId) {
      const peers = [];
      const allPeers = getAllPeers();
      for (const [pid, st] of allPeers) {
        if (st.cellId === cellId) peers.push(pid);
      }
      return peers;
    }

    function getAllCellIds() {
      const cells = new Set();
      const allPeers = getAllPeers();
      for (const [pid, st] of allPeers) {
        if (st.cellId) cells.add(st.cellId);
      }
      return [...cells].sort((a, b) => getCellIndex(a) - getCellIndex(b));
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // BRIDGE DETECTION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    let cachedBridgeMap = new Map();
    let cacheValid = false;

    function invalidateCache() { cacheValid = false; }

    function computeAllBridges() {
      if (cacheValid) return cachedBridgeMap;
      cachedBridgeMap.clear();
      const allPeers = getAllPeers();
      const allPeerIds = [...allPeers.keys()];
      for (const [pid, st] of allPeers) {
        cachedBridgeMap.set(pid, isPeerBridge(pid, st.cellId, allPeerIds));
      }
      cacheValid = true;
      return cachedBridgeMap;
    }

    function isCachedBridge(peerId) {
      return computeAllBridges().get(peerId) || false;
    }

    function computeBridgesForCell(cellId, allPeerIds) {
      const bridgesPerEdge = getBridgesPerEdge();
      const bridges = new Set();
      if (bridgesPerEdge === 0) return bridges;
      const cellIdx = getCellIndex(cellId);
      if (Number.isNaN(cellIdx)) return bridges;
      const cellSize = getCellSize();
      const sorted = [...allPeerIds].sort();
      const neighbors = neighborCells(cellId);
      for (const neighborCell of neighbors) {
        const neighborIdx = getCellIndex(neighborCell);
        if (Number.isNaN(neighborIdx)) continue;
        const minIdx = Math.min(cellIdx, neighborIdx);
        const maxIdx = Math.max(cellIdx, neighborIdx);
        const start = minIdx * cellSize;
        const end = (maxIdx + 1) * cellSize;
        const edgeGroup = sorted.slice(start, end);
        if (edgeGroup.length === 0) continue;
        for (const pid of edgeGroup.slice(0, bridgesPerEdge)) {
          bridges.add(pid);
        }
      }
      return bridges;
    }

    function isPeerBridge(peerId, cellId, allPeerIds) {
      if (!cellId) return false;
      return computeBridgesForCell(cellId, allPeerIds).has(peerId);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // UI UPDATES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function updateUI() {
      $("cellId").textContent = selfState.cellId?.replace('cell-', 'C-') || "---";
      $("cellSize").textContent = selfState.cellSize || "--";
      $("peerCount").textContent = remotePeerStates.size + 1;
      $("roleStatus").textContent = selfState.isBridge ? "Bridge" : "Peer";

      const allPeers = getAllPeers();
      const cells = new Set();
      let bridges = 0;
      const bridgeMap = computeAllBridges();
      for (const [pid, st] of allPeers) {
        if (st.cellId) cells.add(st.cellId);
        if (bridgeMap.get(pid)) bridges++;
      }

      $("metricPeers").textContent = allPeers.size;
      $("metricCells").textContent = cells.size;
      $("metricBridges").textContent = bridges;
      $("metricCellSize").textContent = selfState.cellSize || "--";

      updateConnectionStats();
      create3DLayout();
    }

    function formatBytes(bytes) {
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
      return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
    }

    function formatUptime(ms) {
      const secs = Math.floor(ms / 1000);
      const hrs = Math.floor(secs / 3600);
      const mins = Math.floor((secs % 3600) / 60);
      const s = secs % 60;
      return `${hrs.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
    }

    function updateConnectionStats() {
      if (connectedAt) $("connUptime").textContent = formatUptime(Date.now() - connectedAt);
      $("connBytesOut").textContent = formatBytes(stats.bytesOut);
      $("connBytesIn").textContent = formatBytes(stats.bytesIn);
    }

    function updateSystemStats() {
      if (performance.memory) {
        $("sysMemory").textContent = (performance.memory.usedJSHeapSize / 1024).toFixed(1) + " KB";
      } else {
        $("sysMemory").textContent = "N/A";
      }
      $("sysFps").textContent = currentFps;
    }

    function trackFps() {
      frameCount++;
      const now = performance.now();
      if (now - lastFrameTime >= 1000) {
        currentFps = frameCount;
        frameCount = 0;
        lastFrameTime = now;
        updateSystemStats();
      }
    }

    setInterval(() => { updateConnectionStats(); }, 1000);

    function log(msg) {
      const el = $("log");
      const entry = document.createElement("div");
      entry.className = "chat-entry";
      const time = new Date().toLocaleTimeString('en-US', { hour12: false });
      entry.innerHTML = `<span class="time">[${time}]</span> ${msg}`;
      el.appendChild(entry);
      el.scrollTop = el.scrollHeight;
      while (el.children.length > 50) el.removeChild(el.firstChild);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // THROTTLED UPDATE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    let updatePending = false;
    let lastUpdateTime = 0;
    const UPDATE_THROTTLE = 250;

    function scheduleUpdate() {
      if (updatePending) return;
      const now = Date.now();
      const elapsed = now - lastUpdateTime;
      if (elapsed >= UPDATE_THROTTLE) {
        updatePending = true;
        requestAnimationFrame(doUpdate);
      } else {
        updatePending = true;
        setTimeout(() => requestAnimationFrame(doUpdate), UPDATE_THROTTLE - elapsed);
      }
    }

    function doUpdate() {
      updateUI();
      lastUpdateTime = Date.now();
      updatePending = false;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CONNECT & EVENTS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const relayUrls = ["wss://relay.orangepill.ovh"];

    async function connect() {
      try {
        log('Initializing 3D mesh network...');
        
        db = await gdb('mesh-cells-monitor', {
          rtc: { relayUrls, cells: { ...CELLS_CONFIG, debug: false } }
        });

        room = db.room;
        mesh = room.mesh;
        selfId = db.selfId;

        $("statusBadge").classList.remove('connecting', 'offline');
        $("connectionStatus").textContent = "Online";
        $("connStatus").textContent = "Online";
        $("connStatus").className = "metric-value success";
        connectedAt = Date.now();

        room.on("peer:join", id => {
          log(`<span class="success">+ ${shortId(id)} joined</span>`);
          invalidateCache();
          scheduleUpdate();
        });

        room.on("peer:leave", id => {
          remotePeerStates.delete(id);
          log(`<span class="c-dim">- ${shortId(id)} left</span>`);
          invalidateCache();
          scheduleUpdate();
        });

        room.on("mesh:state", state => {
          selfState = {
            cellId: state.cellId,
            isBridge: state.isBridge === true,
            bridges: Array.isArray(state.bridges) ? state.bridges : [],
            cellSize: state.cellSize || CELLS_CONFIG.cellSize,
            bridgesPerEdge: state.bridgesPerEdge ?? CELLS_CONFIG.bridgesPerEdge
          };
          invalidateCache();
          scheduleUpdate();
        });

        room.on("mesh:peer-state", data => {
          if (data.id === selfId) return;
          remotePeerStates.set(data.id, {
            cellId: data.cell,
            isBridge: data.isBridge === true,
            bridges: Array.isArray(data.bridges) ? data.bridges : []
          });
          invalidateCache();
          scheduleUpdate();
        });

        mesh.on("message", (msg, from) => {
          if (from === selfId) return;
          const content = typeof msg === "string" ? msg : JSON.stringify(msg).slice(0, 30);
          const msgSize = typeof msg === "string" ? msg.length : JSON.stringify(msg).length;
          stats.msgRecv++;
          stats.bytesIn += msgSize;
          log(`<span class="from">${shortId(from)}:</span> ${content}`);
          
          const fromState = remotePeerStates.get(from);
          if (fromState?.cellId) {
            animate3DMessage(from, fromState.cellId);
          }
        });

        $("msgInput").disabled = false;
        $("sendBtn").disabled = false;
        $("netRelay").textContent = "orangepill.ovh";
        $("netRoom").textContent = "mesh-cells-monitor";
        $("yourId").textContent = shortId(selfId);

        log('<span class="success">Connected to 3D mesh network</span>');

      } catch (error) {
        $("statusBadge").classList.remove('connecting');
        $("statusBadge").classList.add('offline');
        $("connectionStatus").textContent = "Error";
        log(`<span class="error">Error: ${error.message}</span>`);
      }
    }

    function sendMessage() {
      const input = $("msgInput");
      const text = input.value.trim();
      if (!text || !mesh) return;
      mesh.send(text);
      stats.msgSent++;
      stats.bytesOut += text.length;
      log(`<span class="you">You:</span> ${text}`);
      
      if (selfState.cellId) {
        animate3DMessage(selfId, selfState.cellId);
      }
      
      input.value = "";
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // INIT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    window.addEventListener("load", () => {
      initThreeJS();
      
      $("sendBtn").addEventListener("click", sendMessage);
      $("msgInput").addEventListener("keydown", e => { if (e.key === "Enter") sendMessage(); });

      log('Starting 3D Mesh Monitor...');
      setTimeout(() => connect(), 300);
      scheduleUpdate();
    });
  </script>
</body>

</html>
