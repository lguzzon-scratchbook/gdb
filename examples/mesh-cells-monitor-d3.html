<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Cellular Mesh Graph (Monitor Universal)</title>
  <style>
    :root {
      --bg: #0d1117;
      --surface: #161b22;
      --border: #30363d;
      --text: #e6edf3;
      --muted: #8b949e;
      --accent: #58a6ff;
      --green: #3fb950;
      --yellow: #f0c000;
      --cyan: #39c5cf;
      --orange: #ff6b35;
      --red: #f85149;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html,
    body {
      height: 100%;
    }

    body {
      background: var(--bg);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      color: var(--text);
      overflow: hidden;
    }

    /* Layout */
    .container {
      display: grid;
      grid-template-columns: 1fr 300px;
      grid-template-rows: auto 1fr auto;
      height: 100vh;
      gap: 1px;
      background: var(--border);
    }

    /* Header */
    .header {
      grid-column: 1 / -1;
      background: var(--surface);
      padding: 12px 20px;
      display: flex;
      align-items: center;
      gap: 20px;
      flex-wrap: wrap;
    }

    .header h1 {
      font-size: 1.2rem;
      font-weight: 600;
      color: var(--accent);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .header h1 .lite {
      font-size: 0.7rem;
      background: var(--cyan);
      color: var(--bg);
      padding: 2px 6px;
      border-radius: 4px;
      margin-left: 4px;
    }

    .status-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 12px;
      border-radius: 20px;
      font-size: 0.8rem;
      font-weight: 500;
    }

    .status-badge.self {
      background: rgba(88, 166, 255, 0.15);
      color: var(--accent);
      border: 1px solid var(--accent);
    }

    .status-badge.bridge {
      background: rgba(240, 192, 0, 0.15);
      color: var(--yellow);
      border: 1px solid var(--yellow);
    }

    .status-item {
      font-size: 0.85rem;
      color: var(--muted);
    }

    .status-item code {
      background: var(--bg);
      padding: 2px 8px;
      border-radius: 4px;
      font-family: monospace;
      color: var(--text);
    }

    /* Graph area */
    #graph {
      background: var(--bg);
      position: relative;
      overflow: hidden;
    }

    #graph svg {
      width: 100%;
      height: 100%;
    }

    /* Sidebar */
    .sidebar {
      background: var(--surface);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .sidebar-section {
      padding: 12px;
      border-bottom: 1px solid var(--border);
    }

    .sidebar-section h3 {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--muted);
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    /* Metrics grid */
    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
    }

    .metric-card {
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      text-align: center;
    }

    .metric-value {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--accent);
    }

    .metric-label {
      font-size: 0.7rem;
      color: var(--muted);
      text-transform: uppercase;
    }

    /* Cell list */
    .cell-list {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
    }

    .cell-item {
      margin-bottom: 10px;
      padding: 8px 12px;
      background: rgba(63, 185, 80, 0.1);
      border: 1px solid var(--green);
      border-radius: 8px;
    }

    .cell-header {
      display: flex;
      justify-content: space-between;
      font-size: 0.85rem;
      color: var(--green);
      font-weight: 600;
      margin-bottom: 6px;
    }

    .peer-item {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 3px 0;
      font-size: 0.75rem;
      color: var(--muted);
    }

    .peer-item.self {
      color: var(--accent);
      font-weight: 600;
    }

    .peer-item .badge {
      font-size: 0.6rem;
      padding: 1px 5px;
      border-radius: 10px;
    }

    .badge-you {
      background: var(--accent);
      color: var(--bg);
    }

    .badge-bridge {
      background: var(--yellow);
      color: var(--bg);
    }

    /* Chat footer */
    .chat-footer {
      grid-column: 1 / -1;
      background: var(--surface);
      padding: 12px 20px;
      display: flex;
      gap: 12px;
      align-items: stretch;
    }

    .chat-log {
      flex: 1;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 12px;
      font-size: 0.8rem;
      font-family: monospace;
      max-height: 80px;
      overflow-y: auto;
    }

    .chat-log .entry {
      padding: 2px 0;
    }

    .chat-log .from {
      color: var(--cyan);
    }

    .chat-log .self {
      color: var(--green);
    }

    .chat-log .direction {
      color: var(--muted);
      font-size: 0.7rem;
    }

    .chat-input-group {
      display: flex;
      gap: 8px;
    }

    .chat-input-group input {
      width: 250px;
      padding: 10px 14px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: var(--bg);
      color: var(--text);
      font-size: 0.9rem;
    }

    .chat-input-group input:focus {
      outline: none;
      border-color: var(--accent);
    }

    .chat-input-group button {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      background: var(--accent);
      color: var(--bg);
      font-weight: 600;
      cursor: pointer;
      transition: opacity 0.2s;
    }

    .chat-input-group button:hover {
      opacity: 0.9;
    }

    .chat-input-group button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* D3 Styles */
    .link {
      fill: none;
      stroke-linecap: round;
    }

    .link-cell {
      stroke: var(--green);
      stroke-width: 3;
      stroke-opacity: 0.6;
    }

    .link-bridge {
      stroke: var(--yellow);
      stroke-width: 2;
      stroke-dasharray: 5, 3;
      stroke-opacity: 0.8;
    }

    .link-membership {
      stroke: var(--muted);
      stroke-width: 1;
      stroke-opacity: 0.4;
    }

    .node-label {
      font-size: 10px;
      fill: var(--text);
      pointer-events: none;
      text-anchor: middle;
      dominant-baseline: middle;
    }

    .cell-label {
      font-weight: 600;
    }

    /* Message animation */
    .message-particle {
      fill: var(--cyan);
      filter: drop-shadow(0 0 10px var(--cyan)) drop-shadow(0 0 20px var(--cyan));
    }

    .message-trail {
      fill: none;
      stroke: var(--cyan);
      stroke-width: 2;
      stroke-opacity: 0.5;
      stroke-linecap: round;
      stroke-dasharray: 4, 2;
    }

    .message-label-bg {
      fill: var(--cyan);
      rx: 8;
      ry: 8;
      filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
    }

    .message-label-text {
      fill: var(--bg);
      font-size: 9px;
      font-weight: 600;
      text-anchor: middle;
      dominant-baseline: middle;
    }

    /* Pulse animation */
    @keyframes pulse {
      0% {
        r: 8;
        opacity: 1;
        stroke-width: 3;
      }

      100% {
        r: 45;
        opacity: 0;
        stroke-width: 1;
      }
    }

    .pulse-ring {
      fill: none;
      stroke: var(--cyan);
      stroke-width: 3;
      animation: pulse 0.8s ease-out forwards;
    }

    /* Node glow when active */
    @keyframes nodeGlow {
      0% {
        filter: drop-shadow(0 0 5px currentColor);
      }

      50% {
        filter: drop-shadow(0 0 15px currentColor) drop-shadow(0 0 25px currentColor);
      }

      100% {
        filter: drop-shadow(0 0 5px currentColor);
      }
    }

    .node-active {
      animation: nodeGlow 0.5s ease-in-out;
    }

    /* Legend */
    .legend {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      font-size: 0.75rem;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 4px 0;
    }

    .legend-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }

    .legend-line {
      width: 20px;
      height: 3px;
      border-radius: 2px;
    }

    @media (max-width: 900px) {
      .container {
        grid-template-columns: 1fr;
      }

      .sidebar {
        display: none;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <!-- Header -->
    <header class="header">
      <h1>üî∑ Cellular Mesh<span class="lite">MONITOR</span></h1>
      <span class="status-badge self" id="selfBadge">YOU</span>
      <span class="status-badge bridge" id="roleBadge" style="display:none">BRIDGE</span>
      <div class="status-item">Cell: <code id="cellId">-</code></div>
      <div class="status-item">Size: <code id="cellSizeVal">-</code></div>
      <div class="status-item">TTL: <code id="ttlValue">-</code></div>
      <div class="status-item">Peers: <code id="peerCount">0</code></div>
    </header>

    <!-- Graph -->
    <div id="graph">
      <div class="legend">
        <div class="legend-item">
          <div class="legend-dot" style="background:var(--accent)"></div> You
        </div>
        <div class="legend-item">
          <div class="legend-dot" style="background:var(--orange)"></div> Peer
        </div>
        <div class="legend-item">
          <div class="legend-dot" style="background:var(--yellow)"></div> Bridge
        </div>
        <div class="legend-item">
          <div class="legend-dot" style="background:var(--green)"></div> Cell
        </div>
        <div class="legend-item">
          <div class="legend-line" style="background:var(--cyan)"></div> Message
        </div>
      </div>
    </div>

    <!-- Sidebar -->
    <aside class="sidebar">
      <div class="sidebar-section">
        <h3>üìä Metrics</h3>
        <div class="metrics-grid">
          <div class="metric-card">
            <div class="metric-value" id="metricPeers">0</div>
            <div class="metric-label">Peers</div>
          </div>
          <div class="metric-card">
            <div class="metric-value" id="metricCells">0</div>
            <div class="metric-label">Cells</div>
          </div>
          <div class="metric-card">
            <div class="metric-value" id="metricBridges">0</div>
            <div class="metric-label">Bridges</div>
          </div>
          <div class="metric-card">
            <div class="metric-value" id="metricCellSize">-</div>
            <div class="metric-label">Cell Size</div>
          </div>
        </div>
      </div>
      <div class="cell-list" id="cellList"></div>
    </aside>

    <!-- Chat -->
    <footer class="chat-footer">
      <div class="chat-log" id="log"></div>
      <div class="chat-input-group">
        <input type="text" id="msgInput" placeholder="Type message..." disabled />
        <button id="sendBtn" disabled>Send</button>
      </div>
    </footer>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
  <script type="module">
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // IMPORT: GenosDB (gdb) con soporte RTC
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    import { gdb } from "../dist/index.js";

    // selfId se obtendr√° despu√©s de inicializar gdb
    let selfId = null;

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // CONSTANTS & STATE
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const COLORS = {
      cell: "#3fb950",      // Verde brillante
      bridge: "#f0c000",    // Amarillo dorado
      peer: "#ff6b35",      // Naranja rojizo
      self: "#58a6ff",      // Azul
      message: "#39c5cf",   // Cyan
      green: "#3fb950"
    };

    const $ = id => document.getElementById(id);
    const shortId = id => id?.length > 10 ? `${id.slice(0, 4)}‚Ä¶${id.slice(-4)}` : id;

    let db = null, room = null, mesh = null;

    // Estado de SELF (simplificado, sin super-cells)
    let selfState = {
      cellId: null,
      isBridge: false,
      bridges: [],
      dynamicTTL: null,
      cellSize: 2
    };

    // Peers remotos
    const remotePeerStates = new Map();

    const getCellIndex = cid => {
      const m = String(cid || "").match(/cell-(\d+)/);
      return m ? Number(m[1]) : NaN;
    };

    const neighborCells = cid => {
      const i = getCellIndex(cid);
      if (Number.isNaN(i)) return [];
      const arr = [];
      if (i > 0) arr.push(`cell-${i - 1}`);
      arr.push(`cell-${i + 1}`);
      return arr;
    };

    // Obtener todos los peers
    function getAllPeers() {
      const all = new Map();

      for (const [pid, state] of remotePeerStates) {
        all.set(pid, { ...state });
      }

      all.set(selfId, {
        cellId: selfState.cellId,
        isBridge: selfState.isBridge,
        bridges: selfState.bridges || []
      });

      return all;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // BRIDGE DETECTION - Calculado localmente
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const BRIDGES_PER_EDGE = 1;

    // Usar cellSize din√°mico del estado
    function getCellSize() {
      return selfState.cellSize || 2;
    }

    function computeBridgesForCell(cellId, allPeerIds) {
      const bridges = new Set();
      const cellIdx = getCellIndex(cellId);
      if (Number.isNaN(cellIdx)) return bridges;

      const cellSize = getCellSize();
      const sorted = [...allPeerIds].sort();
      const neighbors = neighborCells(cellId);

      for (const neighborCell of neighbors) {
        const neighborIdx = getCellIndex(neighborCell);
        if (Number.isNaN(neighborIdx)) continue;

        const minIdx = Math.min(cellIdx, neighborIdx);
        const maxIdx = Math.max(cellIdx, neighborIdx);
        const start = minIdx * cellSize;
        const end = (maxIdx + 1) * cellSize;
        const edgeGroup = sorted.slice(start, end);

        if (edgeGroup.length === 0) continue;

        const bridgePeers = edgeGroup.slice(0, BRIDGES_PER_EDGE);
        for (const pid of bridgePeers) {
          bridges.add(pid);
        }
      }

      return bridges;
    }

    function isPeerBridge(peerId, cellId, allPeerIds) {
      if (!cellId) return false;
      const bridges = computeBridgesForCell(cellId, allPeerIds);
      return bridges.has(peerId);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // D3 SETUP
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const graphEl = $("graph");
    let width = graphEl.clientWidth;
    let height = graphEl.clientHeight;

    const svg = d3.select("#graph").append("svg")
      .attr("viewBox", `0 0 ${width} ${height}`);

    const defs = svg.append("defs");
    const linkLayer = svg.append("g").attr("class", "links");
    const nodeLayer = svg.append("g").attr("class", "nodes");
    const labelLayer = svg.append("g").attr("class", "labels");
    const animLayer = svg.append("g").attr("class", "animations");

    const glow = defs.append("filter").attr("id", "glow");
    glow.append("feGaussianBlur").attr("stdDeviation", "3").attr("result", "coloredBlur");
    const feMerge = glow.append("feMerge");
    feMerge.append("feMergeNode").attr("in", "coloredBlur");
    feMerge.append("feMergeNode").attr("in", "SourceGraphic");

    const simulation = d3.forceSimulation()
      .force("link", d3.forceLink().id(d => d.id).distance(d =>
        d.kind === "cell-link" ? 120 :
          d.kind === "bridge-link" ? 70 :
            40
      ).strength(d => d.kind === "bridge-link" ? 0.8 : 0.5))
      .force("charge", d3.forceManyBody().strength(-250))
      .force("center", d3.forceCenter(width / 2, height / 2))
      .force("collide", d3.forceCollide().radius(d => radiusFor(d) + 8))
      .on("tick", ticked);

    const nodePositions = new Map();

    function radiusFor(d) {
      if (d.kind === "cell") return 22;
      if (d.isSelf) return 14;
      if (d.isBridge) return 12;
      return 10;
    }

    function colorFor(d) {
      if (d.kind === "cell") return COLORS.cell;
      if (d.isSelf) return COLORS.self;
      if (d.isBridge) return COLORS.bridge;
      return COLORS.peer;
    }

    const drag = d3.drag()
      .on("start", (event, d) => {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
      })
      .on("drag", (event, d) => {
        d.fx = event.x;
        d.fy = event.y;
      })
      .on("end", (event, d) => {
        if (!event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
      });

    function ticked() {
      linkLayer.selectAll("line")
        .attr("x1", d => d.source.x)
        .attr("y1", d => d.source.y)
        .attr("x2", d => d.target.x)
        .attr("y2", d => d.target.y);

      nodeLayer.selectAll("circle")
        .attr("cx", d => d.x)
        .attr("cy", d => d.y);

      labelLayer.selectAll("text")
        .attr("x", d => d.x)
        .attr("y", d => d.y + radiusFor(d) + 12);

      nodeLayer.selectAll("circle").each(function (d) {
        nodePositions.set(d.id, { x: d.x, y: d.y, r: radiusFor(d) });
      });
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // GRAPH RENDERING (sin super-cells)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function buildGraph() {
      const nodes = [];
      const links = [];
      const cellIds = new Set();

      const allPeers = getAllPeers();
      const allPeerIds = [...allPeers.keys()];

      // Collect cells (sin super-cells)
      for (const [pid, st] of allPeers) {
        if (st.cellId) {
          cellIds.add(st.cellId);
        }
      }

      // Cell nodes
      for (const cid of cellIds) {
        nodes.push({
          id: `cell:${cid}`,
          kind: "cell",
          cellId: cid,
          label: cid.replace("cell-", "C")
        });
      }

      // Peer nodes
      for (const [pid, st] of allPeers) {
        const isSelf = pid === selfId;

        let isBridge;
        if (isSelf) {
          isBridge = selfState.isBridge;
        } else {
          isBridge = isPeerBridge(pid, st.cellId, allPeerIds);
        }

        const bridgesArray = Array.isArray(st.bridges) ? st.bridges : [];

        nodes.push({
          id: `peer:${pid}`,
          kind: "peer",
          peerId: pid,
          cellId: st.cellId,
          isBridge: isBridge,
          isSelf: isSelf,
          bridges: bridgesArray,
          label: shortId(pid)
        });
      }

      // Links: peer ‚Üí cell
      for (const n of nodes) {
        if (n.kind === "peer" && n.cellId) {
          links.push({
            source: n.id,
            target: `cell:${n.cellId}`,
            kind: "membership"
          });
        }
      }

      // Links: cell ‚Üí cell (adjacent)
      const sortedCells = [...cellIds]
        .map(cid => ({ cid, idx: getCellIndex(cid) }))
        .filter(o => !Number.isNaN(o.idx))
        .sort((a, b) => a.idx - b.idx);

      for (let i = 0; i < sortedCells.length - 1; i++) {
        const curr = sortedCells[i];
        const next = sortedCells[i + 1];
        if (next.idx - curr.idx === 1) {
          links.push({
            source: `cell:${curr.cid}`,
            target: `cell:${next.cid}`,
            kind: "cell-link"
          });
        }
      }

      // Links: bridge peer ‚Üí neighbor cells
      for (const n of nodes) {
        if (n.kind !== "peer" || !n.isBridge || !n.cellId) continue;

        const bridgeCells = n.bridges.length > 0 ? n.bridges : neighborCells(n.cellId);

        for (const nc of bridgeCells) {
          if (!cellIds.has(nc)) continue;
          if (nc === n.cellId) continue;

          links.push({
            source: n.id,
            target: `cell:${nc}`,
            kind: "bridge-link"
          });
        }
      }

      return { nodes, links };
    }

    function render(restart = false) {
      const { nodes, links } = buildGraph();

      // Links
      const link = linkLayer.selectAll("line")
        .data(links, d => `${d.source.id || d.source}-${d.target.id || d.target}-${d.kind}`);

      link.exit().transition().duration(200).style("opacity", 0).remove();

      const linkEnter = link.enter()
        .append("line")
        .attr("class", d => {
          switch (d.kind) {
            case "membership": return "link link-membership";
            case "cell-link": return "link link-cell";
            case "bridge-link": return "link link-bridge";
            default: return "link";
          }
        })
        .style("opacity", 0);

      linkEnter.transition().duration(300).style("opacity", 1);
      linkEnter.merge(link);

      // Nodes
      const node = nodeLayer.selectAll("circle")
        .data(nodes, d => d.id);

      node.exit().transition().duration(200).attr("r", 0).remove();

      const nodeEnter = node.enter()
        .append("circle")
        .attr("r", 0)
        .attr("fill", d => colorFor(d))
        .attr("stroke", d => d.isSelf ? "#fff" : "none")
        .attr("stroke-width", d => d.isSelf ? 3 : 0)
        .attr("filter", d => d.isBridge ? "url(#glow)" : null)
        .style("cursor", "pointer")
        .call(drag);

      nodeEnter.transition().duration(300).attr("r", d => radiusFor(d));

      node.transition()
        .duration(200)
        .attr("r", d => radiusFor(d))
        .attr("fill", d => colorFor(d))
        .attr("stroke", d => d.isSelf ? "#fff" : "none")
        .attr("stroke-width", d => d.isSelf ? 3 : 0)
        .attr("filter", d => d.isBridge ? "url(#glow)" : null);

      // Labels
      const label = labelLayer.selectAll("text")
        .data(nodes, d => d.id);

      label.exit().remove();

      label.enter()
        .append("text")
        .attr("class", d => `node-label ${d.kind === "cell" ? "cell-label" : ""}`)
        .merge(label)
        .text(d => d.label);

      simulation.nodes(nodes);
      simulation.force("link").links(links);

      if (restart) {
        simulation.alpha(0.8).restart();
      } else {
        simulation.alpha(0.3).restart();
      }

      updateUI();
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // MESSAGE ANIMATION
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function findBridgeBetweenCells(fromCellId, toCellId) {
      const allPeers = getAllPeers();
      const allPeerIds = [...allPeers.keys()];

      for (const [pid, st] of allPeers) {
        if (!isPeerBridge(pid, st.cellId, allPeerIds)) continue;

        const peerCell = st.cellId;
        const bridgeCells = st.bridges?.length > 0 ? st.bridges : neighborCells(peerCell);

        if (peerCell === fromCellId && bridgeCells.includes(toCellId)) {
          return pid;
        }
        if (peerCell === toCellId && bridgeCells.includes(fromCellId)) {
          return pid;
        }
      }
      return null;
    }

    function getPeersInCell(cellId) {
      const peers = [];
      const allPeers = getAllPeers();

      for (const [pid, st] of allPeers) {
        if (st.cellId === cellId) {
          peers.push(pid);
        }
      }
      return peers;
    }

    function buildFullMessagePath(fromPeerId, fromCellId, toCellId) {
      const path = [];

      path.push({ type: "peer", id: fromPeerId, cellId: fromCellId });
      path.push({ type: "cell", id: fromCellId });

      const fromIdx = getCellIndex(fromCellId);
      const toIdx = getCellIndex(toCellId);

      if (!Number.isNaN(fromIdx) && !Number.isNaN(toIdx) && fromIdx !== toIdx) {
        const step = fromIdx < toIdx ? 1 : -1;
        let currentCellIdx = fromIdx;

        while (currentCellIdx !== toIdx) {
          const currentCell = `cell-${currentCellIdx}`;
          const nextCellIdx = currentCellIdx + step;
          const nextCell = `cell-${nextCellIdx}`;

          const bridgePeer = findBridgeBetweenCells(currentCell, nextCell);

          if (bridgePeer) {
            path.push({ type: "bridge", id: bridgePeer, fromCell: currentCell, toCell: nextCell });
          }

          path.push({ type: "cell", id: nextCell });

          currentCellIdx = nextCellIdx;
        }
      }

      const destPeers = getPeersInCell(toCellId).filter(pid => pid !== fromPeerId);
      for (const peerId of destPeers) {
        path.push({ type: "dest-peer", id: peerId, cellId: toCellId });
      }

      return path;
    }

    function animateFullMessage(fromPeerId, fromCellId, messageText) {
      const allCells = getAllCellIds();
      const fromPeerPos = nodePositions.get(`peer:${fromPeerId}`);

      if (!fromPeerPos) return;

      createPulse(fromPeerPos.x, fromPeerPos.y, COLORS.message);
      flashNode(`peer:${fromPeerId}`, COLORS.message);

      const sameCellPeers = getPeersInCell(fromCellId).filter(pid => pid !== fromPeerId);
      sameCellPeers.forEach((peerId, idx) => {
        setTimeout(() => {
          animatePeerToPeer(fromPeerId, peerId, fromCellId, messageText, idx === 0);
        }, idx * 150);
      });

      const otherCells = allCells.filter(cid => cid !== fromCellId);
      otherCells.forEach((toCellId, index) => {
        const fullPath = buildFullMessagePath(fromPeerId, fromCellId, toCellId);
        setTimeout(() => {
          animateAlongFullPath(fullPath, messageText, index === 0);
        }, (sameCellPeers.length * 150) + (index * 200));
      });
    }

    function animatePeerToPeer(fromPeerId, toPeerId, cellId, messageText, showLabel) {
      const fromPos = nodePositions.get(`peer:${fromPeerId}`);
      const cellPos = nodePositions.get(`cell:${cellId}`);
      const toPos = nodePositions.get(`peer:${toPeerId}`);

      if (!fromPos || !cellPos || !toPos) return;

      const points = [
        { ...fromPos, nodeType: "peer", nodeId: fromPeerId },
        { ...cellPos, nodeType: "cell", nodeId: cellId },
        { ...toPos, nodeType: "dest-peer", nodeId: toPeerId }
      ];

      animateParticleAlongPoints(points, messageText, showLabel, () => {
        createPulse(toPos.x, toPos.y, COLORS.green);
        flashNode(`peer:${toPeerId}`, COLORS.green);
      }, true);
    }

    function animateAlongFullPath(path, messageText, showLabel = true) {
      if (path.length < 2) return;

      const points = path.map(node => {
        let pos;
        if (node.type === "peer" || node.type === "dest-peer") {
          pos = nodePositions.get(`peer:${node.id}`);
        } else if (node.type === "bridge") {
          pos = nodePositions.get(`peer:${node.id}`);
        } else if (node.type === "cell") {
          pos = nodePositions.get(`cell:${node.id}`);
        }

        if (!pos) return null;

        return {
          ...pos,
          nodeType: node.type,
          nodeId: node.id
        };
      }).filter(p => p && p.x !== undefined);

      if (points.length < 2) return;

      animateParticleAlongPoints(points, messageText, showLabel, null, true);
    }

    function animateParticleAlongPoints(points, messageText, showLabel, onComplete, flashIntermediates = false) {
      if (points.length < 2) return;

      const startPos = points[0];

      const particle = animLayer.append("circle")
        .attr("class", "message-particle")
        .attr("r", 6)
        .attr("cx", startPos.x)
        .attr("cy", startPos.y);

      let label = null;
      let labelBg = null;
      const displayText = messageText?.length > 12 ? messageText.slice(0, 12) + "‚Ä¶" : messageText;

      if (showLabel && messageText) {
        labelBg = animLayer.append("rect")
          .attr("class", "message-label-bg")
          .attr("x", startPos.x - 35)
          .attr("y", startPos.y - 30)
          .attr("width", 70)
          .attr("height", 18);

        label = animLayer.append("text")
          .attr("class", "message-label-text")
          .attr("x", startPos.x)
          .attr("y", startPos.y - 21)
          .text(displayText);
      }

      const trail = animLayer.append("path")
        .attr("class", "message-trail")
        .attr("d", `M${startPos.x},${startPos.y}`);

      let currentSegment = 0;
      const segmentDuration = 250;

      function animateNextSegment() {
        if (currentSegment >= points.length - 1) {
          const lastPoint = points[points.length - 1];
          createPulse(lastPoint.x, lastPoint.y, COLORS.green);

          if (lastPoint.nodeId) {
            const nodeKey = lastPoint.nodeType === "cell"
              ? `cell:${lastPoint.nodeId}`
              : `peer:${lastPoint.nodeId}`;
            flashNode(nodeKey, COLORS.green);
          }

          setTimeout(() => {
            particle.remove();
            trail.remove();
            if (label) label.remove();
            if (labelBg) labelBg.remove();
          }, 400);

          if (onComplete) onComplete();
          return;
        }

        const start = points[currentSegment];
        const end = points[currentSegment + 1];

        let duration = segmentDuration;
        if (end.nodeType === "bridge") duration = 180;
        if (end.nodeType === "dest-peer") duration = 280;

        particle.transition()
          .duration(duration)
          .ease(d3.easeCubicInOut)
          .attr("cx", end.x)
          .attr("cy", end.y);

        if (label && labelBg) {
          label.transition()
            .duration(duration)
            .ease(d3.easeCubicInOut)
            .attr("x", end.x)
            .attr("y", end.y - 21);

          labelBg.transition()
            .duration(duration)
            .ease(d3.easeCubicInOut)
            .attr("x", end.x - 35)
            .attr("y", end.y - 30);
        }

        const trailPoints = points.slice(0, currentSegment + 2);
        const trailPath = trailPoints.map((p, i) => `${i === 0 ? 'M' : 'L'}${p.x},${p.y}`).join(' ');
        trail.transition()
          .duration(duration)
          .attr("d", trailPath);

        if (flashIntermediates && currentSegment > 0) {
          const prevPoint = points[currentSegment];
          if (prevPoint.nodeId) {
            const color = prevPoint.nodeType === "bridge" ? COLORS.bridge :
              prevPoint.nodeType === "cell" ? COLORS.cell : COLORS.peer;
            createPulse(prevPoint.x, prevPoint.y, color, 0.6);

            const nodeKey = prevPoint.nodeType === "cell"
              ? `cell:${prevPoint.nodeId}`
              : `peer:${prevPoint.nodeId}`;
            flashNode(nodeKey, color);
          }
        }

        currentSegment++;
        setTimeout(animateNextSegment, duration);
      }

      animateNextSegment();
    }

    function flashNode(nodeId, color) {
      const node = nodeLayer.selectAll("circle").filter(d => d.id === nodeId);
      if (node.empty()) return;

      const originalColor = node.attr("fill");
      const originalFilter = node.attr("filter");

      node
        .transition()
        .duration(150)
        .attr("fill", color)
        .attr("filter", "url(#glow)")
        .transition()
        .duration(300)
        .attr("fill", originalColor)
        .attr("filter", originalFilter);
    }

    function animateIncomingMessage(fromPeerId, fromCellId, myPeerId, myCellId, messageText) {
      const fullPath = buildFullMessagePath(fromPeerId, fromCellId, myCellId);

      const finalPath = fullPath.filter(n => n.type !== "dest-peer");
      finalPath.push({ type: "dest-peer", id: myPeerId, cellId: myCellId });

      animateAlongFullPath(finalPath, messageText, true);
    }

    function createPulse(x, y, color = COLORS.message, opacity = 1) {
      const pulse = animLayer.append("circle")
        .attr("class", "pulse-ring")
        .attr("cx", x)
        .attr("cy", y)
        .attr("r", 10)
        .attr("stroke", color)
        .attr("opacity", opacity);

      setTimeout(() => pulse.remove(), 800);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // UI UPDATES (simplificado, sin super-cells)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function updateUI() {
      $("cellId").textContent = selfState.cellId || "-";
      $("cellSizeVal").textContent = selfState.cellSize || "-";
      $("ttlValue").textContent = selfState.dynamicTTL || "-";
      $("peerCount").textContent = remotePeerStates.size + 1;

      const roleBadge = $("roleBadge");
      if (selfState.isBridge) {
        roleBadge.textContent = "BRIDGE";
        roleBadge.className = "status-badge bridge";
        roleBadge.style.display = "inline-flex";
      } else {
        roleBadge.style.display = "none";
      }

      const cells = new Set();
      let bridges = 0;

      const allPeers = getAllPeers();
      const allPeerIds = [...allPeers.keys()];

      for (const [pid, st] of allPeers) {
        if (st.cellId) cells.add(st.cellId);
        if (isPeerBridge(pid, st.cellId, allPeerIds)) {
          bridges++;
        }
      }

      $("metricPeers").textContent = allPeers.size;
      $("metricCells").textContent = cells.size;
      $("metricBridges").textContent = bridges;
      $("metricCellSize").textContent = selfState.cellSize || "-";

      renderCellList(cells, allPeerIds);
    }

    function renderCellList(cells, allPeerIds) {
      const structure = new Map();
      const allPeers = getAllPeers();

      for (const [pid, st] of allPeers) {
        const c = st.cellId || "cell-?";
        if (!structure.has(c)) structure.set(c, new Set());
        structure.get(c).add(pid);
      }

      let html = "";
      const sortedCells = [...structure.keys()].sort((a, b) => {
        const aIdx = getCellIndex(a);
        const bIdx = getCellIndex(b);
        return aIdx - bIdx;
      });

      for (const cellId of sortedCells) {
        const peerSet = structure.get(cellId);
        html += `<div class="cell-item">`;
        html += `<div class="cell-header"><span>‚óà ${cellId}</span><span>${peerSet.size} peers</span></div>`;

        for (const pid of [...peerSet].sort()) {
          const isSelf = pid === selfId;
          const st = allPeers.get(pid) || {};
          const isBridge = isPeerBridge(pid, st.cellId, allPeerIds);

          let badges = "";
          if (isSelf) badges += `<span class="badge badge-you">YOU</span>`;
          if (isBridge) badges += `<span class="badge badge-bridge">B</span>`;

          html += `<div class="peer-item ${isSelf ? 'self' : ''}">${shortId(pid)} ${badges}</div>`;
        }

        html += `</div>`;
      }

      $("cellList").innerHTML = html || '<div style="color:var(--muted);padding:10px">No peers</div>';
    }

    function log(msg, direction = null) {
      const el = $("log");
      const entry = document.createElement("div");
      entry.className = "entry";

      let dirHtml = "";
      if (direction) {
        dirHtml = `<span class="direction">[${direction.from} ‚Üí ${direction.to.join(", ")}]</span> `;
      }

      entry.innerHTML = dirHtml + msg;
      el.appendChild(entry);
      el.scrollTop = el.scrollHeight;

      while (el.children.length > 50) {
        el.removeChild(el.firstChild);
      }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // MONITOR UNIVERSAL: Deduplicaci√≥n y formateo
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    // Set para evitar duplicados (mismos datos pueden llegar por m√∫ltiples canales)
    const seenMessages = new Set();
    const SEEN_TTL = 5000; // 5 segundos

    function handleIncomingData(data, from, source) {
      // Ignorar mensajes propios
      if (from === selfId) return;

      // Crear hash simple para detectar duplicados
      const dataStr = typeof data === "string" ? data : JSON.stringify(data);
      const hash = `${from}:${dataStr.slice(0, 100)}:${Math.floor(Date.now() / 1000)}`;
      
      if (seenMessages.has(hash)) return;
      seenMessages.add(hash);
      
      // Limpiar mensajes antiguos
      setTimeout(() => seenMessages.delete(hash), SEEN_TTL);

      // Formatear contenido para mostrar
      const content = formatDataForDisplay(data, source);
      
      const allPeers = getAllPeers();
      const fromState = allPeers.get(from);
      const fromCell = fromState?.cellId || "cell-?";
      const myCell = selfState.cellId || "cell-0";

      // Log con indicador de fuente
      const sourceIcon = {
        mesh: "üí¨",
        data: "üì¶",
        sync: "üîÑ"
      }[source] || "üì®";

      log(
        `<span class="from">${sourceIcon} ${shortId(from)}:</span> ${content}`,
        { from: fromCell, to: [myCell] }
      );

      // Animar
      if (fromCell !== myCell) {
        animateIncomingMessage(from, fromCell, selfId, myCell, content);
      } else {
        animatePeerToPeer(from, selfId, myCell, content, true);
      }
    }

    function formatDataForDisplay(data, source) {
      if (typeof data === "string") {
        return data.length > 50 ? data.slice(0, 50) + "‚Ä¶" : data;
      }
      
      if (typeof data === "object" && data !== null) {
        // Detectar tipos comunes de operaciones
        if (data.type) {
          switch (data.type) {
            case "put": return `üìù PUT ${data.id || data.key || ""}`;
            case "del": 
            case "remove": return `üóëÔ∏è DEL ${data.id || data.key || ""}`;
            case "link": return `üîó LINK ${data.sourceId || ""}‚Üí${data.targetId || ""}`;
            case "sync": return `üîÑ SYNC`;
            case "ack": return `‚úì ACK`;
            case "state": return `üìä STATE`;
            default: return `${data.type}`;
          }
        }
        
        // Para objetos gen√©ricos, mostrar resumen
        const keys = Object.keys(data);
        if (keys.length <= 3) {
          return keys.map(k => `${k}:${String(data[k]).slice(0, 10)}`).join(", ");
        }
        return `{${keys.length} keys}`;
      }
      
      return String(data).slice(0, 50);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // CONNECT & EVENTS (usando gdb con db.room) - MONITOR UNIVERSAL
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    async function connect() {
      try {
        // Inicializar GenosDB con RTC habilitado
        db = await gdb('mesh-cells-monitor', {
          rtc: {
            cells: {
              cellSize:'auto',
              bridgesPerEdge: 2,
              maxCellSize: 50,
              targetCells: 100,
              debug: false
            }
          }
        });

        // Obtener room y mesh desde db.room
        room = db.room;
        mesh = room.mesh;

        selfId = db.selfId;

        room.on("peer:join", id => {
          log(`<span style="color:var(--green)">+ ${shortId(id)}</span>`);
          render(true);
        });

        room.on("peer:leave", id => {
          remotePeerStates.delete(id);
          log(`<span style="color:var(--muted)">- ${shortId(id)}</span>`);
          render(true);
        });

        room.on("mesh:state", state => {
          selfState = {
            cellId: state.cellId,
            isBridge: state.isBridge === true,
            bridges: Array.isArray(state.bridges) ? state.bridges : [],
            dynamicTTL: state.dynamicTTL,
            cellSize: state.cellSize || 2
          };
          render(true);
        });

        room.on("mesh:peer-state", data => {
          if (data.id === selfId) return;

          remotePeerStates.set(data.id, {
            cellId: data.cell,
            isBridge: false,
            bridges: Array.isArray(data.bridges) ? data.bridges : []
          });
          render(false);
        });

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // MONITOR UNIVERSAL: Usar middleware para interceptar operaciones
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        // El middleware intercepta TODAS las operaciones entrantes antes de procesarlas
        db.use(async (ops, prevStates) => {
          // ops es un array de operaciones: [{type: "upsert", id, value, timestamp}, ...]
          for (const op of ops) {
            if (!op || !op.type) continue;
            
            // Formatear la operaci√≥n para mostrar
            const content = formatOpForDisplay(op);
            
            // No sabemos exactamente qui√©n envi√≥ (limitaci√≥n actual),
            // pero podemos mostrar la operaci√≥n
            log(
              `<span class="from">üîÑ SYNC:</span> ${content}`,
              { from: "remote", to: [selfState.cellId || "cell-0"] }
            );
            
            // Animar desde un peer aleatorio de otra celda (visual)
            animateRemoteSync(op);
          }
          
          // IMPORTANTE: retornar las ops sin modificar para que gdb las procese
          return ops;
        });
        
        log(`<span style="color:var(--cyan)">üì° Middleware instalado para interceptar sync</span>`);

        // 1. Mensajes directos del mesh (chat local)
        mesh.on("message", (msg, from) => {
          handleIncomingData(msg, from, "mesh");
        });

        // 2. Interceptar mensajes raw del room (cualquier canal/app)
        if (room.on) {
          room.on("data", (data, from) => {
            handleIncomingData(data, from, "data");
          });
        }

        $("msgInput").disabled = false;
        $("sendBtn").disabled = false;

        log(`<span style="color:var(--accent)">üîó Conectado via GenosDB (Monitor Universal)</span>`);

      } catch (error) {
        log(`<span style="color:var(--red)">‚ö†Ô∏è Error: ${error.message}</span>`);
        console.error("Error initializing:", error);
      }
    }
    
    // Formatear operaci√≥n de sync para mostrar
    function formatOpForDisplay(op) {
      if (!op || !op.type) return "?";
      
      switch (op.type) {
        case "upsert":
          const val = op.value;
          if (val && typeof val === "object") {
            if (val.text !== undefined) {
              return `üìù PUT "${val.text.slice(0, 20)}${val.text.length > 20 ? '‚Ä¶' : ''}"${val.completed ? ' ‚úì' : ''}`;
            }
            return `üìù PUT {${Object.keys(val).slice(0, 2).join(', ')}...}`;
          }
          return `üìù PUT ${String(val).slice(0, 20)}`;
          
        case "remove":
          return `üóëÔ∏è DEL ${shortId(op.id)}`;
          
        case "link":
          return `üîó LINK ${shortId(op.sourceId)}‚Üí${shortId(op.targetId)}`;
          
        case "sync":
          return `üîÑ SYNC REQUEST`;
          
        case "deltaSync":
          return `üì¶ DELTA SYNC`;
          
        case "fullStateSync":
          return `üì¶ FULL SYNC`;
          
        default:
          return `${op.type}`;
      }
    }
    
    // Animar operaci√≥n de sync remota (recorrido completo como animateFullMessage)
    function animateRemoteSync(op) {
      const allPeers = getAllPeers();
      const allCells = getAllCellIds();
      const myCell = selfState.cellId || "cell-0";
      
      // Buscar un peer remoto para usar como origen de la animaci√≥n
      let remotePeerId = null;
      let remoteCell = null;
      
      for (const [pid, st] of allPeers) {
        if (pid !== selfId && st.cellId) {
          remotePeerId = pid;
          remoteCell = st.cellId;
          break;
        }
      }
      
      if (!remotePeerId) {
        // No hay peers remotos, crear animaci√≥n desde el centro del grafo
        const centerX = width / 2;
        const centerY = height / 2;
        createPulse(centerX, centerY, COLORS.message);
        return;
      }
      
      const content = formatOpForDisplay(op);
      const fromPeerPos = nodePositions.get(`peer:${remotePeerId}`);
      
      if (!fromPeerPos) return;

      // Crear pulso inicial en el peer remoto
      createPulse(fromPeerPos.x, fromPeerPos.y, COLORS.message);
      flashNode(`peer:${remotePeerId}`, COLORS.message);

      // Animar hacia peers en la misma celda del remoto
      const sameCellPeers = getPeersInCell(remoteCell).filter(pid => pid !== remotePeerId);
      sameCellPeers.forEach((peerId, idx) => {
        setTimeout(() => {
          animatePeerToPeer(remotePeerId, peerId, remoteCell, content, idx === 0);
        }, idx * 150);
      });

      // Animar hacia todas las otras celdas (incluyendo la m√≠a)
      const otherCells = allCells.filter(cid => cid !== remoteCell);
      otherCells.forEach((toCellId, index) => {
        const fullPath = buildFullMessagePath(remotePeerId, remoteCell, toCellId);
        setTimeout(() => {
          animateAlongFullPath(fullPath, content, index === 0);
        }, (sameCellPeers.length * 150) + (index * 200));
      });
    }

    function sendMessage() {
      const input = $("msgInput");
      const text = input.value.trim();
      if (!text || !mesh) return;

      mesh.send(text);

      const myCell = selfState.cellId || "cell-0";
      const allCells = getAllCellIds();

      log(
        `<span class="self">You:</span> ${text}`,
        { from: myCell, to: allCells }
      );

      animateFullMessage(selfId, myCell, text);

      input.value = "";
    }

    function getAllCellIds() {
      const cells = new Set();
      const allPeers = getAllPeers();

      for (const [pid, st] of allPeers) {
        if (st.cellId) cells.add(st.cellId);
      }
      return [...cells].sort((a, b) => getCellIndex(a) - getCellIndex(b));
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // INIT
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    window.addEventListener("load", () => {
      $("sendBtn").addEventListener("click", sendMessage);
      $("msgInput").addEventListener("keydown", e => {
        if (e.key === "Enter") sendMessage();
      });

      window.addEventListener("resize", () => {
        width = graphEl.clientWidth;
        height = graphEl.clientHeight;
        svg.attr("viewBox", `0 0 ${width} ${height}`);
        simulation.force("center", d3.forceCenter(width / 2, height / 2));
        simulation.alpha(0.3).restart();
      });

      connect();
      render(true);
    });
  </script>
</body>

</html>
