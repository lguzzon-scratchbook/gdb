<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MESH MONITOR v1.0 [RETRO]</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

    :root {
      --bg: #0a0a0a;
      --green: #33ff33;
      --green-dim: #1a8c1a;
      --amber: #ffaa00;
      --cyan: #00ffff;
      --white: #cccccc;
      --red: #ff3333;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      height: 100%;
      background: var(--bg);
      font-family: 'VT323', 'Courier New', monospace;
      color: var(--green);
      font-size: 16px;
      line-height: 1.2;
    }

    /* CRT Scanline effect */
    body::before {
      content: "";
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      background: repeating-linear-gradient(
        0deg,
        rgba(0, 0, 0, 0.15),
        rgba(0, 0, 0, 0.15) 1px,
        transparent 1px,
        transparent 2px
      );
      z-index: 9999;
    }

    /* CRT glow effect */
    body::after {
      content: "";
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      box-shadow: inset 0 0 100px rgba(51, 255, 51, 0.1);
      z-index: 9998;
    }

    .container {
      display: flex;
      flex-direction: column;
      height: 100vh;
      padding: 8px;
    }

    /* Header */
    .header {
      border: 1px solid var(--green);
      padding: 4px 8px;
      margin-bottom: 8px;
      text-shadow: 0 0 10px var(--green);
    }

    .header-line {
      display: flex;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 8px;
    }

    .title {
      color: var(--cyan);
      text-shadow: 0 0 10px var(--cyan);
    }

    .status {
      color: var(--amber);
      text-shadow: 0 0 8px var(--amber);
    }

    .blink {
      animation: blink 1s infinite;
    }

    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0; }
    }

    /* Main area */
    .main {
      display: flex;
      flex: 1;
      gap: 8px;
      min-height: 0;
    }

    /* Graph area */
    .graph-panel {
      flex: 1;
      border: 1px solid var(--green);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .panel-title {
      background: var(--green);
      color: var(--bg);
      padding: 2px 8px;
      font-weight: bold;
    }

    #asciiGraph {
      flex: 1;
      padding: 8px;
      overflow: auto;
      white-space: pre;
      font-size: 14px;
      line-height: 1.1;
    }

    /* Sidebar */
    .sidebar {
      width: 280px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-height: 0;
      overflow-y: auto;
    }

    .sidebar::-webkit-scrollbar {
      width: 6px;
    }

    .sidebar::-webkit-scrollbar-track {
      background: var(--bg);
    }

    .sidebar::-webkit-scrollbar-thumb {
      background: var(--green-dim);
      border-radius: 3px;
    }

    .sidebar::-webkit-scrollbar-thumb:hover {
      background: var(--green);
    }

    .info-panel {
      border: 1px solid var(--green);
      flex-shrink: 0;
    }

    .metrics {
      padding: 8px;
    }

    .metric-row {
      display: flex;
      justify-content: space-between;
    }

    .metric-label {
      color: var(--green-dim);
    }

    .metric-value {
      color: var(--amber);
      text-shadow: 0 0 5px var(--amber);
    }

    .activity-panel {
      flex: 1;
      border: 1px solid var(--green);
      display: flex;
      flex-direction: column;
      min-height: 0;
      overflow: hidden;
    }

    .cell-content {
      flex: 1;
      padding: 8px;
      overflow-y: auto;
      font-size: 14px;
    }

    .cell-item {
      margin-bottom: 8px;
      color: var(--cyan);
    }

    .peer-line {
      color: var(--green);
      padding-left: 8px;
    }

    .peer-line.self {
      color: var(--amber);
    }

    .peer-line .bridge {
      color: var(--red);
    }

    /* Chat footer */
    .chat-panel {
      border: 1px solid var(--green);
      margin-top: 8px;
    }

    .chat-log {
      height: 60px;
      padding: 4px 8px;
      overflow-y: auto;
      font-size: 14px;
      border-bottom: 1px solid var(--green-dim);
    }

    .chat-entry {
      color: var(--green);
    }

    .chat-entry .from {
      color: var(--cyan);
    }

    .chat-entry .you {
      color: var(--amber);
    }

    .chat-input-row {
      display: flex;
      padding: 4px;
      gap: 8px;
    }

    .chat-input-row input {
      flex: 1;
      background: var(--bg);
      border: 1px solid var(--green-dim);
      color: var(--green);
      font-family: inherit;
      font-size: 16px;
      padding: 4px 8px;
      outline: none;
    }

    .chat-input-row input:focus {
      border-color: var(--green);
      box-shadow: 0 0 5px var(--green);
    }

    .chat-input-row button {
      background: var(--green);
      color: var(--bg);
      border: none;
      padding: 4px 16px;
      font-family: inherit;
      font-size: 16px;
      cursor: pointer;
    }

    .chat-input-row button:hover {
      background: var(--cyan);
    }

    .chat-input-row button:disabled {
      background: var(--green-dim);
      cursor: not-allowed;
    }

    /* ASCII Art colors */
    .c-green { color: var(--green); }
    .c-amber { color: var(--amber); }
    .c-cyan { color: var(--cyan); }
    .c-red { color: var(--red); }
    .c-dim { color: var(--green-dim); }
    .c-white { color: var(--white); }

    .glow-green { text-shadow: 0 0 10px var(--green); }
    .glow-amber { text-shadow: 0 0 10px var(--amber); }
    .glow-cyan { text-shadow: 0 0 10px var(--cyan); }

    @media (max-width: 700px) {
      .sidebar { display: none; }
    }
  </style>
</head>

<body>
  <div class="container">
    <!-- Header -->
    <div class="header">
      <div class="header-line">
        <span class="title">╔══ CELLULAR MESH MONITOR v1.0 ══╗</span>
        <span class="status">[<span id="connectionStatus" class="blink">CONNECTING...</span>]</span>
      </div>
      <div class="header-line" style="margin-top:4px">
        <span>CELL:<span id="cellId" class="c-amber">---</span></span>
        <span>SIZE:<span id="cellSize" class="c-amber">--</span></span>
        <span>ROLE:<span id="roleStatus" class="c-cyan">PEER</span></span>
        <span>ID:<span id="yourId" class="c-amber">---</span></span>
        <span>NODES:<span id="peerCount" class="c-amber">0</span></span>
      </div>
    </div>

    <!-- Main -->
    <div class="main">
      <!-- ASCII Graph -->
      <div class="graph-panel">
        <div class="panel-title">[ NETWORK TOPOLOGY ]</div>
        <div id="asciiGraph"></div>
      </div>

      <!-- Sidebar -->
      <div class="sidebar">
        <div class="info-panel">
          <div class="panel-title">[ METRICS ]</div>
          <div class="metrics">
            <div class="metric-row">
              <span class="metric-label">TOTAL PEERS.:</span>
              <span class="metric-value" id="metricPeers">0</span>
            </div>
            <div class="metric-row">
              <span class="metric-label">ACTIVE CELLS:</span>
              <span class="metric-value" id="metricCells">0</span>
            </div>
            <div class="metric-row">
              <span class="metric-label">BRIDGES.....:</span>
              <span class="metric-value" id="metricBridges">0</span>
            </div>
            <div class="metric-row">
              <span class="metric-label">CELL SIZE...:</span>
              <span class="metric-value" id="metricCellSize">--</span>
            </div>
          </div>
        </div>

        <div class="info-panel">
          <div class="panel-title">[ CONNECTION ]</div>
          <div class="metrics">
            <div class="metric-row">
              <span class="metric-label">STATUS......:</span>
              <span class="metric-value c-green" id="connStatus">OFFLINE</span>
            </div>
            <div class="metric-row">
              <span class="metric-label">UPTIME......:</span>
              <span class="metric-value" id="connUptime">00:00:00</span>
            </div>
            <div class="metric-row">
              <span class="metric-label">MSG SENT....:</span>
              <span class="metric-value" id="connMsgSent">0</span>
            </div>
            <div class="metric-row">
              <span class="metric-label">MSG RECV....:</span>
              <span class="metric-value" id="connMsgRecv">0</span>
            </div>
            <div class="metric-row">
              <span class="metric-label">BYTES OUT...:</span>
              <span class="metric-value" id="connBytesOut">0 B</span>
            </div>
            <div class="metric-row">
              <span class="metric-label">BYTES IN....:</span>
              <span class="metric-value" id="connBytesIn">0 B</span>
            </div>
          </div>
        </div>

        <div class="info-panel">
          <div class="panel-title">[ NETWORK ]</div>
          <div class="metrics">
            <div class="metric-row">
              <span class="metric-label">RELAY.......:</span>
              <span class="metric-value c-dim" id="netRelay">---</span>
            </div>
            <div class="metric-row">
              <span class="metric-label">ROOM........:</span>
              <span class="metric-value" id="netRoom">---</span>
            </div>
            <div class="metric-row">
              <span class="metric-label">NEIGHBORS...:</span>
              <span class="metric-value" id="netNeighbors">---</span>
            </div>
            <div class="metric-row">
              <span class="metric-label">BRIDGES/EDGE:</span>
              <span class="metric-value" id="netBridges">0</span>
            </div>
          </div>
        </div>

        <div class="info-panel">
          <div class="panel-title">[ SYSTEM ]</div>
          <div class="metrics">
            <div class="metric-row">
              <span class="metric-label">MEMORY......:</span>
              <span class="metric-value" id="sysMemory">--- KB</span>
            </div>
            <div class="metric-row">
              <span class="metric-label">CPU CYCLES..:</span>
              <span class="metric-value" id="sysCycles">0</span>
            </div>
            <div class="metric-row">
              <span class="metric-label">RENDER FPS..:</span>
              <span class="metric-value c-cyan" id="sysFps">--</span>
            </div>
            <div class="metric-row">
              <span class="metric-label">LAST UPDATE.:</span>
              <span class="metric-value" id="sysLastUpdate">--:--:--</span>
            </div>
            <div class="metric-row">
              <span class="metric-label">BROWSER.....:</span>
              <span class="metric-value c-dim" id="sysBrowser">---</span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Chat -->
    <div class="chat-panel">
      <div class="panel-title">[ MESSAGE LOG ]</div>
      <div class="chat-log" id="log"></div>
      <div class="chat-input-row">
        <span class="c-green">&gt;</span>
        <input type="text" id="msgInput" placeholder="ENTER MESSAGE..." disabled />
        <button id="sendBtn" disabled>SEND</button>
      </div>
    </div>
  </div>

  <script type="module">
    import { gdb } from "../dist/index.js";

    let selfId = null;

    // ════════════════════════════════════════════════════════════════
    // ASCII ART CHARACTERS
    // ════════════════════════════════════════════════════════════════
    const CHARS = {
      cell: '◉',
      peer: '○',
      bridge: '◈',
      self: '★',
      hLine: '─',
      vLine: '│',
      cross: '┼',
      tRight: '├',
      tLeft: '┤',
      corner: '└',
      arrow: '→',
      pulse: '●',
      dot: '·'
    };

    // ════════════════════════════════════════════════════════════════
    // STATE
    // ════════════════════════════════════════════════════════════════
    const $ = id => document.getElementById(id);
    const shortId = id => id?.length > 10 ? `${id.slice(0, 4)}..${id.slice(-4)}` : id;

    let db = null, room = null, mesh = null;

    const CELLS_CONFIG = {
      cellSize: 'auto',
      bridgesPerEdge: 2,
      maxCellSize: 50,
      targetCells: 100
    };

    let selfState = {
      cellId: null,
      isBridge: false,
      bridges: [],
      cellSize: CELLS_CONFIG.cellSize,
      bridgesPerEdge: CELLS_CONFIG.bridgesPerEdge
    };

    const remotePeerStates = new Map();

    // Animation state
    const animations = [];
    let animationRunning = false;

    // Connection stats
    let connectedAt = null;
    let stats = {
      msgSent: 0,
      msgRecv: 0,
      bytesOut: 0,
      bytesIn: 0
    };

    // System stats
    let cpuCycles = 0;
    let lastFrameTime = performance.now();
    let frameCount = 0;
    let currentFps = 0;

    // Detect browser
    function detectBrowser() {
      const ua = navigator.userAgent;
      if (ua.includes('Firefox')) return 'Firefox';
      if (ua.includes('Edg')) return 'Edge';
      if (ua.includes('Chrome')) return 'Chrome';
      if (ua.includes('Safari')) return 'Safari';
      if (ua.includes('Opera') || ua.includes('OPR')) return 'Opera';
      return 'Unknown';
    }

    // ════════════════════════════════════════════════════════════════
    // HELPERS
    // ════════════════════════════════════════════════════════════════
    const getCellIndex = cid => {
      const m = String(cid || "").match(/cell-(\d+)/);
      return m ? Number(m[1]) : NaN;
    };

    const neighborCells = cid => {
      const i = getCellIndex(cid);
      if (Number.isNaN(i)) return [];
      const arr = [];
      if (i > 0) arr.push(`cell-${i - 1}`);
      arr.push(`cell-${i + 1}`);
      return arr;
    };

    function getAllPeers() {
      const all = new Map();
      for (const [pid, state] of remotePeerStates) {
        all.set(pid, { ...state });
      }
      if (selfId) {
        all.set(selfId, {
          cellId: selfState.cellId,
          isBridge: selfState.isBridge,
          bridges: selfState.bridges || []
        });
      }
      return all;
    }

    function getBridgesPerEdge() {
      return selfState.bridgesPerEdge ?? CELLS_CONFIG.bridgesPerEdge;
    }

    function getCellSize() {
      return selfState.cellSize || CELLS_CONFIG.cellSize;
    }

    // ════════════════════════════════════════════════════════════════
    // BRIDGE DETECTION
    // ════════════════════════════════════════════════════════════════
    let cachedBridgeMap = new Map();
    let cacheValid = false;

    function invalidateCache() {
      cacheValid = false;
    }

    function computeAllBridges() {
      if (cacheValid) return cachedBridgeMap;
      
      cachedBridgeMap.clear();
      const allPeers = getAllPeers();
      const allPeerIds = [...allPeers.keys()];
      
      for (const [pid, st] of allPeers) {
        const isBridge = isPeerBridge(pid, st.cellId, allPeerIds);
        cachedBridgeMap.set(pid, isBridge);
      }
      
      cacheValid = true;
      return cachedBridgeMap;
    }

    function isCachedBridge(peerId) {
      const map = computeAllBridges();
      return map.get(peerId) || false;
    }

    function computeBridgesForCell(cellId, allPeerIds) {
      const bridgesPerEdge = getBridgesPerEdge();
      const bridges = new Set();
      
      if (bridgesPerEdge === 0) return bridges;
      
      const cellIdx = getCellIndex(cellId);
      if (Number.isNaN(cellIdx)) return bridges;

      const cellSize = getCellSize();
      const sorted = [...allPeerIds].sort();
      const neighbors = neighborCells(cellId);

      for (const neighborCell of neighbors) {
        const neighborIdx = getCellIndex(neighborCell);
        if (Number.isNaN(neighborIdx)) continue;

        const minIdx = Math.min(cellIdx, neighborIdx);
        const maxIdx = Math.max(cellIdx, neighborIdx);
        const start = minIdx * cellSize;
        const end = (maxIdx + 1) * cellSize;
        const edgeGroup = sorted.slice(start, end);

        if (edgeGroup.length === 0) continue;

        const bridgePeers = edgeGroup.slice(0, bridgesPerEdge);
        for (const pid of bridgePeers) {
          bridges.add(pid);
        }
      }

      return bridges;
    }

    function isPeerBridge(peerId, cellId, allPeerIds) {
      if (!cellId) return false;
      const bridges = computeBridgesForCell(cellId, allPeerIds);
      return bridges.has(peerId);
    }

    // ════════════════════════════════════════════════════════════════
    // ASCII GRAPH RENDERING
    // ════════════════════════════════════════════════════════════════
    function renderASCIIGraph() {
      const allPeers = getAllPeers();
      const cells = new Map();
      
      for (const [pid, st] of allPeers) {
        const cellId = st.cellId || "cell-0";
        if (!cells.has(cellId)) cells.set(cellId, []);
        cells.get(cellId).push({ id: pid, ...st });
      }

      const sortedCells = [...cells.keys()].sort((a, b) => getCellIndex(a) - getCellIndex(b));
      
      if (sortedCells.length === 0) {
        $("asciiGraph").innerHTML = '<span class="c-dim">NO NODES DETECTED...</span>';
        return;
      }

      let output = '';
      
      // Header line
      output += '<span class="c-dim">╔';
      for (let i = 0; i < sortedCells.length; i++) {
        output += '════════════════';
        if (i < sortedCells.length - 1) output += '╦';
      }
      output += '╗</span>\n';

      // Cell headers
      output += '<span class="c-dim">║</span>';
      for (let i = 0; i < sortedCells.length; i++) {
        const cellId = sortedCells[i];
        const label = `   ${CHARS.cell} ${cellId.replace('cell-', 'CELL-')}   `;
        output += `<span class="c-cyan glow-cyan">${label.padEnd(16)}</span>`;
        if (i < sortedCells.length - 1) {
          output += '<span class="c-dim">║</span>';
        }
      }
      output += '<span class="c-dim">║</span>\n';

      // Separator
      output += '<span class="c-dim">╠';
      for (let i = 0; i < sortedCells.length; i++) {
        output += '════════════════';
        if (i < sortedCells.length - 1) output += '╬';
      }
      output += '╣</span>\n';

      // Find max peers in any cell
      let maxPeers = 0;
      for (const cellId of sortedCells) {
        maxPeers = Math.max(maxPeers, cells.get(cellId).length);
      }

      // Peer rows
      for (let row = 0; row < maxPeers; row++) {
        output += '<span class="c-dim">║</span>';
        
        for (let i = 0; i < sortedCells.length; i++) {
          const cellId = sortedCells[i];
          const peers = cells.get(cellId) || [];
          
          if (row < peers.length) {
            const peer = peers[row];
            const isSelf = peer.id === selfId;
            const isBridge = isSelf ? selfState.isBridge : isCachedBridge(peer.id);
            
            let icon, colorClass;
            if (isSelf) {
              icon = CHARS.self;
              colorClass = 'c-amber glow-amber';
            } else if (isBridge) {
              icon = CHARS.bridge;
              colorClass = 'c-red';
            } else {
              icon = CHARS.peer;
              colorClass = 'c-green';
            }
            
            const id = shortId(peer.id);
            const label = ` ${icon} ${id}`;
            output += `<span class="${colorClass}">${label.padEnd(16)}</span>`;
          } else {
            output += '<span class="c-dim">                </span>';
          }
          
          if (i < sortedCells.length - 1) {
            // Connection between cells
            if (getBridgesPerEdge() > 0 && row === 0) {
              output += '<span class="c-green">◄──►</span>';
            } else {
              output += '<span class="c-dim">│</span>';
            }
          }
        }
        output += '<span class="c-dim">║</span>\n';
      }

      // Footer
      output += '<span class="c-dim">╚';
      for (let i = 0; i < sortedCells.length; i++) {
        output += '════════════════';
        if (i < sortedCells.length - 1) output += '╩';
      }
      output += '╝</span>\n';

      // Legend
      output += '\n<span class="c-dim">LEGEND: </span>';
      output += `<span class="c-amber">${CHARS.self} YOU</span>  `;
      output += `<span class="c-green">${CHARS.peer} PEER</span>  `;
      output += `<span class="c-red">${CHARS.bridge} BRIDGE</span>  `;
      output += `<span class="c-cyan">${CHARS.cell} CELL</span>`;

      // Animation overlay
      for (const anim of animations) {
        // We'll handle animation separately
      }

      $("asciiGraph").innerHTML = output;
    }

    // ════════════════════════════════════════════════════════════════
    // ANIMATION SYSTEM
    // ════════════════════════════════════════════════════════════════
    function animateMessage(fromId, isSent = false) {
      const allPeers = getAllPeers();
      const fromState = allPeers.get(fromId);
      const fromCellId = fromState?.cellId || selfState.cellId || "cell-0";
      
      // Create animation frames in the log
      const frames = ['◐', '◓', '◑', '◒'];
      let frameIdx = 0;
      
      const animEl = document.createElement('span');
      animEl.className = isSent ? 'c-amber' : 'c-cyan';
      animEl.textContent = ` ${frames[0]} TRANSMITTING...`;
      
      const logEl = $("log");
      logEl.appendChild(animEl);
      logEl.scrollTop = logEl.scrollHeight;
      
      const interval = setInterval(() => {
        frameIdx = (frameIdx + 1) % frames.length;
        animEl.textContent = ` ${frames[frameIdx]} TRANSMITTING...`;
      }, 100);
      
      setTimeout(() => {
        clearInterval(interval);
        animEl.textContent = ' ✓ DELIVERED';
        setTimeout(() => animEl.remove(), 1000);
      }, 800);
    }

    // ════════════════════════════════════════════════════════════════
    // UI UPDATES
    // ════════════════════════════════════════════════════════════════
    function updateUI() {
      $("cellId").textContent = selfState.cellId || "---";
      $("cellSize").textContent = selfState.cellSize || "--";
      $("peerCount").textContent = remotePeerStates.size + 1;
      $("roleStatus").textContent = selfState.isBridge ? "BRIDGE" : "PEER";
      $("roleStatus").className = selfState.isBridge ? "c-red" : "c-cyan";

      const allPeers = getAllPeers();
      const cells = new Set();
      let bridges = 0;

      const bridgeMap = computeAllBridges();
      
      for (const [pid, st] of allPeers) {
        if (st.cellId) cells.add(st.cellId);
        if (bridgeMap.get(pid)) bridges++;
      }

      $("metricPeers").textContent = allPeers.size;
      $("metricCells").textContent = cells.size;
      $("metricBridges").textContent = bridges;
      $("metricCellSize").textContent = selfState.cellSize || "--";

      // Update Network panel info
      updateNetworkInfo();

      updateConnectionStats();
      renderASCIIGraph();
    }

    // ════════════════════════════════════════════════════════════════
    // NETWORK INFO
    // ════════════════════════════════════════════════════════════════
    function updateNetworkInfo() {
      // Get neighbors
      const neighbors = neighborCells(selfState.cellId);
      if (neighbors.length > 0) {
        $("netNeighbors").textContent = neighbors.map(c => c.replace("cell-", "C-")).join(", ");
      } else {
        $("netNeighbors").textContent = "---";
      }
      
      // Bridges per edge
      $("netBridges").textContent = getBridgesPerEdge();
    }

    // ════════════════════════════════════════════════════════════════
    // CONNECTION STATS
    // ════════════════════════════════════════════════════════════════
    function formatBytes(bytes) {
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
      return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
    }

    function formatUptime(ms) {
      const secs = Math.floor(ms / 1000);
      const hrs = Math.floor(secs / 3600);
      const mins = Math.floor((secs % 3600) / 60);
      const s = secs % 60;
      return `${hrs.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
    }

    function updateConnectionStats() {
      if (connectedAt) {
        $("connUptime").textContent = formatUptime(Date.now() - connectedAt);
      }
      $("connMsgSent").textContent = stats.msgSent;
      $("connMsgRecv").textContent = stats.msgRecv;
      $("connBytesOut").textContent = formatBytes(stats.bytesOut);
      $("connBytesIn").textContent = formatBytes(stats.bytesIn);
    }

    // ════════════════════════════════════════════════════════════════
    // SYSTEM STATS
    // ════════════════════════════════════════════════════════════════
    function updateSystemStats() {
      // Memory (if available)
      if (performance.memory) {
        const memKB = (performance.memory.usedJSHeapSize / 1024).toFixed(1);
        $("sysMemory").textContent = memKB + " KB";
      } else {
        $("sysMemory").textContent = "N/A";
      }

      // CPU cycles (increment on each update call)
      cpuCycles++;
      $("sysCycles").textContent = cpuCycles.toLocaleString();

      // FPS calculation
      $("sysFps").textContent = currentFps;

      // Last update time
      const now = new Date();
      $("sysLastUpdate").textContent = now.toLocaleTimeString('en-US', { hour12: false });

      // Browser (only needs to be set once, but ok to update)
      $("sysBrowser").textContent = detectBrowser();
    }

    // FPS tracking
    function trackFps() {
      frameCount++;
      const now = performance.now();
      if (now - lastFrameTime >= 1000) {
        currentFps = frameCount;
        frameCount = 0;
        lastFrameTime = now;
      }
      requestAnimationFrame(trackFps);
    }
    requestAnimationFrame(trackFps);

    // Update stats every second
    setInterval(() => {
      updateConnectionStats();
      updateSystemStats();
    }, 1000);

    // Initialize browser on load
    $("sysBrowser").textContent = detectBrowser();

    function log(msg, type = 'info') {
      const el = $("log");
      const entry = document.createElement("div");
      entry.className = "chat-entry";
      
      const time = new Date().toLocaleTimeString('en-US', { hour12: false });
      entry.innerHTML = `<span class="c-dim">[${time}]</span> ${msg}`;
      
      el.appendChild(entry);
      el.scrollTop = el.scrollHeight;

      while (el.children.length > 50) {
        el.removeChild(el.firstChild);
      }
    }

    // ════════════════════════════════════════════════════════════════
    // THROTTLED UPDATE
    // ════════════════════════════════════════════════════════════════
    let updatePending = false;
    let lastUpdateTime = 0;
    const UPDATE_THROTTLE = 300;

    function scheduleUpdate() {
      if (updatePending) return;
      
      const now = Date.now();
      const elapsed = now - lastUpdateTime;
      
      if (elapsed >= UPDATE_THROTTLE) {
        updatePending = true;
        requestAnimationFrame(doUpdate);
      } else {
        updatePending = true;
        setTimeout(() => {
          requestAnimationFrame(doUpdate);
        }, UPDATE_THROTTLE - elapsed);
      }
    }

    function doUpdate() {
      updateUI();
      lastUpdateTime = Date.now();
      updatePending = false;
    }

    // ════════════════════════════════════════════════════════════════
    // CONNECT & EVENTS
    // ════════════════════════════════════════════════════════════════
    const relayUrls = [
      "wss://relay.orangepill.ovh"
    ];

    async function connect() {
      try {
        log('INITIALIZING MESH NETWORK...');
        
        db = await gdb('mesh-cells-monitor', {
          rtc: {
            relayUrls,
            cells: {
              ...CELLS_CONFIG,
              debug: false
            }
          }
        });

        room = db.room;
        mesh = room.mesh;
        selfId = db.selfId;

        $("connectionStatus").textContent = "ONLINE";
        $("connectionStatus").className = "c-green";
        $("connStatus").textContent = "ONLINE";
        $("connStatus").className = "metric-value c-green";
        connectedAt = Date.now();

        room.on("peer:join", id => {
          log(`<span class="c-green">+ NODE JOINED: ${shortId(id)}</span>`);
          invalidateCache();
          scheduleUpdate();
        });

        room.on("peer:leave", id => {
          remotePeerStates.delete(id);
          log(`<span class="c-dim">- NODE LEFT: ${shortId(id)}</span>`);
          invalidateCache();
          scheduleUpdate();
        });

        room.on("mesh:state", state => {
          selfState = {
            cellId: state.cellId,
            isBridge: state.isBridge === true,
            bridges: Array.isArray(state.bridges) ? state.bridges : [],
            cellSize: state.cellSize || CELLS_CONFIG.cellSize,
            bridgesPerEdge: state.bridgesPerEdge ?? CELLS_CONFIG.bridgesPerEdge
          };
          invalidateCache();
          scheduleUpdate();
        });

        room.on("mesh:peer-state", data => {
          if (data.id === selfId) return;
          remotePeerStates.set(data.id, {
            cellId: data.cell,
            isBridge: data.isBridge === true,
            bridges: Array.isArray(data.bridges) ? data.bridges : []
          });
          invalidateCache();
          scheduleUpdate();
        });

        mesh.on("message", (msg, from) => {
          if (from === selfId) return;
          const content = typeof msg === "string" ? msg : JSON.stringify(msg).slice(0, 30);
          const msgSize = typeof msg === "string" ? msg.length : JSON.stringify(msg).length;
          
          stats.msgRecv++;
          stats.bytesIn += msgSize;
          
          log(`<span class="from">${shortId(from)}:</span> ${content}`);
          animateMessage(from, false);
        });

        $("msgInput").disabled = false;
        $("sendBtn").disabled = false;

        // Update Network panel and header
        $("netRelay").textContent = "orangepill.ovh";
        $("netRoom").textContent = "mesh-cells-monitor";
        $("yourId").textContent = shortId(selfId);

        log('<span class="c-green">══ MESH NETWORK CONNECTED ══</span>');

      } catch (error) {
        $("connectionStatus").textContent = "ERROR";
        $("connectionStatus").className = "c-red";
        log(`<span class="c-red">ERROR: ${error.message}</span>`);
        console.error("Error initializing:", error);
      }
    }

    function sendMessage() {
      const input = $("msgInput");
      const text = input.value.trim();
      if (!text || !mesh) return;

      mesh.send(text);
      
      stats.msgSent++;
      stats.bytesOut += text.length;
      
      log(`<span class="you">YOU:</span> ${text}`);
      animateMessage(selfId, true);
      input.value = "";
    }

    // ════════════════════════════════════════════════════════════════
    // INIT
    // ════════════════════════════════════════════════════════════════
    window.addEventListener("load", () => {
      $("sendBtn").addEventListener("click", sendMessage);
      $("msgInput").addEventListener("keydown", e => {
        if (e.key === "Enter") sendMessage();
      });

      // Boot sequence
      log('<span class="c-cyan">╔════════════════════════════════════╗</span>');
      log('<span class="c-cyan">║  CELLULAR MESH MONITOR v1.0       ║</span>');
      log('<span class="c-cyan">║  (C) 2025 GENOSDB SYSTEMS         ║</span>');
      log('<span class="c-cyan">╚════════════════════════════════════╝</span>');
      log('');
      log('SYSTEM BOOT SEQUENCE INITIATED...');
      
      setTimeout(() => {
        log('LOADING NETWORK DRIVERS... <span class="c-green">OK</span>');
      }, 200);
      
      setTimeout(() => {
        log('INITIALIZING P2P SUBSYSTEM... <span class="c-green">OK</span>');
      }, 400);
      
      setTimeout(() => {
        log('CONNECTING TO RELAY SERVERS...');
        connect();
      }, 600);

      scheduleUpdate();
    });
  </script>
</body>

</html>
