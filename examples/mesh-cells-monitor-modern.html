<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mesh Monitor - Modern</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap');

    :root {
      --bg: #0f0f0f;
      --bg-card: #1a1a1a;
      --bg-hover: #242424;
      --border: #2a2a2a;
      --text: #e5e5e5;
      --text-dim: #737373;
      --accent: #3b82f6;
      --accent-dim: #1d4ed8;
      --success: #22c55e;
      --warning: #f59e0b;
      --error: #ef4444;
      --purple: #a855f7;
      --radius: 12px;
      --radius-sm: 8px;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      height: 100%;
      background: var(--bg);
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      color: var(--text);
      font-size: 14px;
      line-height: 1.5;
      -webkit-font-smoothing: antialiased;
    }

    .container {
      display: flex;
      flex-direction: column;
      height: 100vh;
      padding: 12px;
      gap: 12px;
    }

    /* Header */
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 16px;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      flex-shrink: 0;
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 16px;
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .logo-icon {
      width: 32px;
      height: 32px;
      background: linear-gradient(135deg, var(--accent), var(--purple));
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
    }

    .logo-text {
      font-weight: 600;
      font-size: 16px;
      letter-spacing: -0.02em;
    }

    .status-badge {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      background: rgba(34, 197, 94, 0.1);
      border: 1px solid rgba(34, 197, 94, 0.2);
      border-radius: 20px;
      font-size: 12px;
      font-weight: 500;
      color: var(--success);
    }

    .status-badge.offline {
      background: rgba(239, 68, 68, 0.1);
      border-color: rgba(239, 68, 68, 0.2);
      color: var(--error);
    }

    .status-badge.connecting {
      background: rgba(245, 158, 11, 0.1);
      border-color: rgba(245, 158, 11, 0.2);
      color: var(--warning);
    }

    .status-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: currentColor;
    }

    .status-badge.connecting .status-dot {
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }

    .header-stats {
      display: flex;
      gap: 24px;
    }

    .header-stat {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
    }

    .header-stat-label {
      font-size: 11px;
      color: var(--text-dim);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .header-stat-value {
      font-size: 14px;
      font-weight: 500;
      color: var(--text);
    }

    /* Main area */
    .main {
      display: flex;
      flex: 1;
      gap: 12px;
      min-height: 0;
      overflow: hidden;
    }

    /* Graph Panel */
    .graph-panel {
      flex: 1;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      border-bottom: 1px solid var(--border);
    }

    .panel-title {
      font-weight: 500;
      font-size: 13px;
      color: var(--text-dim);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    #graphContainer {
      flex: 1;
      position: relative;
      overflow: hidden;
    }

    #canvas {
      width: 100%;
      height: 100%;
    }

    .graph-legend {
      position: absolute;
      bottom: 12px;
      left: 12px;
      display: flex;
      gap: 16px;
      font-size: 11px;
      color: var(--text-dim);
      background: rgba(15, 15, 15, 0.8);
      padding: 6px 12px;
      border-radius: 6px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .legend-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }

    .legend-dot.you { background: #a855f7; }
    .legend-dot.peer { background: #22c55e; }
    .legend-dot.bridge { background: #f59e0b; }
    .legend-dot.cell { background: #3b82f6; }

    /* Sidebar */
    .sidebar {
      width: 280px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-height: 0;
      overflow-y: auto;
      flex-shrink: 0;
    }

    .sidebar::-webkit-scrollbar {
      width: 4px;
    }

    .sidebar::-webkit-scrollbar-track {
      background: transparent;
    }

    .sidebar::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 2px;
    }

    .card {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      overflow: hidden;
    }

    .card-header {
      padding: 8px 12px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .card-icon {
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      opacity: 0.7;
    }

    .card-title {
      font-weight: 500;
      font-size: 12px;
      color: var(--text-dim);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .card-body {
      padding: 10px 14px;
    }

    .metric-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px 20px;
    }

    .metric-item {
      display: flex;
      flex-direction: column;
      gap: 2px;
      min-width: 0;
    }

    .metric-item.full {
      grid-column: 1 / -1;
    }

    .metric-label {
      font-size: 10px;
      color: var(--text-dim);
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }

    .metric-value {
      font-size: 15px;
      font-weight: 600;
      color: var(--text);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .metric-value.accent {
      color: var(--accent);
    }

    .metric-value.success {
      color: var(--success);
    }

    .metric-value.warning {
      color: var(--warning);
    }

    .metric-value.small {
      font-size: 13px;
      font-weight: 500;
    }

    /* Chat Panel */
    .chat-panel {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      display: flex;
      flex-direction: column;
    }

    .chat-log {
      height: 60px;
      padding: 8px 12px;
      overflow-y: auto;
      font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
      font-size: 11px;
      border-bottom: 1px solid var(--border);
    }

    .chat-entry {
      padding: 2px 0;
      color: var(--text-dim);
    }

    .chat-entry .time {
      color: var(--text-dim);
      opacity: 0.6;
    }

    .chat-entry .from {
      color: var(--accent);
    }

    .chat-entry .you {
      color: var(--purple);
    }

    .chat-entry .success {
      color: var(--success);
    }

    .chat-entry .error {
      color: var(--error);
    }

    .chat-input-row {
      display: flex;
      padding: 8px 12px;
      gap: 8px;
    }

    .chat-input-row input {
      flex: 1;
      background: var(--bg);
      border: 1px solid var(--border);
      color: var(--text);
      font-family: inherit;
      font-size: 12px;
      padding: 8px 12px;
      border-radius: var(--radius-sm);
      outline: none;
      transition: border-color 0.2s, box-shadow 0.2s;
    }

    .chat-input-row input::placeholder {
      color: var(--text-dim);
    }

    .chat-input-row input:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }

    .chat-input-row button {
      background: var(--accent);
      color: white;
      border: none;
      padding: 8px 16px;
      font-family: inherit;
      font-size: 12px;
      font-weight: 500;
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: background 0.2s;
    }

    .chat-input-row button:hover {
      background: var(--accent-dim);
    }

    .chat-input-row button:disabled {
      background: var(--border);
      color: var(--text-dim);
      cursor: not-allowed;
    }

    /* Graph colors */
    .c-accent { color: var(--accent); }
    .c-purple { color: var(--purple); }
    .c-success { color: var(--success); }
    .c-warning { color: var(--warning); }
    .c-error { color: var(--error); }
    .c-dim { color: var(--text-dim); }
    .c-text { color: var(--text); }

    /* Legend */
    .legend {
      display: flex;
      gap: 16px;
      padding: 8px 0;
      border-top: 1px solid var(--border);
      margin-top: 8px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      color: var(--text-dim);
    }

    .legend-icon {
      font-size: 14px;
    }

    @media (max-width: 768px) {
      .sidebar { display: none; }
      .header-stats { display: none; }
    }
  </style>
</head>

<body>
  <div class="container">
    <!-- Header -->
    <div class="header">
      <div class="header-left">
        <div class="logo">
          <div class="logo-icon">â—‰</div>
          <span class="logo-text">Mesh Monitor</span>
        </div>
        <div class="status-badge connecting" id="statusBadge">
          <span class="status-dot"></span>
          <span id="connectionStatus">Connecting</span>
        </div>
      </div>
      <div class="header-stats">
        <div class="header-stat">
          <span class="header-stat-label">Cell</span>
          <span class="header-stat-value" id="cellId">---</span>
        </div>
        <div class="header-stat">
          <span class="header-stat-label">Size</span>
          <span class="header-stat-value" id="cellSize">--</span>
        </div>
        <div class="header-stat">
          <span class="header-stat-label">Role</span>
          <span class="header-stat-value" id="roleStatus">Peer</span>
        </div>
        <div class="header-stat">
          <span class="header-stat-label">Your ID</span>
          <span class="header-stat-value" id="yourId">---</span>
        </div>
        <div class="header-stat">
          <span class="header-stat-label">Nodes</span>
          <span class="header-stat-value" id="peerCount">0</span>
        </div>
      </div>
    </div>

    <!-- Main -->
    <div class="main">
      <!-- Graph -->
      <div class="graph-panel">
        <div class="panel-header">
          <span class="panel-title">Network Topology</span>
        </div>
        <div id="graphContainer">
          <canvas id="canvas"></canvas>
          <div class="graph-legend">
            <span class="legend-item"><span class="legend-dot you"></span> You</span>
            <span class="legend-item"><span class="legend-dot peer"></span> Peer</span>
            <span class="legend-item"><span class="legend-dot bridge"></span> Bridge</span>
            <span class="legend-item"><span class="legend-dot cell"></span> Cell</span>
          </div>
        </div>
      </div>

      <!-- Sidebar -->
      <div class="sidebar">
        <div class="card">
          <div class="card-header">
            <span class="card-icon">ğŸ“Š</span>
            <span class="card-title">Metrics</span>
          </div>
          <div class="card-body">
            <div class="metric-grid">
              <div class="metric-item">
                <span class="metric-label">Peers</span>
                <span class="metric-value" id="metricPeers">0</span>
              </div>
              <div class="metric-item">
                <span class="metric-label">Cells</span>
                <span class="metric-value" id="metricCells">0</span>
              </div>
              <div class="metric-item">
                <span class="metric-label">Bridges</span>
                <span class="metric-value" id="metricBridges">0</span>
              </div>
              <div class="metric-item">
                <span class="metric-label">Cell Size</span>
                <span class="metric-value" id="metricCellSize">--</span>
              </div>
            </div>
          </div>
        </div>

        <div class="card">
          <div class="card-header">
            <span class="card-icon">ğŸ”—</span>
            <span class="card-title">Connection</span>
          </div>
          <div class="card-body">
            <div class="metric-grid">
              <div class="metric-item">
                <span class="metric-label">Status</span>
                <span class="metric-value success" id="connStatus">Offline</span>
              </div>
              <div class="metric-item">
                <span class="metric-label">Uptime</span>
                <span class="metric-value" id="connUptime">00:00:00</span>
              </div>
              <div class="metric-item">
                <span class="metric-label">â†‘ Out</span>
                <span class="metric-value small" id="connBytesOut">0 B</span>
              </div>
              <div class="metric-item">
                <span class="metric-label">â†“ In</span>
                <span class="metric-value small" id="connBytesIn">0 B</span>
              </div>
            </div>
          </div>
        </div>

        <div class="card">
          <div class="card-header">
            <span class="card-icon">ğŸŒ</span>
            <span class="card-title">Network</span>
          </div>
          <div class="card-body">
            <div class="metric-grid">
              <div class="metric-item full">
                <span class="metric-label">Relay</span>
                <span class="metric-value small" id="netRelay">---</span>
              </div>
              <div class="metric-item full">
                <span class="metric-label">Room</span>
                <span class="metric-value small" id="netRoom">---</span>
              </div>
            </div>
          </div>
        </div>

        <div class="card">
          <div class="card-header">
            <span class="card-icon">âš™ï¸</span>
            <span class="card-title">System</span>
          </div>
          <div class="card-body">
            <div class="metric-grid">
              <div class="metric-item">
                <span class="metric-label">Memory</span>
                <span class="metric-value small" id="sysMemory">--</span>
              </div>
              <div class="metric-item">
                <span class="metric-label">FPS</span>
                <span class="metric-value accent" id="sysFps">--</span>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Chat -->
    <div class="chat-panel">
      <div class="panel-header">
        <span class="panel-title">Message Log</span>
      </div>
      <div class="chat-log" id="log"></div>
      <div class="chat-input-row">
        <input type="text" id="msgInput" placeholder="Type a message..." disabled />
        <button id="sendBtn" disabled>Send</button>
      </div>
    </div>
  </div>

  <script type="module">
    import { gdb } from "../dist/index.js";

    let selfId = null;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // COLORS (Modern palette)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const COLORS = {
      cell: "#3b82f6",
      bridge: "#f59e0b",
      peer: "#22c55e",
      self: "#a855f7",
      link: "#2a2a2a",
      bridgeLink: "#f59e0b",
      pulse: "#3b82f6",
      message: "#06b6d4"
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ANIMATION SYSTEM - Particles and pulses
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const particles = [];
    const pulses = [];
    const nodePositions = new Map();
    const cellPositions = new Map();
    let animationRunning = false;

    function createPulse(x, y, color = COLORS.message) {
      pulses.push({ x, y, radius: 8, alpha: 1, color });
      startAnimation();
    }

    function createParticle(path, color = COLORS.message, onComplete = null) {
      if (!path || path.length < 2) return;
      particles.push({
        path,
        currentSegment: 0,
        progress: 0,
        color,
        onComplete
      });
      startAnimation();
    }

    function updateAnimations() {
      for (let i = pulses.length - 1; i >= 0; i--) {
        const p = pulses[i];
        p.radius += 2;
        p.alpha -= 0.05;
        if (p.alpha <= 0) pulses.splice(i, 1);
      }

      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.progress += 0.08;

        if (p.progress >= 1) {
          p.progress = 0;
          p.currentSegment++;

          if (p.currentSegment < p.path.length) {
            const node = p.path[p.currentSegment];
            createPulse(node.x, node.y, p.color);
          }

          if (p.currentSegment >= p.path.length - 1) {
            const lastNode = p.path[p.path.length - 1];
            createPulse(lastNode.x, lastNode.y, COLORS.cell);
            if (p.onComplete) p.onComplete();
            particles.splice(i, 1);
          }
        }
      }
    }

    function renderAnimations(ctx) {
      for (const p of pulses) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
        ctx.strokeStyle = p.color;
        ctx.globalAlpha = p.alpha;
        ctx.lineWidth = 2;
        ctx.stroke();
      }
      ctx.globalAlpha = 1;

      for (const p of particles) {
        if (p.currentSegment >= p.path.length - 1) continue;

        const from = p.path[p.currentSegment];
        const to = p.path[p.currentSegment + 1];
        const x = from.x + (to.x - from.x) * p.progress;
        const y = from.y + (to.y - from.y) * p.progress;

        ctx.beginPath();
        ctx.moveTo(p.path[0].x, p.path[0].y);
        for (let i = 1; i <= p.currentSegment; i++) {
          ctx.lineTo(p.path[i].x, p.path[i].y);
        }
        ctx.lineTo(x, y);
        ctx.strokeStyle = p.color;
        ctx.globalAlpha = 0.4;
        ctx.lineWidth = 2;
        ctx.setLineDash([4, 2]);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.globalAlpha = 1;

        ctx.beginPath();
        ctx.arc(x, y, 6, 0, Math.PI * 2);
        ctx.fillStyle = p.color;
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 15;
        ctx.fill();
        ctx.shadowBlur = 0;
      }
    }

    function startAnimation() {
      if (animationRunning) return;
      animationRunning = true;
      animateLoop();
    }

    function animateLoop() {
      if (pulses.length === 0 && particles.length === 0) {
        animationRunning = false;
        return;
      }
      updateAnimations();
      render();
      requestAnimationFrame(animateLoop);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // BROADCAST ANIMATION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function getPeersInCell(cellId) {
      const peers = [];
      const allPeers = getAllPeers();
      for (const [pid, st] of allPeers) {
        if (st.cellId === cellId) peers.push(pid);
      }
      return peers;
    }

    function getAllCellIds() {
      const cells = new Set();
      const allPeers = getAllPeers();
      for (const [pid, st] of allPeers) {
        if (st.cellId) cells.add(st.cellId);
      }
      return [...cells].sort((a, b) => getCellIndex(a) - getCellIndex(b));
    }

    function buildPathToCell(fromPeerId, fromCellId, toCellId) {
      const path = [];
      const fromPos = nodePositions.get(fromPeerId);
      if (fromPos) path.push({ ...fromPos });
      const fromCellPos = cellPositions.get(fromCellId);
      if (fromCellPos) path.push({ ...fromCellPos });

      const fromIdx = getCellIndex(fromCellId);
      const toIdx = getCellIndex(toCellId);

      if (!Number.isNaN(fromIdx) && !Number.isNaN(toIdx) && fromIdx !== toIdx) {
        const step = fromIdx < toIdx ? 1 : -1;
        let currentIdx = fromIdx + step;
        while (currentIdx !== toIdx + step) {
          const cellId = `cell-${currentIdx}`;
          const cellPos = cellPositions.get(cellId);
          if (cellPos) path.push({ ...cellPos });
          currentIdx += step;
        }
      }
      return path;
    }

    function animateFullBroadcast(fromPeerId, fromCellId) {
      const fromPos = nodePositions.get(fromPeerId);
      const fromCellPos = cellPositions.get(fromCellId);
      
      if (fromPos) {
        createPulse(fromPos.x, fromPos.y, COLORS.message);
      } else if (fromCellPos) {
        createPulse(fromCellPos.x, fromCellPos.y, COLORS.message);
      }

      const sameCellPeers = getPeersInCell(fromCellId).filter(pid => pid !== fromPeerId);
      sameCellPeers.forEach((peerId, idx) => {
        setTimeout(() => {
          const toPos = nodePositions.get(peerId);
          if (fromPos && fromCellPos && toPos) {
            createParticle([fromPos, fromCellPos, toPos], COLORS.message);
          } else if (fromCellPos && toPos) {
            createParticle([fromCellPos, toPos], COLORS.message);
          }
        }, idx * 100);
      });

      if (getBridgesPerEdge() > 0) {
        const allCells = getAllCellIds();
        const otherCells = allCells.filter(cid => cid !== fromCellId);

        otherCells.forEach((toCellId, cellIdx) => {
          setTimeout(() => {
            const path = buildPathToCell(fromPeerId, fromCellId, toCellId);
            if (path.length >= 1) {
              const destPeers = getPeersInCell(toCellId);
              destPeers.forEach((destPeerId, peerIdx) => {
                setTimeout(() => {
                  const destPos = nodePositions.get(destPeerId);
                  if (destPos) {
                    createParticle([...path, destPos], COLORS.message);
                  }
                }, peerIdx * 80);
              });
            }
          }, (sameCellPeers.length * 100) + (cellIdx * 150));
        });
      }
    }

    function animateMessageSent() {
      animateFullBroadcast(selfId, selfState.cellId || "cell-0");
    }

    function animateMessageReceived(fromId) {
      const allPeers = getAllPeers();
      const fromState = allPeers.get(fromId);
      const fromCellId = fromState?.cellId;

      if (fromCellId) {
        animateFullBroadcast(fromId, fromCellId);
      } else {
        const myPos = nodePositions.get(selfId);
        if (myPos) createPulse(myPos.x, myPos.y, COLORS.message);
      }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STATE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const $ = id => document.getElementById(id);
    const shortId = id => id?.length > 10 ? `${id.slice(0, 4)}..${id.slice(-4)}` : id;

    let db = null, room = null, mesh = null;

    const CELLS_CONFIG = {
      cellSize: 'auto',
      bridgesPerEdge: 2,
      maxCellSize: 50,
      targetCells: 100
    };

    let selfState = {
      cellId: null,
      isBridge: false,
      bridges: [],
      cellSize: CELLS_CONFIG.cellSize,
      bridgesPerEdge: CELLS_CONFIG.bridgesPerEdge
    };

    const remotePeerStates = new Map();

    let connectedAt = null;
    let stats = { msgSent: 0, msgRecv: 0, bytesOut: 0, bytesIn: 0 };
    let lastFrameTime = performance.now();
    let frameCount = 0;
    let currentFps = 0;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // HELPERS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const getCellIndex = cid => {
      const m = String(cid || "").match(/cell-(\d+)/);
      return m ? Number(m[1]) : NaN;
    };

    const neighborCells = cid => {
      const i = getCellIndex(cid);
      if (Number.isNaN(i)) return [];
      const arr = [];
      if (i > 0) arr.push(`cell-${i - 1}`);
      arr.push(`cell-${i + 1}`);
      return arr;
    };

    function getAllPeers() {
      const all = new Map();
      for (const [pid, state] of remotePeerStates) {
        all.set(pid, { ...state });
      }
      if (selfId) {
        all.set(selfId, {
          cellId: selfState.cellId,
          isBridge: selfState.isBridge,
          bridges: selfState.bridges || []
        });
      }
      return all;
    }

    function getBridgesPerEdge() {
      return selfState.bridgesPerEdge ?? CELLS_CONFIG.bridgesPerEdge;
    }

    function getCellSize() {
      return selfState.cellSize || CELLS_CONFIG.cellSize;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // BRIDGE DETECTION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    let cachedBridgeMap = new Map();
    let cacheValid = false;

    function invalidateCache() { cacheValid = false; }

    function computeAllBridges() {
      if (cacheValid) return cachedBridgeMap;
      cachedBridgeMap.clear();
      const allPeers = getAllPeers();
      const allPeerIds = [...allPeers.keys()];
      for (const [pid, st] of allPeers) {
        cachedBridgeMap.set(pid, isPeerBridge(pid, st.cellId, allPeerIds));
      }
      cacheValid = true;
      return cachedBridgeMap;
    }

    function isCachedBridge(peerId) {
      return computeAllBridges().get(peerId) || false;
    }

    function computeBridgesForCell(cellId, allPeerIds) {
      const bridgesPerEdge = getBridgesPerEdge();
      const bridges = new Set();
      if (bridgesPerEdge === 0) return bridges;
      const cellIdx = getCellIndex(cellId);
      if (Number.isNaN(cellIdx)) return bridges;
      const cellSize = getCellSize();
      const sorted = [...allPeerIds].sort();
      const neighbors = neighborCells(cellId);
      for (const neighborCell of neighbors) {
        const neighborIdx = getCellIndex(neighborCell);
        if (Number.isNaN(neighborIdx)) continue;
        const minIdx = Math.min(cellIdx, neighborIdx);
        const maxIdx = Math.max(cellIdx, neighborIdx);
        const start = minIdx * cellSize;
        const end = (maxIdx + 1) * cellSize;
        const edgeGroup = sorted.slice(start, end);
        if (edgeGroup.length === 0) continue;
        for (const pid of edgeGroup.slice(0, bridgesPerEdge)) {
          bridges.add(pid);
        }
      }
      return bridges;
    }

    function isPeerBridge(peerId, cellId, allPeerIds) {
      if (!cellId) return false;
      return computeBridgesForCell(cellId, allPeerIds).has(peerId);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CANVAS SETUP & RENDERING
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const graphEl = $("graphContainer");
    const canvas = $("canvas");
    const ctx = canvas.getContext("2d");

    function resizeCanvas() {
      const dpr = window.devicePixelRatio || 1;
      const rect = graphEl.getBoundingClientRect();
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      canvas.style.width = rect.width + "px";
      canvas.style.height = rect.height + "px";
      ctx.scale(dpr, dpr);
      scheduleUpdate();
    }

    function calculateLayout() {
      const allPeers = getAllPeers();
      const cells = new Map();
      
      for (const [pid, st] of allPeers) {
        const cellId = st.cellId || "cell-0";
        if (!cells.has(cellId)) cells.set(cellId, []);
        cells.get(cellId).push({ id: pid, ...st });
      }

      const sortedCells = [...cells.keys()].sort((a, b) => getCellIndex(a) - getCellIndex(b));
      const rect = graphEl.getBoundingClientRect();
      const width = rect.width;
      const height = rect.height;
      const padding = 60;

      const layout = { cells: [], peers: [], links: [] };
      const cellCount = sortedCells.length || 1;
      const cellWidth = Math.min(200, (width - padding * 2) / cellCount);
      const startX = (width - cellWidth * cellCount) / 2 + cellWidth / 2;

      sortedCells.forEach((cellId, cellIndex) => {
        const cellX = startX + cellIndex * cellWidth;
        const cellY = height / 2;
        cellPositions.set(cellId, { x: cellX, y: cellY });

        layout.cells.push({
          id: cellId,
          x: cellX,
          y: cellY,
          label: `C${getCellIndex(cellId)}`
        });

        const peers = cells.get(cellId) || [];
        const peerCount = peers.length;
        const angleStep = (Math.PI * 2) / Math.max(peerCount, 1);
        const radius = Math.min(60, cellWidth / 3);

        peers.forEach((peer, peerIndex) => {
          const angle = angleStep * peerIndex - Math.PI / 2;
          const px = cellX + Math.cos(angle) * radius;
          const py = cellY + Math.sin(angle) * radius;
          nodePositions.set(peer.id, { x: px, y: py });

          const isSelf = peer.id === selfId;
          const isBridge = isSelf ? selfState.isBridge : isCachedBridge(peer.id);

          layout.peers.push({
            id: peer.id, x: px, y: py, cellId, isSelf, isBridge,
            bridges: peer.bridges || [],
            label: shortId(peer.id)
          });

          layout.links.push({ x1: px, y1: py, x2: cellX, y2: cellY, type: "membership" });
        });

        if (cellIndex < sortedCells.length - 1) {
          const nextCellX = startX + (cellIndex + 1) * cellWidth;
          layout.links.push({ x1: cellX + 20, y1: cellY, x2: nextCellX - 20, y2: cellY, type: "cell" });
        }
      });

      const peerPositions = new Map();
      for (const peer of layout.peers) {
        peerPositions.set(peer.id, peer);
      }

      for (const peer of layout.peers) {
        if (peer.isBridge && peer.bridges?.length > 0) {
          for (const targetId of peer.bridges) {
            const target = peerPositions.get(targetId);
            if (target && target.cellId !== peer.cellId) {
              const peerCellIdx = getCellIndex(peer.cellId);
              const targetCellIdx = getCellIndex(target.cellId);
              if (peerCellIdx < targetCellIdx) {
                layout.links.push({ x1: peer.x, y1: peer.y, x2: target.x, y2: target.y, type: "bridge" });
              }
            }
          }
        }
      }

      return layout;
    }

    function render() {
      const rect = graphEl.getBoundingClientRect();
      const width = rect.width;
      const height = rect.height;
      ctx.clearRect(0, 0, width, height);

      const layout = calculateLayout();

      // Links
      for (const link of layout.links) {
        ctx.beginPath();
        ctx.moveTo(link.x1, link.y1);
        ctx.lineTo(link.x2, link.y2);
        if (link.type === "cell") {
          ctx.strokeStyle = COLORS.cell;
          ctx.lineWidth = 2;
          ctx.setLineDash([]);
        } else if (link.type === "bridge") {
          ctx.strokeStyle = COLORS.bridgeLink;
          ctx.lineWidth = 2;
          ctx.setLineDash([4, 4]);
        } else {
          ctx.strokeStyle = COLORS.link;
          ctx.lineWidth = 1;
          ctx.setLineDash([]);
        }
        ctx.stroke();
      }
      ctx.setLineDash([]);

      // Cells
      for (const cell of layout.cells) {
        ctx.beginPath();
        ctx.arc(cell.x, cell.y, 20, 0, Math.PI * 2);
        ctx.fillStyle = COLORS.cell;
        ctx.fill();

        ctx.fillStyle = "#fff";
        ctx.font = "bold 11px Inter, sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(cell.label, cell.x, cell.y);
      }

      // Peers
      for (const peer of layout.peers) {
        const radius = peer.isSelf ? 12 : peer.isBridge ? 10 : 8;
        const color = peer.isSelf ? COLORS.self : peer.isBridge ? COLORS.bridge : COLORS.peer;

        ctx.beginPath();
        ctx.arc(peer.x, peer.y, radius, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.shadowColor = color;
        ctx.shadowBlur = peer.isSelf ? 12 : 6;
        ctx.fill();
        ctx.shadowBlur = 0;

        ctx.fillStyle = "rgba(255,255,255,0.9)";
        ctx.font = "10px Inter, sans-serif";
        ctx.textAlign = "center";
        ctx.fillText(peer.label, peer.x, peer.y + radius + 12);
      }

      renderAnimations(ctx);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // UI UPDATES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function updateUI() {
      $("cellId").textContent = selfState.cellId?.replace('cell-', 'C-') || "---";
      $("cellSize").textContent = selfState.cellSize || "--";
      $("peerCount").textContent = remotePeerStates.size + 1;
      $("roleStatus").textContent = selfState.isBridge ? "Bridge" : "Peer";

      const allPeers = getAllPeers();
      const cells = new Set();
      let bridges = 0;
      const bridgeMap = computeAllBridges();
      for (const [pid, st] of allPeers) {
        if (st.cellId) cells.add(st.cellId);
        if (bridgeMap.get(pid)) bridges++;
      }

      $("metricPeers").textContent = allPeers.size;
      $("metricCells").textContent = cells.size;
      $("metricBridges").textContent = bridges;
      $("metricCellSize").textContent = selfState.cellSize || "--";

      updateConnectionStats();
      render();
    }

    function formatBytes(bytes) {
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
      return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
    }

    function formatUptime(ms) {
      const secs = Math.floor(ms / 1000);
      const hrs = Math.floor(secs / 3600);
      const mins = Math.floor((secs % 3600) / 60);
      const s = secs % 60;
      return `${hrs.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
    }

    function updateConnectionStats() {
      if (connectedAt) $("connUptime").textContent = formatUptime(Date.now() - connectedAt);
      $("connBytesOut").textContent = formatBytes(stats.bytesOut);
      $("connBytesIn").textContent = formatBytes(stats.bytesIn);
    }

    function updateSystemStats() {
      if (performance.memory) {
        $("sysMemory").textContent = (performance.memory.usedJSHeapSize / 1024).toFixed(1) + " KB";
      } else {
        $("sysMemory").textContent = "N/A";
      }
      $("sysFps").textContent = currentFps;
    }

    function trackFps() {
      frameCount++;
      const now = performance.now();
      if (now - lastFrameTime >= 1000) {
        currentFps = frameCount;
        frameCount = 0;
        lastFrameTime = now;
      }
      requestAnimationFrame(trackFps);
    }
    requestAnimationFrame(trackFps);

    setInterval(() => { updateConnectionStats(); updateSystemStats(); }, 1000);

    function log(msg) {
      const el = $("log");
      const entry = document.createElement("div");
      entry.className = "chat-entry";
      const time = new Date().toLocaleTimeString('en-US', { hour12: false });
      entry.innerHTML = `<span class="time">[${time}]</span> ${msg}`;
      el.appendChild(entry);
      el.scrollTop = el.scrollHeight;
      while (el.children.length > 50) el.removeChild(el.firstChild);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // THROTTLED UPDATE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    let updatePending = false;
    let lastUpdateTime = 0;
    const UPDATE_THROTTLE = 250;

    function scheduleUpdate() {
      if (updatePending) return;
      const now = Date.now();
      const elapsed = now - lastUpdateTime;
      if (elapsed >= UPDATE_THROTTLE) {
        updatePending = true;
        requestAnimationFrame(doUpdate);
      } else {
        updatePending = true;
        setTimeout(() => requestAnimationFrame(doUpdate), UPDATE_THROTTLE - elapsed);
      }
    }

    function doUpdate() {
      updateUI();
      lastUpdateTime = Date.now();
      updatePending = false;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CONNECT & EVENTS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const relayUrls = ["wss://relay.orangepill.ovh"];

    async function connect() {
      try {
        log('Initializing mesh network...');
        
        db = await gdb('mesh-cells-monitor', {
          rtc: { relayUrls, cells: { ...CELLS_CONFIG, debug: false } }
        });

        room = db.room;
        mesh = room.mesh;
        selfId = db.selfId;

        $("statusBadge").classList.remove('connecting', 'offline');
        $("connectionStatus").textContent = "Online";
        $("connStatus").textContent = "Online";
        $("connStatus").className = "metric-value success";
        connectedAt = Date.now();

        room.on("peer:join", id => {
          log(`<span class="success">+ ${shortId(id)} joined</span>`);
          invalidateCache();
          scheduleUpdate();
        });

        room.on("peer:leave", id => {
          remotePeerStates.delete(id);
          log(`<span class="c-dim">- ${shortId(id)} left</span>`);
          invalidateCache();
          scheduleUpdate();
        });

        room.on("mesh:state", state => {
          selfState = {
            cellId: state.cellId,
            isBridge: state.isBridge === true,
            bridges: Array.isArray(state.bridges) ? state.bridges : [],
            cellSize: state.cellSize || CELLS_CONFIG.cellSize,
            bridgesPerEdge: state.bridgesPerEdge ?? CELLS_CONFIG.bridgesPerEdge
          };
          invalidateCache();
          scheduleUpdate();
        });

        room.on("mesh:peer-state", data => {
          if (data.id === selfId) return;
          remotePeerStates.set(data.id, {
            cellId: data.cell,
            isBridge: data.isBridge === true,
            bridges: Array.isArray(data.bridges) ? data.bridges : []
          });
          invalidateCache();
          scheduleUpdate();
        });

        mesh.on("message", (msg, from) => {
          if (from === selfId) return;
          const content = typeof msg === "string" ? msg : JSON.stringify(msg).slice(0, 30);
          const msgSize = typeof msg === "string" ? msg.length : JSON.stringify(msg).length;
          stats.msgRecv++;
          stats.bytesIn += msgSize;
          log(`<span class="from">${shortId(from)}:</span> ${content}`);
          animateMessageReceived(from);
        });

        $("msgInput").disabled = false;
        $("sendBtn").disabled = false;
        $("netRelay").textContent = "orangepill.ovh";
        $("netRoom").textContent = "mesh-cells-monitor";
        $("yourId").textContent = shortId(selfId);

        log('<span class="success">Connected to mesh network</span>');

      } catch (error) {
        $("statusBadge").classList.remove('connecting');
        $("statusBadge").classList.add('offline');
        $("connectionStatus").textContent = "Error";
        log(`<span class="error">Error: ${error.message}</span>`);
      }
    }

    function sendMessage() {
      const input = $("msgInput");
      const text = input.value.trim();
      if (!text || !mesh) return;
      mesh.send(text);
      stats.msgSent++;
      stats.bytesOut += text.length;
      log(`<span class="you">You:</span> ${text}`);
      animateMessageSent();
      input.value = "";
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // INIT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    window.addEventListener("load", () => {
      resizeCanvas();
      window.addEventListener("resize", resizeCanvas);
      
      $("sendBtn").addEventListener("click", sendMessage);
      $("msgInput").addEventListener("keydown", e => { if (e.key === "Enter") sendMessage(); });

      log('Starting Mesh Monitor...');
      setTimeout(() => connect(), 300);
      scheduleUpdate();
    });
  </script>
</body>

</html>
