var w0=typeof globalThis==="object"&&("crypto"in globalThis)?globalThis.crypto:void 0;function I0($){return $ instanceof Uint8Array||ArrayBuffer.isView($)&&$.constructor.name==="Uint8Array"}function o0($){if(!Number.isSafeInteger($)||$<0)throw new Error("positive integer expected, got "+$)}function $0($,...J){if(!I0($))throw new Error("Uint8Array expected");if(J.length>0&&!J.includes($.length))throw new Error("Uint8Array expected of length "+J+", got length="+$.length)}function Y8($){if(typeof $!=="function"||typeof $.create!=="function")throw new Error("Hash should be wrapped by utils.createHasher");o0($.outputLen),o0($.blockLen)}function _0($,J=!0){if($.destroyed)throw new Error("Hash instance has been destroyed");if(J&&$.finished)throw new Error("Hash#digest() has already been called")}function Y$($,J){$0($);const q=J.outputLen;if($.length<q)throw new Error("digestInto() expects output buffer of length at least "+q)}function k0(...$){for(let J=0;J<$.length;J++)$[J].fill(0)}function Z8($){return new DataView($.buffer,$.byteOffset,$.byteLength)}function Q0($,J){return $<<32-J|$>>>J}function Z0($){if($0($),Z$)return $.toHex();let J="";for(let q=0;q<$.length;q++)J+=wQ[$[q]];return J}var X$=function($){if($>=Y0._0&&$<=Y0._9)return $-Y0._0;if($>=Y0.A&&$<=Y0.F)return $-(Y0.A-10);if($>=Y0.a&&$<=Y0.f)return $-(Y0.a-10);return};function S0($){if(typeof $!=="string")throw new Error("hex string expected, got "+typeof $);if(Z$)return Uint8Array.fromHex($);const J=$.length,q=J/2;if(J%2)throw new Error("hex string expected, got unpadded hex of length "+J);const Q=new Uint8Array(q);for(let G=0,z=0;G<q;G++,z+=2){const U=X$($.charCodeAt(z)),Y=X$($.charCodeAt(z+1));if(U===void 0||Y===void 0){const X=$[z]+$[z+1];throw new Error('hex string expected, got non-hex character "'+X+'" at index '+z)}Q[G]=U*16+Y}return Q}function K8($){if(typeof $!=="string")throw new Error("string expected");return new Uint8Array((new TextEncoder()).encode($))}function r0($){if(typeof $==="string")$=K8($);return $0($),$}function o(...$){let J=0;for(let Q=0;Q<$.length;Q++){const G=$[Q];$0(G),J+=G.length}const q=new Uint8Array(J);for(let Q=0,G=0;Q<$.length;Q++){const z=$[Q];q.set(z,G),G+=z.length}return q}function K$($){const J=(Q)=>$().update(r0(Q)).digest(),q=$();return J.outputLen=q.outputLen,J.blockLen=q.blockLen,J.create=()=>$(),J}function P0($=32){if(w0&&typeof w0.getRandomValues==="function")return w0.getRandomValues(new Uint8Array($));if(w0&&typeof w0.randomBytes==="function")return Uint8Array.from(w0.randomBytes($));throw new Error("crypto.getRandomValues must be defined")}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */var Z$=(()=>typeof Uint8Array.from([]).toHex==="function"&&typeof Uint8Array.fromHex==="function")(),wQ=Array.from({length:256},($,J)=>J.toString(16).padStart(2,"0")),Y0={_0:48,_9:57,A:65,F:70,a:97,f:102};class p0{}function IQ($,J,q,Q){if(typeof $.setBigUint64==="function")return $.setBigUint64(J,q,Q);const G=BigInt(32),z=BigInt(4294967295),U=Number(q>>G&z),Y=Number(q&z),X=Q?4:0,V=Q?0:4;$.setUint32(J+X,U,Q),$.setUint32(J+V,Y,Q)}function M$($,J,q){return $&J^~$&q}function D$($,J,q){return $&J^$&q^J&q}class f8 extends p0{constructor($,J,q,Q){super();this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=$,this.outputLen=J,this.padOffset=q,this.isLE=Q,this.buffer=new Uint8Array($),this.view=Z8(this.buffer)}update($){_0(this),$=r0($),$0($);const{view:J,buffer:q,blockLen:Q}=this,G=$.length;for(let z=0;z<G;){const U=Math.min(Q-this.pos,G-z);if(U===Q){const Y=Z8($);for(;Q<=G-z;z+=Q)this.process(Y,z);continue}if(q.set($.subarray(z,z+U),this.pos),this.pos+=U,z+=U,this.pos===Q)this.process(J,0),this.pos=0}return this.length+=$.length,this.roundClean(),this}digestInto($){_0(this),Y$($,this),this.finished=!0;const{buffer:J,view:q,blockLen:Q,isLE:G}=this;let{pos:z}=this;if(J[z++]=128,k0(this.buffer.subarray(z)),this.padOffset>Q-z)this.process(q,0),z=0;for(let N=z;N<Q;N++)J[N]=0;IQ(q,Q-8,BigInt(this.length*8),G),this.process(q,0);const U=Z8($),Y=this.outputLen;if(Y%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const X=Y/4,V=this.get();if(X>V.length)throw new Error("_sha2: outputLen bigger than state");for(let N=0;N<X;N++)U.setUint32(4*N,V[N],G)}digest(){const{buffer:$,outputLen:J}=this;this.digestInto($);const q=$.slice(0,J);return this.destroy(),q}_cloneInto($){$||($=new this.constructor),$.set(...this.get());const{blockLen:J,buffer:q,length:Q,finished:G,destroyed:z,pos:U}=this;if($.destroyed=z,$.finished=G,$.length=Q,$.pos=U,Q%J)$.buffer.set(q);return $}clone(){return this._cloneInto()}}var K0=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]);var kQ=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),H0=new Uint32Array(64);class W$ extends f8{constructor($=32){super(64,$,8,!1);this.A=K0[0]|0,this.B=K0[1]|0,this.C=K0[2]|0,this.D=K0[3]|0,this.E=K0[4]|0,this.F=K0[5]|0,this.G=K0[6]|0,this.H=K0[7]|0}get(){const{A:$,B:J,C:q,D:Q,E:G,F:z,G:U,H:Y}=this;return[$,J,q,Q,G,z,U,Y]}set($,J,q,Q,G,z,U,Y){this.A=$|0,this.B=J|0,this.C=q|0,this.D=Q|0,this.E=G|0,this.F=z|0,this.G=U|0,this.H=Y|0}process($,J){for(let N=0;N<16;N++,J+=4)H0[N]=$.getUint32(J,!1);for(let N=16;N<64;N++){const L=H0[N-15],j=H0[N-2],K=Q0(L,7)^Q0(L,18)^L>>>3,x=Q0(j,17)^Q0(j,19)^j>>>10;H0[N]=x+H0[N-7]+K+H0[N-16]|0}let{A:q,B:Q,C:G,D:z,E:U,F:Y,G:X,H:V}=this;for(let N=0;N<64;N++){const L=Q0(U,6)^Q0(U,11)^Q0(U,25),j=V+L+M$(U,Y,X)+kQ[N]+H0[N]|0,x=(Q0(q,2)^Q0(q,13)^Q0(q,22))+D$(q,Q,G)|0;V=X,X=Y,Y=U,U=z+j|0,z=G,G=Q,Q=q,q=j+x|0}q=q+this.A|0,Q=Q+this.B|0,G=G+this.C|0,z=z+this.D|0,U=U+this.E|0,Y=Y+this.F|0,X=X+this.G|0,V=V+this.H|0,this.set(q,Q,G,z,U,Y,X,V)}roundClean(){k0(H0)}destroy(){this.set(0,0,0,0,0,0,0,0),k0(this.buffer)}}var M8=K$(()=>new W$);class _8 extends p0{constructor($,J){super();this.finished=!1,this.destroyed=!1,Y8($);const q=r0(J);if(this.iHash=$.create(),typeof this.iHash.update!=="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const Q=this.blockLen,G=new Uint8Array(Q);G.set(q.length>Q?$.create().update(q).digest():q);for(let z=0;z<G.length;z++)G[z]^=54;this.iHash.update(G),this.oHash=$.create();for(let z=0;z<G.length;z++)G[z]^=54^92;this.oHash.update(G),k0(G)}update($){return _0(this),this.iHash.update($),this}digestInto($){_0(this),$0($,this.outputLen),this.finished=!0,this.iHash.digestInto($),this.oHash.update($),this.oHash.digestInto($),this.destroy()}digest(){const $=new Uint8Array(this.oHash.outputLen);return this.digestInto($),$}_cloneInto($){$||($=Object.create(Object.getPrototypeOf(this),{}));const{oHash:J,iHash:q,finished:Q,destroyed:G,blockLen:z,outputLen:U}=this;return $=$,$.finished=Q,$.destroyed=G,$.blockLen=z,$.outputLen=U,$.oHash=J._cloneInto($.oHash),$.iHash=q._cloneInto($.iHash),$}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}var b8=($,J,q)=>new _8($,J).update(q).digest();b8.create=($,J)=>new _8($,J);function i0($,J=""){if(typeof $!=="boolean"){const q=J&&`"${J}"`;throw new Error(q+"expected boolean, got type="+typeof $)}return $}function O0($,J,q=""){const Q=I0($),G=$?.length,z=J!==void 0;if(!Q||z&&G!==J){const U=q&&`"${q}" `,Y=z?` of length ${J}`:"",X=Q?`length=${G}`:`type=${typeof $}`;throw new Error(U+"expected Uint8Array"+Y+", got "+X)}return $}function a0($){const J=$.toString(16);return J.length&1?"0"+J:J}function N$($){if(typeof $!=="string")throw new Error("hex string expected, got "+typeof $);return $===""?u8:BigInt("0x"+$)}function M0($){return N$(Z0($))}function m8($){return $0($),N$(Z0(Uint8Array.from($).reverse()))}function b0($,J){return S0($.toString(16).padStart(J*2,"0"))}function F8($,J){return b0($,J).reverse()}function m($,J,q){let Q;if(typeof J==="string")try{Q=S0(J)}catch(z){throw new Error($+" must be hex string or Uint8Array, cause: "+z)}else if(I0(J))Q=Uint8Array.from(J);else throw new Error($+" must be hex string or Uint8Array");const G=Q.length;if(typeof q==="number"&&G!==q)throw new Error($+" of length "+q+" expected, got "+G);return Q}function n0($,J,q){return g8($)&&g8(J)&&g8(q)&&J<=$&&$<q}function V$($,J,q,Q){if(!n0(J,q,Q))throw new Error("expected valid "+$+": "+q+" <= n < "+Q+", got "+J)}function D8($){let J;for(J=0;$>u8;$>>=y8,J+=1);return J}function C$($,J,q){if(typeof $!=="number"||$<2)throw new Error("hashLen must be a number");if(typeof J!=="number"||J<2)throw new Error("qByteLen must be a number");if(typeof q!=="function")throw new Error("hmacFn must be a function");const Q=(K)=>new Uint8Array(K),G=(K)=>Uint8Array.of(K);let z=Q($),U=Q($),Y=0;const X=()=>{z.fill(1),U.fill(0),Y=0},V=(...K)=>q(U,z,...K),N=(K=Q(0))=>{if(U=V(G(0),K),z=V(),K.length===0)return;U=V(G(1),K),z=V()},L=()=>{if(Y++>=1000)throw new Error("drbg: tried 1000 values");let K=0;const x=[];while(K<J){z=V();const A=z.slice();x.push(A),K+=z.length}return o(...x)};return(K,x)=>{X(),N(K);let A=void 0;while(!(A=x(L())))N();return X(),A}}function s0($,J,q={}){if(!$||typeof $!=="object")throw new Error("expected valid options object");function Q(G,z,U){const Y=$[G];if(U&&Y===void 0)return;const X=typeof Y;if(X!==z||Y===null)throw new Error(`param "${G}" is invalid: expected ${z}, got ${X}`)}Object.entries(J).forEach(([G,z])=>Q(G,z,!1)),Object.entries(q).forEach(([G,z])=>Q(G,z,!0))}function h8($){const J=new WeakMap;return(q,...Q)=>{const G=J.get(q);if(G!==void 0)return G;const z=$(q,...Q);return J.set(q,z),z}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var u8=BigInt(0),y8=BigInt(1),g8=($)=>typeof $==="bigint"&&u8<=$,x0=($)=>(y8<<BigInt($))-y8;function i($,J){const q=$%J;return q>=l?q:J+q}function a($,J,q){let Q=$;while(J-- >l)Q*=Q,Q%=q;return Q}function B$($,J){if($===l)throw new Error("invert: expected non-zero number");if(J<=l)throw new Error("invert: expected positive modulus, got "+J);let q=i($,J),Q=J,G=l,z=h,U=h,Y=l;while(q!==l){const V=Q/q,N=Q%q,L=G-U*V,j=z-Y*V;Q=q,q=N,G=U,z=Y,U=L,Y=j}if(Q!==h)throw new Error("invert: does not exist");return i(G,J)}var l8=function($,J,q){if(!$.eql($.sqr(J),q))throw new Error("Cannot find square root")},A$=function($,J){const q=($.ORDER+h)/x$,Q=$.pow(J,q);return l8($,Q,J),Q},EQ=function($,J){const q=($.ORDER-T$)/L$,Q=$.mul(J,E0),G=$.pow(Q,q),z=$.mul(J,G),U=$.mul($.mul(z,E0),G),Y=$.mul(z,$.sub(U,$.ONE));return l8($,Y,J),Y},vQ=function($){const J=T0($),q=w$($),Q=q(J,J.neg(J.ONE)),G=q(J,Q),z=q(J,J.neg(Q)),U=($+SQ)/R$;return(Y,X)=>{let V=Y.pow(X,U),N=Y.mul(V,Q);const L=Y.mul(V,G),j=Y.mul(V,z),K=Y.eql(Y.sqr(N),X),x=Y.eql(Y.sqr(L),X);V=Y.cmov(V,N,K),N=Y.cmov(j,L,x);const A=Y.eql(Y.sqr(N),X),E=Y.cmov(V,N,A);return l8(Y,E,X),E}};function w$($){if($<O$)throw new Error("sqrt is not defined for small field");let J=$-h,q=0;while(J%E0===l)J/=E0,q++;let Q=E0;const G=T0($);while(H$(G,Q)===1)if(Q++>1000)throw new Error("Cannot find square root: probably non-prime P");if(q===1)return A$;let z=G.pow(Q,J);const U=(J+h)/E0;return function Y(X,V){if(X.is0(V))return V;if(H$(X,V)!==1)throw new Error("Cannot find square root");let N=q,L=X.mul(X.ONE,z),j=X.pow(V,J),K=X.pow(V,U);while(!X.eql(j,X.ONE)){if(X.is0(j))return X.ZERO;let x=1,A=X.sqr(j);while(!X.eql(A,X.ONE))if(x++,A=X.sqr(A),x===N)throw new Error("Cannot find square root");const E=h<<BigInt(N-x-1),f=X.pow(L,E);N=x,L=X.sqr(f),j=X.mul(j,L),K=X.mul(K,f)}return K}}function fQ($){if($%x$===O$)return A$;if($%L$===T$)return EQ;if($%R$===PQ)return vQ($);return w$($)}function c8($){const J={ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"},q=_Q.reduce((Q,G)=>{return Q[G]="function",Q},J);return s0($,q),$}function bQ($,J,q){if(q<l)throw new Error("invalid exponent, negatives unsupported");if(q===l)return $.ONE;if(q===h)return J;let Q=$.ONE,G=J;while(q>l){if(q&h)Q=$.mul(Q,G);G=$.sqr(G),q>>=h}return Q}function W8($,J,q=!1){const Q=new Array(J.length).fill(q?$.ZERO:void 0),G=J.reduce((U,Y,X)=>{if($.is0(Y))return U;return Q[X]=U,$.mul(U,Y)},$.ONE),z=$.inv(G);return J.reduceRight((U,Y,X)=>{if($.is0(Y))return U;return Q[X]=$.mul(U,Q[X]),$.mul(U,Y)},z),Q}function H$($,J){const q=($.ORDER-h)/E0,Q=$.pow(J,q),G=$.eql(Q,$.ONE),z=$.eql(Q,$.ZERO),U=$.eql(Q,$.neg($.ONE));if(!G&&!z&&!U)throw new Error("invalid Legendre symbol result");return G?1:z?0:-1}function N8($,J){if(J!==void 0)o0(J);const q=J!==void 0?J:$.toString(2).length,Q=Math.ceil(q/8);return{nBitLength:q,nByteLength:Q}}function T0($,J,q=!1,Q={}){if($<=l)throw new Error("invalid field: expected ORDER > 0, got "+$);let G=void 0,z=void 0,U=!1,Y=void 0;if(typeof J==="object"&&J!=null){if(Q.sqrt||q)throw new Error("cannot specify opts in two arguments");const j=J;if(j.BITS)G=j.BITS;if(j.sqrt)z=j.sqrt;if(typeof j.isLE==="boolean")q=j.isLE;if(typeof j.modFromBytes==="boolean")U=j.modFromBytes;Y=j.allowedLengths}else{if(typeof J==="number")G=J;if(Q.sqrt)z=Q.sqrt}const{nBitLength:X,nByteLength:V}=N8($,G);if(V>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let N;const L=Object.freeze({ORDER:$,isLE:q,BITS:X,BYTES:V,MASK:x0(X),ZERO:l,ONE:h,allowedLengths:Y,create:(j)=>i(j,$),isValid:(j)=>{if(typeof j!=="bigint")throw new Error("invalid field element: expected bigint, got "+typeof j);return l<=j&&j<$},is0:(j)=>j===l,isValidNot0:(j)=>!L.is0(j)&&L.isValid(j),isOdd:(j)=>(j&h)===h,neg:(j)=>i(-j,$),eql:(j,K)=>j===K,sqr:(j)=>i(j*j,$),add:(j,K)=>i(j+K,$),sub:(j,K)=>i(j-K,$),mul:(j,K)=>i(j*K,$),pow:(j,K)=>bQ(L,j,K),div:(j,K)=>i(j*B$(K,$),$),sqrN:(j)=>j*j,addN:(j,K)=>j+K,subN:(j,K)=>j-K,mulN:(j,K)=>j*K,inv:(j)=>B$(j,$),sqrt:z||((j)=>{if(!N)N=fQ($);return N(L,j)}),toBytes:(j)=>q?F8(j,V):b0(j,V),fromBytes:(j,K=!0)=>{if(Y){if(!Y.includes(j.length)||j.length>V)throw new Error("Field.fromBytes: expected "+Y+" bytes, got "+j.length);const A=new Uint8Array(V);A.set(j,q?0:A.length-j.length),j=A}if(j.length!==V)throw new Error("Field.fromBytes: expected "+V+" bytes, got "+j.length);let x=q?m8(j):M0(j);if(U)x=i(x,$);if(!K){if(!L.isValid(x))throw new Error("invalid field element: outside of range 0..ORDER")}return x},invertBatch:(j)=>W8(L,j),cmov:(j,K,x)=>x?K:j});return Object.freeze(L)}function I$($){if(typeof $!=="bigint")throw new Error("field order must be bigint");const J=$.toString(2).length;return Math.ceil(J/8)}function d8($){const J=I$($);return J+Math.ceil(J/2)}function V8($,J,q=!1){const Q=$.length,G=I$(J),z=d8(J);if(Q<16||Q<z||Q>1024)throw new Error("expected "+z+"-1024 bytes of input, got "+Q);const U=q?m8($):M0($),Y=i(U,J-h)+h;return q?F8(Y,G):b0(Y,G)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var l=BigInt(0),h=BigInt(1),E0=BigInt(2),O$=BigInt(3),x$=BigInt(4),T$=BigInt(5),SQ=BigInt(7),L$=BigInt(8),PQ=BigInt(9),R$=BigInt(16);var _Q=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function t0($,J){const q=J.negate();return $?q:J}function C8($,J){const q=W8($.Fp,J.map((Q)=>Q.Z));return J.map((Q,G)=>$.fromAffine(Q.toAffine(q[G])))}var E$=function($,J){if(!Number.isSafeInteger($)||$<=0||$>J)throw new Error("invalid window size, expected [1.."+J+"], got W="+$)},o8=function($,J){E$($,J);const q=Math.ceil(J/$)+1,Q=2**($-1),G=2**$,z=x0($),U=BigInt($);return{windows:q,windowSize:Q,mask:z,maxNumber:G,shiftBy:U}},k$=function($,J,q){const{windowSize:Q,mask:G,maxNumber:z,shiftBy:U}=q;let Y=Number($&G),X=$>>U;if(Y>Q)Y-=z,X+=v0;const V=J*Q,N=V+Math.abs(Y)-1,L=Y===0,j=Y<0,K=J%2!==0;return{nextN:X,offset:N,isZero:L,isNeg:j,isNegF:K,offsetF:V}},gQ=function($,J){if(!Array.isArray($))throw new Error("array expected");$.forEach((q,Q)=>{if(!(q instanceof J))throw new Error("invalid point at index "+Q)})},yQ=function($,J){if(!Array.isArray($))throw new Error("array of scalars expected");$.forEach((q,Q)=>{if(!J.isValid(q))throw new Error("invalid scalar at index "+Q)})},p8=function($){return v$.get($)||1},S$=function($){if($!==g0)throw new Error("invalid wNAF")};function f$($,J,q,Q){let G=J,z=$.ZERO,U=$.ZERO;while(q>g0||Q>g0){if(q&v0)z=z.add(G);if(Q&v0)U=U.add(G);G=G.double(),q>>=v0,Q>>=v0}return{p1:z,p2:U}}function _$($,J,q,Q){gQ(q,$),yQ(Q,J);const G=q.length,z=Q.length;if(G!==z)throw new Error("arrays of points and scalars must have equal length");const U=$.ZERO,Y=D8(BigInt(G));let X=1;if(Y>12)X=Y-3;else if(Y>4)X=Y-2;else if(Y>0)X=2;const V=x0(X),N=new Array(Number(V)+1).fill(U),L=Math.floor((J.BITS-1)/X)*X;let j=U;for(let K=L;K>=0;K-=X){N.fill(U);for(let A=0;A<z;A++){const E=Q[A],f=Number(E>>BigInt(K)&V);N[f]=N[f].add(q[A])}let x=U;for(let A=N.length-1,E=U;A>0;A--)E=E.add(N[A]),x=x.add(E);if(j=j.add(x),K!==0)for(let A=0;A<X;A++)j=j.double()}return j}var P$=function($,J,q){if(J){if(J.ORDER!==$)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return c8(J),J}else return T0($,{isLE:q})};function b$($,J,q={},Q){if(Q===void 0)Q=$==="edwards";if(!J||typeof J!=="object")throw new Error(`expected valid ${$} CURVE object`);for(let X of["p","n","h"]){const V=J[X];if(!(typeof V==="bigint"&&V>g0))throw new Error(`CURVE.${X} must be positive bigint`)}const G=P$(J.p,q.Fp,Q),z=P$(J.n,q.Fn,Q),Y=["Gx","Gy","a",$==="weierstrass"?"b":"d"];for(let X of Y)if(!G.isValid(J[X]))throw new Error(`CURVE.${X} must be valid field element of CURVE.Fp`);return J=Object.freeze(Object.assign({},J)),{CURVE:J,Fp:G,Fn:z}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var g0=BigInt(0),v0=BigInt(1),r8=new WeakMap,v$=new WeakMap;class i8{constructor($,J){this.BASE=$.BASE,this.ZERO=$.ZERO,this.Fn=$.Fn,this.bits=J}_unsafeLadder($,J,q=this.ZERO){let Q=$;while(J>g0){if(J&v0)q=q.add(Q);Q=Q.double(),J>>=v0}return q}precomputeWindow($,J){const{windows:q,windowSize:Q}=o8(J,this.bits),G=[];let z=$,U=z;for(let Y=0;Y<q;Y++){U=z,G.push(U);for(let X=1;X<Q;X++)U=U.add(z),G.push(U);z=U.double()}return G}wNAF($,J,q){if(!this.Fn.isValid(q))throw new Error("invalid scalar");let Q=this.ZERO,G=this.BASE;const z=o8($,this.bits);for(let U=0;U<z.windows;U++){const{nextN:Y,offset:X,isZero:V,isNeg:N,isNegF:L,offsetF:j}=k$(q,U,z);if(q=Y,V)G=G.add(t0(L,J[j]));else Q=Q.add(t0(N,J[X]))}return S$(q),{p:Q,f:G}}wNAFUnsafe($,J,q,Q=this.ZERO){const G=o8($,this.bits);for(let z=0;z<G.windows;z++){if(q===g0)break;const{nextN:U,offset:Y,isZero:X,isNeg:V}=k$(q,z,G);if(q=U,X)continue;else{const N=J[Y];Q=Q.add(V?N.negate():N)}}return S$(q),Q}getPrecomputes($,J,q){let Q=r8.get(J);if(!Q){if(Q=this.precomputeWindow(J,$),$!==1){if(typeof q==="function")Q=q(Q);r8.set(J,Q)}}return Q}cached($,J,q){const Q=p8($);return this.wNAF(Q,this.getPrecomputes(Q,$,q),J)}unsafe($,J,q,Q){const G=p8($);if(G===1)return this._unsafeLadder($,J,Q);return this.wNAFUnsafe(G,this.getPrecomputes(G,$,q),J,Q)}createCache($,J){E$(J,this.bits),v$.set($,J),r8.delete($)}hasCache($){return p8($)!==1}}function uQ($,J,q){const[[Q,G],[z,U]]=J,Y=g$(U*$,q),X=g$(-G*$,q);let V=$-Y*Q-X*z,N=-Y*G-X*U;const L=V<W0,j=N<W0;if(L)V=-V;if(j)N=-N;const K=x0(Math.ceil(D8(q)/2))+y0;if(V<W0||V>=K||N<W0||N>=K)throw new Error("splitScalar (endomorphism): failed, k="+$);return{k1neg:L,k1:V,k2neg:j,k2:N}}var n8=function($){if(!["compact","recovered","der"].includes($))throw new Error('Signature format must be "compact", "recovered", or "der"');return $},a8=function($,J){const q={};for(let Q of Object.keys(J))q[Q]=$[Q]===void 0?J[Q]:$[Q];if(i0(q.lowS,"lowS"),i0(q.prehash,"prehash"),q.format!==void 0)n8(q.format);return q};function L0($,J){const{BYTES:q}=$;let Q;if(typeof J==="bigint")Q=J;else{let G=m("private key",J);try{Q=$.fromBytes(G)}catch(z){throw new Error(`invalid private key: expected ui8a of size ${q}, got ${typeof J}`)}}if(!$.isValidNot0(Q))throw new Error("invalid private key: out of range [1..N-1]");return Q}function FQ($,J={}){const q=b$("weierstrass",$,J),{Fp:Q,Fn:G}=q;let z=q.CURVE;const{h:U,n:Y}=z;s0(J,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:X}=J;if(X){if(!Q.is0(z.a)||typeof X.beta!=="bigint"||!Array.isArray(X.basises))throw new Error('invalid endo: expected "beta": bigint and "basises": array')}const V=F$(Q,G);function N(){if(!Q.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function L(W,T,M){const{x:H,y:Z}=T.toAffine(),D=Q.toBytes(H);if(i0(M,"isCompressed"),M){N();const C=!Q.isOdd(Z);return o(m$(C),D)}else return o(Uint8Array.of(4),D,Q.toBytes(Z))}function j(W){O0(W,void 0,"Point");const{publicKey:T,publicKeyUncompressed:M}=V,H=W.length,Z=W[0],D=W.subarray(1);if(H===T&&(Z===2||Z===3)){const C=Q.fromBytes(D);if(!Q.isValid(C))throw new Error("bad point: is not on curve, wrong x");const O=A(C);let B;try{B=Q.sqrt(O)}catch(k){const w=k instanceof Error?": "+k.message:"";throw new Error("bad point: is not on curve, sqrt error"+w)}N();const R=Q.isOdd(B);if((Z&1)===1!==R)B=Q.neg(B);return{x:C,y:B}}else if(H===M&&Z===4){const C=Q.BYTES,O=Q.fromBytes(D.subarray(0,C)),B=Q.fromBytes(D.subarray(C,C*2));if(!E(O,B))throw new Error("bad point: is not on curve");return{x:O,y:B}}else throw new Error(`bad point: got length ${H}, expected compressed=${T} or uncompressed=${M}`)}const K=J.toBytes||L,x=J.fromBytes||j;function A(W){const T=Q.sqr(W),M=Q.mul(T,W);return Q.add(Q.add(M,Q.mul(W,z.a)),z.b)}function E(W,T){const M=Q.sqr(T),H=A(W);return Q.eql(M,H)}if(!E(z.Gx,z.Gy))throw new Error("bad curve params: generator point");const f=Q.mul(Q.pow(z.a,B8),mQ),q0=Q.mul(Q.sqr(z.b),BigInt(27));if(Q.is0(Q.add(f,q0)))throw new Error("bad curve params: a or b");function b(W,T,M=!1){if(!Q.isValid(T)||M&&Q.is0(T))throw new Error(`bad point coordinate ${W}`);return T}function n(W){if(!(W instanceof I))throw new Error("ProjectivePoint expected")}function c(W){if(!X||!X.basises)throw new Error("no endo");return uQ(W,X.basises,G.ORDER)}const s=h8((W,T)=>{const{X:M,Y:H,Z}=W;if(Q.eql(Z,Q.ONE))return{x:M,y:H};const D=W.is0();if(T==null)T=D?Q.ONE:Q.inv(Z);const C=Q.mul(M,T),O=Q.mul(H,T),B=Q.mul(Z,T);if(D)return{x:Q.ZERO,y:Q.ZERO};if(!Q.eql(B,Q.ONE))throw new Error("invZ was invalid");return{x:C,y:O}}),C0=h8((W)=>{if(W.is0()){if(J.allowInfinityPoint&&!Q.is0(W.Y))return;throw new Error("bad point: ZERO")}const{x:T,y:M}=W.toAffine();if(!Q.isValid(T)||!Q.isValid(M))throw new Error("bad point: x or y not field elements");if(!E(T,M))throw new Error("bad point: equation left != right");if(!W.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function G0(W,T,M,H,Z){return M=new I(Q.mul(M.X,W),M.Y,M.Z),T=t0(H,T),M=t0(Z,M),T.add(M)}class I{constructor(W,T,M){this.X=b("x",W),this.Y=b("y",T,!0),this.Z=b("z",M),Object.freeze(this)}static CURVE(){return z}static fromAffine(W){const{x:T,y:M}=W||{};if(!W||!Q.isValid(T)||!Q.isValid(M))throw new Error("invalid affine point");if(W instanceof I)throw new Error("projective point not allowed");if(Q.is0(T)&&Q.is0(M))return I.ZERO;return new I(T,M,Q.ONE)}static fromBytes(W){const T=I.fromAffine(x(O0(W,void 0,"point")));return T.assertValidity(),T}static fromHex(W){return I.fromBytes(m("pointHex",W))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(W=8,T=!0){if(S.createCache(this,W),!T)this.multiply(B8);return this}assertValidity(){C0(this)}hasEvenY(){const{y:W}=this.toAffine();if(!Q.isOdd)throw new Error("Field doesn't support isOdd");return!Q.isOdd(W)}equals(W){n(W);const{X:T,Y:M,Z:H}=this,{X:Z,Y:D,Z:C}=W,O=Q.eql(Q.mul(T,C),Q.mul(Z,H)),B=Q.eql(Q.mul(M,C),Q.mul(D,H));return O&&B}negate(){return new I(this.X,Q.neg(this.Y),this.Z)}double(){const{a:W,b:T}=z,M=Q.mul(T,B8),{X:H,Y:Z,Z:D}=this;let{ZERO:C,ZERO:O,ZERO:B}=Q,R=Q.mul(H,H),g=Q.mul(Z,Z),k=Q.mul(D,D),w=Q.mul(H,Z);return w=Q.add(w,w),B=Q.mul(H,D),B=Q.add(B,B),C=Q.mul(W,B),O=Q.mul(M,k),O=Q.add(C,O),C=Q.sub(g,O),O=Q.add(g,O),O=Q.mul(C,O),C=Q.mul(w,C),B=Q.mul(M,B),k=Q.mul(W,k),w=Q.sub(R,k),w=Q.mul(W,w),w=Q.add(w,B),B=Q.add(R,R),R=Q.add(B,R),R=Q.add(R,k),R=Q.mul(R,w),O=Q.add(O,R),k=Q.mul(Z,D),k=Q.add(k,k),R=Q.mul(k,w),C=Q.sub(C,R),B=Q.mul(k,g),B=Q.add(B,B),B=Q.add(B,B),new I(C,O,B)}add(W){n(W);const{X:T,Y:M,Z:H}=this,{X:Z,Y:D,Z:C}=W;let{ZERO:O,ZERO:B,ZERO:R}=Q;const g=z.a,k=Q.mul(z.b,B8);let w=Q.mul(T,Z),P=Q.mul(M,D),v=Q.mul(H,C),_=Q.add(T,M),y=Q.add(Z,D);_=Q.mul(_,y),y=Q.add(w,P),_=Q.sub(_,y),y=Q.add(T,H);let u=Q.add(Z,C);return y=Q.mul(y,u),u=Q.add(w,v),y=Q.sub(y,u),u=Q.add(M,H),O=Q.add(D,C),u=Q.mul(u,O),O=Q.add(P,v),u=Q.sub(u,O),R=Q.mul(g,y),O=Q.mul(k,v),R=Q.add(O,R),O=Q.sub(P,R),R=Q.add(P,R),B=Q.mul(O,R),P=Q.add(w,w),P=Q.add(P,w),v=Q.mul(g,v),y=Q.mul(k,y),P=Q.add(P,v),v=Q.sub(w,v),v=Q.mul(g,v),y=Q.add(y,v),w=Q.mul(P,y),B=Q.add(B,w),w=Q.mul(u,y),O=Q.mul(_,O),O=Q.sub(O,w),w=Q.mul(_,P),R=Q.mul(u,R),R=Q.add(R,w),new I(O,B,R)}subtract(W){return this.add(W.negate())}is0(){return this.equals(I.ZERO)}multiply(W){const{endo:T}=J;if(!G.isValidNot0(W))throw new Error("invalid scalar: out of range");let M,H;const Z=(D)=>S.cached(this,D,(C)=>C8(I,C));if(T){const{k1neg:D,k1:C,k2neg:O,k2:B}=c(W),{p:R,f:g}=Z(C),{p:k,f:w}=Z(B);H=g.add(w),M=G0(T.beta,R,k,D,O)}else{const{p:D,f:C}=Z(W);M=D,H=C}return C8(I,[M,H])[0]}multiplyUnsafe(W){const{endo:T}=J,M=this;if(!G.isValid(W))throw new Error("invalid scalar: out of range");if(W===W0||M.is0())return I.ZERO;if(W===y0)return M;if(S.hasCache(this))return this.multiply(W);if(T){const{k1neg:H,k1:Z,k2neg:D,k2:C}=c(W),{p1:O,p2:B}=f$(I,M,Z,C);return G0(T.beta,O,B,H,D)}else return S.unsafe(M,W)}multiplyAndAddUnsafe(W,T,M){const H=this.multiplyUnsafe(T).add(W.multiplyUnsafe(M));return H.is0()?void 0:H}toAffine(W){return s(this,W)}isTorsionFree(){const{isTorsionFree:W}=J;if(U===y0)return!0;if(W)return W(I,this);return S.unsafe(this,Y).is0()}clearCofactor(){const{clearCofactor:W}=J;if(U===y0)return this;if(W)return W(I,this);return this.multiplyUnsafe(U)}isSmallOrder(){return this.multiplyUnsafe(U).is0()}toBytes(W=!0){return i0(W,"isCompressed"),this.assertValidity(),K(I,this,W)}toHex(W=!0){return Z0(this.toBytes(W))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(W=!0){return this.toBytes(W)}_setWindowSize(W){this.precompute(W)}static normalizeZ(W){return C8(I,W)}static msm(W,T){return _$(I,G,W,T)}static fromPrivateKey(W){return I.BASE.multiply(L0(G,W))}}I.BASE=new I(z.Gx,z.Gy,Q.ONE),I.ZERO=new I(Q.ZERO,Q.ONE,Q.ZERO),I.Fp=Q,I.Fn=G;const X0=G.BITS,S=new i8(I,J.endo?Math.ceil(X0/2):X0);return I.BASE.precompute(8),I}var m$=function($){return Uint8Array.of($?2:3)};var F$=function($,J){return{secretKey:J.BYTES,publicKey:1+$.BYTES,publicKeyUncompressed:1+2*$.BYTES,publicKeyHasPrefix:!0,signature:2*J.BYTES}};function hQ($,J={}){const{Fn:q}=$,Q=J.randomBytes||P0,G=Object.assign(F$($.Fp,q),{seed:d8(q.ORDER)});function z(K){try{return!!L0(q,K)}catch(x){return!1}}function U(K,x){const{publicKey:A,publicKeyUncompressed:E}=G;try{const f=K.length;if(x===!0&&f!==A)return!1;if(x===!1&&f!==E)return!1;return!!$.fromBytes(K)}catch(f){return!1}}function Y(K=Q(G.seed)){return V8(O0(K,G.seed,"seed"),q.ORDER)}function X(K,x=!0){return $.BASE.multiply(L0(q,K)).toBytes(x)}function V(K){const x=Y(K);return{secretKey:x,publicKey:X(x)}}function N(K){if(typeof K==="bigint")return!1;if(K instanceof $)return!0;const{secretKey:x,publicKey:A,publicKeyUncompressed:E}=G;if(q.allowedLengths||x===A)return;const f=m("key",K).length;return f===A||f===E}function L(K,x,A=!0){if(N(K)===!0)throw new Error("first arg must be private key");if(N(x)===!1)throw new Error("second arg must be public key");const E=L0(q,K);return $.fromHex(x).multiply(E).toBytes(A)}return Object.freeze({getPublicKey:X,getSharedSecret:L,keygen:V,Point:$,utils:{isValidSecretKey:z,isValidPublicKey:U,randomSecretKey:Y,isValidPrivateKey:z,randomPrivateKey:Y,normPrivateKeyToScalar:(K)=>L0(q,K),precompute(K=8,x=$.BASE){return x.precompute(K,!1)}},lengths:G})}function lQ($,J,q={}){Y8(J),s0(q,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const Q=q.randomBytes||P0,G=q.hmac||((M,...H)=>b8(J,M,o(...H))),{Fp:z,Fn:U}=$,{ORDER:Y,BITS:X}=U,{keygen:V,getPublicKey:N,getSharedSecret:L,utils:j,lengths:K}=hQ($,q),x={prehash:!1,lowS:typeof q.lowS==="boolean"?q.lowS:!1,format:void 0,extraEntropy:!1},A="compact";function E(M){const H=Y>>y0;return M>H}function f(M,H){if(!U.isValidNot0(H))throw new Error(`invalid signature ${M}: out of range 1..Point.Fn.ORDER`);return H}function q0(M,H){n8(H);const Z=K.signature,D=H==="compact"?Z:H==="recovered"?Z+1:void 0;return O0(M,D,`${H} signature`)}class b{constructor(M,H,Z){if(this.r=f("r",M),this.s=f("s",H),Z!=null)this.recovery=Z;Object.freeze(this)}static fromBytes(M,H=A){q0(M,H);let Z;if(H==="der"){const{r:B,s:R}=D0.toSig(O0(M));return new b(B,R)}if(H==="recovered")Z=M[0],H="compact",M=M.subarray(1);const D=U.BYTES,C=M.subarray(0,D),O=M.subarray(D,D*2);return new b(U.fromBytes(C),U.fromBytes(O),Z)}static fromHex(M,H){return this.fromBytes(S0(M),H)}addRecoveryBit(M){return new b(this.r,this.s,M)}recoverPublicKey(M){const H=z.ORDER,{r:Z,s:D,recovery:C}=this;if(C==null||![0,1,2,3].includes(C))throw new Error("recovery id invalid");if(Y*u$<H&&C>1)throw new Error("recovery id is ambiguous for h>1 curve");const B=C===2||C===3?Z+Y:Z;if(!z.isValid(B))throw new Error("recovery id 2 or 3 invalid");const R=z.toBytes(B),g=$.fromBytes(o(m$((C&1)===0),R)),k=U.inv(B),w=c(m("msgHash",M)),P=U.create(-w*k),v=U.create(D*k),_=$.BASE.multiplyUnsafe(P).add(g.multiplyUnsafe(v));if(_.is0())throw new Error("point at infinify");return _.assertValidity(),_}hasHighS(){return E(this.s)}toBytes(M=A){if(n8(M),M==="der")return S0(D0.hexFromSig(this));const H=U.toBytes(this.r),Z=U.toBytes(this.s);if(M==="recovered"){if(this.recovery==null)throw new Error("recovery bit must be present");return o(Uint8Array.of(this.recovery),H,Z)}return o(H,Z)}toHex(M){return Z0(this.toBytes(M))}assertValidity(){}static fromCompact(M){return b.fromBytes(m("sig",M),"compact")}static fromDER(M){return b.fromBytes(m("sig",M),"der")}normalizeS(){return this.hasHighS()?new b(this.r,U.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return Z0(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return Z0(this.toBytes("compact"))}}const n=q.bits2int||function M(H){if(H.length>8192)throw new Error("input is too large");const Z=M0(H),D=H.length*8-X;return D>0?Z>>BigInt(D):Z},c=q.bits2int_modN||function M(H){return U.create(n(H))},s=x0(X);function C0(M){return V$("num < 2^"+X,M,W0,s),U.toBytes(M)}function G0(M,H){return O0(M,void 0,"message"),H?O0(J(M),void 0,"prehashed message"):M}function I(M,H,Z){if(["recovered","canonical"].some((v)=>(v in Z)))throw new Error("sign() legacy options not supported");const{lowS:D,prehash:C,extraEntropy:O}=a8(Z,x);M=G0(M,C);const B=c(M),R=L0(U,H),g=[C0(R),C0(B)];if(O!=null&&O!==!1){const v=O===!0?Q(K.secretKey):O;g.push(m("extraEntropy",v))}const k=o(...g),w=B;function P(v){const _=n(v);if(!U.isValidNot0(_))return;const y=U.inv(_),u=$.BASE.multiply(_).toAffine(),F=U.create(u.x);if(F===W0)return;const t=U.create(y*U.create(w+F*R));if(t===W0)return;let z0=(u.x===F?0:2)|Number(u.y&y0),p=t;if(D&&E(t))p=U.neg(t),z0^=1;return new b(F,p,z0)}return{seed:k,k2sig:P}}function X0(M,H,Z={}){M=m("message",M);const{seed:D,k2sig:C}=I(M,H,Z);return C$(J.outputLen,U.BYTES,G)(D,C)}function S(M){let H=void 0;const Z=typeof M==="string"||I0(M),D=!Z&&M!==null&&typeof M==="object"&&typeof M.r==="bigint"&&typeof M.s==="bigint";if(!Z&&!D)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(D)H=new b(M.r,M.s);else if(Z){try{H=b.fromBytes(m("sig",M),"der")}catch(C){if(!(C instanceof D0.Err))throw C}if(!H)try{H=b.fromBytes(m("sig",M),"compact")}catch(C){return!1}}if(!H)return!1;return H}function W(M,H,Z,D={}){const{lowS:C,prehash:O,format:B}=a8(D,x);if(Z=m("publicKey",Z),H=G0(m("message",H),O),("strict"in D))throw new Error("options.strict was renamed to lowS");const R=B===void 0?S(M):b.fromBytes(m("sig",M),B);if(R===!1)return!1;try{const g=$.fromBytes(Z);if(C&&R.hasHighS())return!1;const{r:k,s:w}=R,P=c(H),v=U.inv(w),_=U.create(P*v),y=U.create(k*v),u=$.BASE.multiplyUnsafe(_).add(g.multiplyUnsafe(y));if(u.is0())return!1;return U.create(u.x)===k}catch(g){return!1}}function T(M,H,Z={}){const{prehash:D}=a8(Z,x);return H=G0(H,D),b.fromBytes(M,"recovered").recoverPublicKey(H).toBytes()}return Object.freeze({keygen:V,getPublicKey:N,getSharedSecret:L,utils:j,lengths:K,Point:$,sign:X0,verify:W,recoverPublicKey:T,Signature:b,hash:J})}var cQ=function($){const J={a:$.a,b:$.b,p:$.Fp.ORDER,n:$.n,h:$.h,Gx:$.Gx,Gy:$.Gy},q=$.Fp;let Q=$.allowedPrivateKeyLengths?Array.from(new Set($.allowedPrivateKeyLengths.map((U)=>Math.ceil(U/2)))):void 0;const G=T0(J.n,{BITS:$.nBitLength,allowedLengths:Q,modFromBytes:$.wrapPrivateKey}),z={Fp:q,Fn:G,allowInfinityPoint:$.allowInfinityPoint,endo:$.endo,isTorsionFree:$.isTorsionFree,clearCofactor:$.clearCofactor,fromBytes:$.fromBytes,toBytes:$.toBytes};return{CURVE:J,curveOpts:z}},dQ=function($){const{CURVE:J,curveOpts:q}=cQ($),Q={hmac:$.hmac,randomBytes:$.randomBytes,lowS:$.lowS,bits2int:$.bits2int,bits2int_modN:$.bits2int_modN};return{CURVE:J,curveOpts:q,hash:$.hash,ecdsaOpts:Q}};var oQ=function($,J){const q=J.Point;return Object.assign({},J,{ProjectivePoint:q,CURVE:Object.assign({},$,N8(q.Fn.ORDER,q.Fn.BITS))})};function h$($){const{CURVE:J,curveOpts:q,hash:Q,ecdsaOpts:G}=dQ($),z=FQ(J,q),U=lQ(z,Q,G);return oQ($,U)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var g$=($,J)=>($+($>=0?J:-J)/u$)/J;class y$ extends Error{constructor($=""){super($)}}var D0={Err:y$,_tlv:{encode:($,J)=>{const{Err:q}=D0;if($<0||$>256)throw new q("tlv.encode: wrong tag");if(J.length&1)throw new q("tlv.encode: unpadded data");const Q=J.length/2,G=a0(Q);if(G.length/2&128)throw new q("tlv.encode: long form length too big");const z=Q>127?a0(G.length/2|128):"";return a0($)+z+G+J},decode($,J){const{Err:q}=D0;let Q=0;if($<0||$>256)throw new q("tlv.encode: wrong tag");if(J.length<2||J[Q++]!==$)throw new q("tlv.decode: wrong tlv");const G=J[Q++],z=!!(G&128);let U=0;if(!z)U=G;else{const X=G&127;if(!X)throw new q("tlv.decode(long): indefinite length not supported");if(X>4)throw new q("tlv.decode(long): byte length is too big");const V=J.subarray(Q,Q+X);if(V.length!==X)throw new q("tlv.decode: length bytes not complete");if(V[0]===0)throw new q("tlv.decode(long): zero leftmost byte");for(let N of V)U=U<<8|N;if(Q+=X,U<128)throw new q("tlv.decode(long): not minimal encoding")}const Y=J.subarray(Q,Q+U);if(Y.length!==U)throw new q("tlv.decode: wrong value length");return{v:Y,l:J.subarray(Q+U)}}},_int:{encode($){const{Err:J}=D0;if($<W0)throw new J("integer: negative integers are not allowed");let q=a0($);if(Number.parseInt(q[0],16)&8)q="00"+q;if(q.length&1)throw new J("unexpected DER parsing assertion: unpadded hex");return q},decode($){const{Err:J}=D0;if($[0]&128)throw new J("invalid signature integer: negative");if($[0]===0&&!($[1]&128))throw new J("invalid signature integer: unnecessary leading zero");return M0($)}},toSig($){const{Err:J,_int:q,_tlv:Q}=D0,G=m("signature",$),{v:z,l:U}=Q.decode(48,G);if(U.length)throw new J("invalid signature: left bytes after parsing");const{v:Y,l:X}=Q.decode(2,z),{v:V,l:N}=Q.decode(2,X);if(N.length)throw new J("invalid signature: left bytes after parsing");return{r:q.decode(Y),s:q.decode(V)}},hexFromSig($){const{_tlv:J,_int:q}=D0,Q=J.encode(2,q.encode($.r)),G=J.encode(2,q.encode($.s)),z=Q+G;return J.encode(48,z)}},W0=BigInt(0),y0=BigInt(1),u$=BigInt(2),B8=BigInt(3),mQ=BigInt(4);function l$($,J){const q=(Q)=>h$({...$,hash:Q});return{...q(J),create:q}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var iQ=function($){const J=u0.p,q=BigInt(3),Q=BigInt(6),G=BigInt(11),z=BigInt(22),U=BigInt(23),Y=BigInt(44),X=BigInt(88),V=$*$*$%J,N=V*V*$%J,L=a(N,q,J)*N%J,j=a(L,q,J)*N%J,K=a(j,s8,J)*V%J,x=a(K,G,J)*K%J,A=a(x,z,J)*x%J,E=a(A,Y,J)*A%J,f=a(E,X,J)*E%J,q0=a(f,Y,J)*A%J,b=a(q0,q,J)*N%J,n=a(b,U,J)*x%J,c=a(n,Q,J)*V%J,s=a(c,s8,J);if(!H8.eql(H8.sqr(s),$))throw new Error("Cannot find square root");return s},O8=function($,...J){let q=d$[$];if(q===void 0){const Q=M8(K8($));q=o(Q,Q),d$[$]=q}return M8(o(q,...J))},t8=function($){const{Fn:J,BASE:q}=m0,Q=L0(J,$),G=q.multiply(Q);return{scalar:$$(G.y)?Q:J.neg(Q),bytes:e8(G)}},p$=function($){const J=H8;if(!J.isValidNot0($))throw new Error("invalid x: Fail if x \u2265 p");const q=J.create($*$),Q=J.create(q*$+BigInt(7));let G=J.sqrt(Q);if(!$$(G))G=J.neg(G);const z=m0.fromAffine({x:$,y:G});return z.assertValidity(),z},i$=function(...$){return m0.Fn.create(e0(O8("BIP0340/challenge",...$)))},o$=function($){return t8($).bytes},aQ=function($,J,q=P0(32)){const{Fn:Q}=m0,G=m("message",$),{bytes:z,scalar:U}=t8(J),Y=m("auxRand",q,32),X=Q.toBytes(U^e0(O8("BIP0340/aux",Y))),V=O8("BIP0340/nonce",X,z,G),{bytes:N,scalar:L}=t8(V),j=i$(N,z,G),K=new Uint8Array(64);if(K.set(N,0),K.set(Q.toBytes(Q.create(L+j*U)),32),!a$(K,G,z))throw new Error("sign: Invalid signature produced");return K},a$=function($,J,q){const{Fn:Q,BASE:G}=m0,z=m("signature",$,64),U=m("message",J),Y=m("publicKey",q,32);try{const X=p$(e0(Y)),V=e0(z.subarray(0,32));if(!n0(V,c$,u0.p))return!1;const N=e0(z.subarray(32,64));if(!n0(N,c$,u0.n))return!1;const L=i$(Q.toBytes(V),e8(X),U),j=G.multiplyUnsafe(N).add(X.multiplyUnsafe(Q.neg(L))),{x:K,y:x}=j.toAffine();if(j.is0()||!$$(x)||K!==V)return!1;return!0}catch(X){return!1}};/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var u0={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},rQ={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},pQ=BigInt(0),c$=BigInt(1),s8=BigInt(2),H8=T0(u0.p,{sqrt:iQ}),r$=l$({...u0,Fp:H8,lowS:!0,endo:rQ},M8),d$={},e8=($)=>$.toBytes(!0).slice(1),m0=(()=>r$.Point)(),$$=($)=>$%s8===pQ,e0=M0,x8=(()=>{const q=(G=P0(48))=>{return V8(G,u0.n)};r$.utils.randomSecretKey;function Q(G){const z=q(G);return{secretKey:z,publicKey:o$(z)}}return{keygen:Q,getPublicKey:o$,sign:aQ,verify:a$,Point:m0,utils:{randomSecretKey:q,randomPrivateKey:q,taggedHash:O8,lift_x:p$,pointToBytes:e8,numberToBytesBE:b0,bytesToNumberBE:M0,mod:i},lengths:{secretKey:32,publicKey:32,publicKeyHasPrefix:!1,signature:64,seed:48}}})();var nQ=new TextEncoder,sQ=new TextDecoder,j0=($)=>nQ.encode($),f0=($)=>sQ.decode($),T8=($)=>Array.from($,(J)=>J.toString(16).padStart(2,"0")).join(""),e=JSON.stringify,R0=JSON.parse,L8=($,J=Number.MAX_SAFE_INTEGER)=>$.split("").reduce((q,Q)=>q+Q.charCodeAt(0),0)%J;var Q$="AES-GCM",tQ={},n$="$",s$=",",eQ=($)=>{const J=new Uint8Array($);let Q="";for(let G=0;G<J.length;G+=32768)Q+=String.fromCharCode(...J.subarray(G,G+32768));return btoa(Q)},$J=($)=>Uint8Array.from(atob($),(J)=>J.charCodeAt(0)).buffer,$8=($)=>tQ[$]??=crypto.subtle.digest("SHA-1",j0($)).then((J)=>{const q=new Uint8Array(J);let Q="";for(let G of q)Q+=G.toString(36);return Q}),t$=async($,J,q)=>{const Q=await crypto.subtle.digest("SHA-256",j0(`${$}:${J}:${q}`));return crypto.subtle.importKey("raw",Q,{name:Q$},!1,["encrypt","decrypt"])},e$=async($,J)=>{const q=crypto.getRandomValues(new Uint8Array(12)),Q=await $,G=await crypto.subtle.encrypt({name:Q$,iv:q},Q,j0(J));return`${q.join(s$)}${n$}${eQ(G)}`},$Q=async($,J)=>{const[q,Q]=J.split(n$);if(!q||!Q)throw new Error("Invalid encrypted payload format");const G=Uint8Array.from(q.split(s$),Number),z=await $,U=await crypto.subtle.decrypt({name:Q$,iv:G},z,$J(Q));return f0(U)};var r="GenosRTC",F0=($,J)=>Array.from({length:$},J);var Q8=($)=>Array.from(crypto.getRandomValues(new Uint8Array($)),(J)=>"0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz"[J%"0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz".length]).join(""),N0=Q8(20),V0=Promise.all.bind(Promise),QQ=typeof window!=="undefined",{entries:JQ,fromEntries:R8,keys:J1}=Object,qQ=()=>{},J0=($)=>new Error(`GenosRTC: ${$}`),J8=(...$)=>$.join("@"),GQ=($,J)=>{const q=[...$];let Q=q.length;const G=()=>{const z=Math.sin(J++)*1e4;return z-Math.floor(z)};while(Q){const z=Math.floor(G()*Q--);[q[Q],q[z]]=[q[z],q[Q]]}return q};var QJ=5000,zQ="icegatheringstatechange",UQ="offer",JJ="answer",qJ=[...F0(3,($,J)=>`stun:stun${J||""}.l.google.com:19302`),"stun:stun.cloudflare.com:3478"].map(($)=>({urls:$})),A8=($,{rtcConfig:J,rtcPolyfill:q,turnConfig:Q})=>{const G=new(q||RTCPeerConnection)({iceServers:[...qJ,...Q||[]],...J}),z={};let U=!1,Y=!1,X;const V=(j)=>Object.assign(j,{binaryType:"arraybuffer",bufferedAmountLowThreshold:65535,onmessage:(K)=>z.data?.(K.data),onopen:()=>z.connect?.(),onclose:()=>z.close?.(),onerror:(K)=>!K?.error?.message?.includes("User-Initiated Abort")&&z.error?.(K)}),N=()=>Promise.race([new Promise((j)=>{const K=()=>{if(G.iceGatheringState==="complete")G.removeEventListener(zQ,K),j()};G.addEventListener(zQ,K),K()}),new Promise((j)=>setTimeout(j,QJ))]).then(()=>({type:G.localDescription.type,sdp:G.localDescription.sdp.replace(/a=ice-options:trickle\s\n/g,"")}));if($?V(X=G.createDataChannel("data")):G.ondatachannel=({channel:j})=>V(X=j),G.onnegotiationneeded=async()=>{try{U=!0,await G.setLocalDescription(),z.signal?.(await N())}catch(j){z.error?.(j)}finally{U=!1}},G.onconnectionstatechange=()=>{if(["disconnected","failed","closed"].includes(G.connectionState))z.close?.()},G.ontrack=(j)=>{z.track?.(j.track,j.streams[0]),z.stream?.(j.streams[0])},G.onremovestream=(j)=>z.stream?.(j.stream),$&&!G.canTrickleIceCandidates)G.onnegotiationneeded();const L=()=>G.getSenders();return{created:Date.now(),connection:G,get channel(){return X},get isDead(){return G.connectionState==="closed"},async signal(j){if(X?.readyState==="open"&&!j.sdp?.includes("a=rtpmap"))return;try{if(j.type===UQ){if(U||G.signalingState!=="stable"&&!Y){if($)return;await V0([G.setLocalDescription({type:"rollback"}),G.setRemoteDescription(j)])}else await G.setRemoteDescription(j);await G.setLocalDescription();const K=await N();return z.signal?.(K),K}if(j.type===JJ){Y=!0;try{await G.setRemoteDescription(j)}finally{Y=!1}}}catch(K){z.error?.(K)}},sendData:(j)=>X.send(j),destroy:()=>{X?.close(),G.close(),U=Y=!1},setHandlers:(j)=>Object.assign(z,j),offerPromise:$?new Promise((j)=>z.signal=(K)=>K.type===UQ&&j(K)):Promise.resolve(),addStream:(j)=>j.getTracks().forEach((K)=>G.addTrack(K,j)),removeStream:(j)=>L().filter((K)=>j.getTracks().includes(K.track)).forEach((K)=>G.removeTrack(K)),addTrack:(j,K)=>G.addTrack(j,K),removeTrack:(j)=>{const K=L().find((x)=>x.track===j);if(K)G.removeTrack(K)},replaceTrack:(j,K)=>L().find((x)=>x.track===j)?.replaceTrack(K)}};var GJ=Object.getPrototypeOf(Uint8Array),I8=12,jQ=0,k8=jQ+I8,S8=k8+1,G8=S8+1,z8=G8+1,q8=16384-z8,w8=255,J$="bufferedamountlow",h0=($)=>`@_${$}`,q$=100,zJ=3,UJ=200,XQ=($,J,q)=>{const Q=new Map,G=new Map,z=new Map,U={},Y={},X={},V={},N=new Map,L=(Z,D)=>{if(!N.has(Z))N.set(Z,new Set);N.get(Z).add(D)},j=(Z,D)=>N.get(Z)?.delete(D),K=(Z,...D)=>N.get(Z)?.forEach((C)=>C(...D)),x=(Z,D)=>{const C=Z?Array.isArray(Z)?Z:[Z]:Q.keys();return Array.from(C,(O)=>{const B=Q.get(O);if(!B)return console.warn(`${r}: no peer with id ${O}`),null;return D(O,B)}).filter(Boolean)},A=(Z)=>{if(!Q.has(Z))return;Q.delete(Z),delete U[Z],delete Y[Z],delete X[Z],delete V[Z],K("peer:leave",Z),J(Z)},E=(Z)=>new Promise((D,C)=>{let O=setTimeout(()=>{Z.removeEventListener(J$,B),C(new Error(`${r}: bufferLow timeout`))},5000);function B(){clearTimeout(O),Z.removeEventListener(J$,B),D()}Z.addEventListener(J$,B)}),f=(Z)=>{if(z.has(Z))return z.get(Z);if(!Z)throw J0("action type is required");const D=j0(Z);if(D.byteLength>I8)throw J0(`\u274C "${Z}" exceeds ${I8} bytes. Use a shorter name.`);const C=new Uint8Array(I8).map((P,v)=>D[v]||0);let O=0;const B=new Map([["message",new Set],["progress",new Set]]),R=(P,v)=>B.get(P)?.add(v),g=(P,v)=>B.get(P)?.delete(v),k=async(P,v,_,y)=>{if(_&&typeof _!=="object")throw J0("meta must be object");if(P===void 0)throw J0("data cannot be undefined");const u=P instanceof Blob,F=u||P instanceof ArrayBuffer||P instanceof GJ,t=typeof P!=="string";if(_&&!F)throw J0("meta only allowed with binary");const z0=F?new Uint8Array(u?await P.arrayBuffer():P):j0(t?e(P):P),p=_?j0(e(_)):null,d=Math.ceil(z0.byteLength/q8)+(_?1:0)||1;if(d>q$)throw J0(`Message too large, exceeds max chunks ${q$}`);const j$=F0(d,(j8,U0)=>{const d0=U0===d-1,A0=_&&U0===0,X8=A0?p:z0.subarray(_?(U0-1)*q8:U0*q8,_?U0*q8:(U0+1)*q8),B0=new Uint8Array(z8+X8.byteLength);return B0.set(C),B0.set([O],k8),B0.set([d0|A0<<1|F<<2|t<<3],S8),B0.set([Math.round((U0+1)/d*w8)],G8),B0.set(X8,z8),B0});return O=O+1&w8,V0(x(v,async(j8,U0)=>{const{channel:d0}=U0;for(let A0=0;A0<d;A0++){let X8=0;while(d0.bufferedAmount>d0.bufferedAmountLowThreshold){if(X8++>zJ)throw J0(`${r}: send buffer full, max retries reached for peer ${j8}`);try{await E(d0)}catch(B0){console.warn(B0.message),await new Promise((AQ)=>setTimeout(AQ,UJ))}}if(!Q.has(j8))break;U0.sendData(j$[A0]),y?.(j$[A0][G8]/w8,j8,_)}}))};G.set(Z,{listeners:B,send:k});const w={send:k,on:R,off:g};return z.set(Z,w),w},q0=(Z,D)=>{try{const C=new Uint8Array(D),O=f0(C.subarray(jQ,k8)).replace(/ /g,"");if(!G.has(O))return console.warn(`${r}: unregistered type (${O})`);const[B]=C.subarray(k8,S8),[R]=C.subarray(S8,G8),[g]=C.subarray(G8,z8),k=C.subarray(z8),w=Boolean(R&1),P=Boolean(R&2),v=Boolean(R&4),_=Boolean(R&8),y=G.get(O),u=(U[Z]||={})[O]||={};if(u[B]?.chunks?.length>q$){console.warn(`${r}: peer ${Z} sent too many chunks for nonce ${B}, ignoring.`);return}const F=u[B]||={chunks:[]};if(P)try{F.meta=R0(f0(k))}catch{console.warn(`${r}: failed to parse meta from peer ${Z} for type ${O}`);return}else F.chunks.push(k);if(y.listeners.get("progress").forEach((p)=>{try{p(g/w8,Z,F.meta)}catch(d){console.error(d)}}),!w)return;const t=new Uint8Array(F.chunks.reduce((p,d)=>p+d.byteLength,0));F.chunks.reduce((p,d)=>(t.set(d,p),p+d.byteLength),0),delete u[B];let z0;if(v)z0=t;else if(_)try{z0=R0(f0(t))}catch{console.warn(`${r}: failed to parse JSON message data from peer ${Z} for type ${O}`);return}else z0=f0(t);y.listeners.get("message").forEach((p)=>{try{p(z0,Z,F.meta)}catch(d){console.error(d)}})}catch(C){console.error(`${r}: error handling data from peer ${Z}:`,C)}},b=async()=>{try{await M(""),await new Promise((Z)=>setTimeout(Z,99))}catch(Z){console.warn(`${r}: error sending leave`,Z)}for(let[Z,D]of Q){try{D.destroy()}catch{}Q.delete(Z)}q()},{send:n,on:c}=f(h0("ping")),{send:s,on:C0}=f(h0("pong")),{send:G0,on:I}=f(h0("signal")),{send:X0,on:S}=f(h0("stream")),{send:W,on:T}=f(h0("track")),{send:M,on:H}=f(h0("leave"));if($((Z,D)=>{if(Q.has(D))return;Q.set(D,Z),Z.setHandlers({data:(C)=>q0(D,C),stream:(C)=>{K("stream:add",C,D,X[D]),delete X[D]},track:(C,O)=>{K("track:add",C,O,D,V[D]),delete V[D]},signal:(C)=>G0(C,D),close:()=>A(D),error:(C)=>{console.error(`${r}: peer error for ${D}`,C),A(D)}}),K("peer:join",D)}),c("message",(Z,D)=>s("",D)),C0("message",(Z,D)=>{Y[D]?.(),delete Y[D]}),I("message",(Z,D)=>Q.get(D)?.signal(Z)),S("message",(Z,D)=>X[D]=Z),T("message",(Z,D)=>V[D]=Z),H("message",(Z,D)=>A(D)),QQ)addEventListener("beforeunload",b);return{on:L,off:j,channel:f,leave:b,ping:async(Z)=>{if(!Z)throw J0("ping() requires target peer ID");const D=Date.now();return n("",Z),await new Promise((C)=>Y[Z]=C),Date.now()-D},getPeers:()=>R8(Array.from(Q,([Z,D])=>[Z,D.connection])),addStream:(Z,D,C)=>x(D,async(O,B)=>{if(C)await X0(C,O);B.addStream(Z)}),removeStream:(Z,D)=>x(D,(C,O)=>O.removeStream(Z)),addTrack:(Z,D,C,O)=>x(C,async(B,R)=>{if(O)await W(O,B);R.addTrack(Z,D)}),removeTrack:(Z,D)=>x(D,(C,O)=>O.removeTrack(Z)),replaceTrack:(Z,D,C,O)=>x(C,async(B,R)=>{if(O)await W(O,B);R.replaceTrack(Z,D)})}};var jJ=20,XJ=5333,YQ=57333,ZQ=({init:$,subscribe:J,announce:q})=>{const Q={};let G=!1,z,U;return(Y,X,V)=>{const{appId:N}=Y;if(Q[N]?.[X])return Q[N][X];if(!Y||!X||!N&&!Y.firebaseApp)throw J0(!Y?"config required":!X?"roomId required":"appId missing");let L=qQ;if(!G){const S=$(Y);U=F0(jJ,()=>A8(!0,Y)),z=Array.isArray(S)?S:[S];const W=setInterval(()=>{U=U.filter((T)=>{const M=Date.now()-T.created<YQ;if(!M)T.destroy();return M})},YQ);Q.offerCleanupTimer||=W,G=!0}const j={},K={},x=J8(r,N,X),A=$8(x),E=$8(J8(x,N0)),f=t$(Y.password||"",N,X),q0=(S)=>async(W)=>({type:W.type,sdp:await S(f,W.sdp)}),b=q0($Q),n=q0(e$),c=(S,W)=>{if(K[W]===S)return;K[W]?.destroy(),K[W]=S,L(S,W),j[W]?.forEach((T)=>T!==S&&T.destroy()),delete j[W]},s=(S,W)=>{if(K[W]===S)delete K[W]},C0=(S)=>async(W,T,M)=>{const[H,Z]=await V0([A,E]);if(W!==H&&W!==Z)return;const{peerId:D,offer:C,answer:O}=typeof T==="string"?R0(T):T;if(D===N0||K[D])return;if(C){if(j[D]?.[S]&&N0>D)return;const B=A8(!1,Y);B.setHandlers({connect:()=>c(B,D),close:()=>s(B,D)});try{const R=await b(C);if(B.isDead)return;const[g,k]=await V0([$8(J8(x,D)),B.signal(R).then(n)]);M(g,e({peerId:N0,answer:k}))}catch{V?.({error:"decryption failed (offer)",appId:N,peerId:D,roomId:X})}}else if(O){const B=j[D]?.[S];if(!B||B.isDead)return;B.setHandlers({connect:()=>c(B,D),close:()=>s(B,D)});try{B.signal(await b(O))}catch{V?.({error:"decryption failed (answer)",appId:N,peerId:D,roomId:X})}}else{if(j[D]?.[S])return;const B=U.pop()||A8(!0,Y),[R,{offer:g}]=await V0([$8(J8(x,D)),B.offerPromise.then(n).then((k)=>({offer:k}))]);j[D]||=[],j[D][S]=B,B.setHandlers({connect:()=>c(B,D),close:()=>s(B,D)}),M(R,e({peerId:N0,offer:g,peer:B}))}},G0=V0(z.map(async(S,W)=>J(await S,await A,await E,C0(W)))),I=[];G0.then((S)=>{z.forEach((W,T)=>{const M=async()=>{const H=await q(await W,await A,await E);I[T]=setTimeout(M,typeof H==="number"?H:XJ)};M()}),Q[N][X].onCleanup=()=>{if(delete Q[N][X],I.forEach(clearTimeout),S.forEach((W)=>W()),Object.keys(Q).length===0)clearInterval(Q.offerCleanupTimer),delete Q.offerCleanupTimer}}),Q[N]||={};const X0=XQ((S)=>L=S,(S)=>delete K[S],()=>X0.onCleanup?.());return Q[N][X]=X0}};var KQ=3333,P8={},MQ={},G$=($,J)=>{const q={};let Q=null;const G=()=>{if(Q)clearTimeout(Q),Q=null;const z=new WebSocket($);z.onclose=()=>{P8[$]??=KQ,Q=setTimeout(G,P8[$]),P8[$]*=2},z.onmessage=(U)=>J(U.data),q.socket=z,q.url=z.url,q.ready=new Promise((U)=>{z.onopen=()=>{P8[$]=KQ,U(q)}}),q.send=(U)=>{if(z.readyState===1)z.send(U)}};return q.forceReconnect=G,G(),MQ[$]=q,q};if(typeof window!=="undefined"){const $=()=>{console.info("\u26A1 [GenosRTC] Network event detected. Forcing reconnection\u2026"),Object.values(MQ).forEach((J)=>{if(J.socket&&J.socket.readyState!==WebSocket.OPEN&&J.socket.readyState!==WebSocket.CONNECTING)J.forceReconnect()})};window.addEventListener("online",()=>{console.info("\u2705 Reconnected to the network."),$()}),window.addEventListener("offline",async()=>{console.info("\u274C Disconnected from the network.")}),document.addEventListener("visibilitychange",()=>{if(document.visibilityState==="visible")$()})}var DQ=($)=>()=>R8(JQ($).map(([J,q])=>[J,q.socket])),z$=($,J,q,Q)=>($.relayUrls??(Q?GQ(J,L8($.appId)):J)).slice(0,$.relayUrls?.length??$.relayRedundancy??q);async function RQ(){try{const $=JSON.parse(localStorage.getItem(U8)??"[]"),J=await fetch("https://api.nostr.watch/v1/online").then((q)=>q.ok?q.json():null).catch(()=>null);if(J?.length)localStorage.setItem(U8,JSON.stringify([...new Set([...$,...J])]))}catch{}}var c0={},CQ=5,BQ="x",U$="EVENT",HQ=/pow: (\d+) bits needed\.?/,E8=new Set,OQ=x8.utils.randomSecretKey(),YJ=T8(x8.getPublicKey(OQ)),v8={},l0={},ZJ={},xQ=()=>Math.floor(Date.now()/1000),TQ=($)=>ZJ[$]??=L8($,1e4)+20000,LQ=["wss://black.nostrcity.club","wss://eu.purplerelay.com","wss://ftp.halifax.rwth-aachen.de/nostr","wss://nostr.cool110.xyz","wss://nostr.data.haus","wss://nostr.mom","wss://nostr.oxtr.dev","wss://nostr.sathoarder.com","wss://nostr.vulpem.com","wss://relay.agorist.space","wss://relay.binaryrobot.com","wss://relay.fountain.fm","wss://relay.mostro.network","wss://relay.nostraddress.com","wss://relay.nostrdice.com","wss://relay.nostromo.social","wss://relay.oldenburg.cool","wss://relay.snort.social","wss://relay.verified-nostr.com","wss://sendit.nosflare.com","wss://yabu.me/v2","wss://relay.damus.io"],U8="genosrtc_fallback_relays";if(!localStorage.getItem(U8))localStorage.setItem(U8,JSON.stringify(LQ));RQ();setInterval(RQ,7200000);var KJ=($,J,q)=>{const Q=Math.min(3000,Math.max(500,3000-q*200));setTimeout(()=>{z$($,J,CQ,!0).forEach((G)=>{if(c0[G])return;const z=G$(G,(U)=>{const[Y,X,V,N]=R0(U);if(Y!==U$){if(Y==="NOTICE"||Y==="OK"&&!V){if((Y==="NOTICE"?X:N).match(HQ)?.[1]>0)E8.add(G.replace(/\/$/,"")),z.close?.(),delete c0[G]}return}l0[X]?.(v8[X],V.content)});c0[G]=z})},Q)},WQ=async($,J)=>{const q={kind:TQ($),content:J,pubkey:YJ,created_at:xQ(),tags:[[BQ,$]]},Q=new Uint8Array(await crypto.subtle.digest("SHA-256",j0(e([0,q.pubkey,q.created_at,q.kind,q.tags,q.content])))),G=x8.sign(Q,OQ);return e([U$,{...q,id:T8(Q),sig:T8(G)}])},NQ=($,J)=>{return v8[$]=J,e(["REQ",$,{kinds:[TQ(J)],since:xQ(),["#"+BQ]:[J]}])},VQ=($)=>{return delete v8[$],e(["CLOSE",$])},MJ=ZQ({init:($)=>{const J=$?.relayUrls?.length?$.relayUrls:null,q=J??LQ,Q=JSON.parse(localStorage.getItem(U8)??"[]");if(J)console.log("[GenosRTC] Using user relay list.");const G=z$($,q,CQ,!0).map((z)=>{const U=G$(z,(Y)=>{const[X,V,N,L]=R0(Y);if(X!==U$){if(X==="NOTICE"||X==="OK"&&!N){if((X==="NOTICE"?V:L).match(HQ)?.[1]>0)E8.add(z.replace(/\/$/,"")),U.close?.(),delete c0[z]}return}l0[V]?.(v8[V],N.content)});return c0[z]=U,U.ready.then(()=>U)});return KJ($,Q,q.length),G},subscribe:($,J,q,Q)=>{const G=Q8(64),z=Q8(64);return l0[G]=l0[z]=(U,Y)=>Q(U,Y,async(X,V)=>{if(E8.has($.url.replace(/\/$/,"")))return;$.send(await WQ(X,V))}),$.send(NQ(G,J)),$.send(NQ(z,q)),()=>{$.send(VQ(G)),$.send(VQ(z)),delete l0[G],delete l0[z]}},announce:async($,J)=>{if(E8.has($.url.replace(/\/$/,"")))return;$.send(await WQ(J,e({peerId:N0})))}}),DJ=DQ(c0);export{N0 as selfId,MJ as join,DJ as getRelaySockets};
