function _1(j){const H=j.map;return j.map=async function(..._){let Z={},J=null;_.forEach((B)=>{if(typeof B==="object")Z={...Z,...B};if(typeof B==="function")J=B});let M=!1;if(Z.prompt)try{const B=await Z1(Z.prompt);if(console.log("Query generated from local DSL:",B),Z={...Z,...B},B.__nlqReturnDeepest)M=!0;delete Z.prompt}catch(B){console.error("Error parsing prompt:",B.message),Z.query={}}const G=M&&J?(B)=>{try{const f=w(B);J&&J(f)}catch{J&&J(B)}}:J,Q=await H.call(this,Z,G);if(M&&Q&&Array.isArray(Q.results))Q.results=w(Q.results);return Q},j}async function Z1(j){return j1(j)}var j1=function(j){const H=i(String(j||""));let _=x(H);const Z={query:{}},J=Z.query,M=U1(_);if(M.length){Z.$_ors=[];for(let A of M)Z.$_ors.push(A.left,A.right),_=V(_,A.span)}const F=Q1(_);if(F)J.type=F.type,Z.type=F.type,_=V(_,F.span);if(!J.type){const A=G1(_);if(A)J.type=A.type,Z.type=A.type,_=V(_,A.span)}if(!J.type){const A=W1(_);if(A)J.type=A.type,Z.type=A.type,_=V(_,A.span)}const G=B1(_);if(G&&G.edge){if(J.$edge=G.edge,G.span)_=V(_,G.span)}if(G&&G.edge&&/\bthen\s+finds?\s+(?:that\s+[A-Za-z]+s?\s+)?descendant\s+(?:named|called|with\s+name)\b/i.test(H))Z.__nlqReturnDeepest=!0;const Q=p(_);for(let A of Q){if(A.mode==="in"){const L=A.values??[A.value];J[A.field]={...J[A.field]||{},$in:L}}else J[A.field]={...J[A.field]||{},$contains:A.value};_=V(_,A.span)}const B=u(_);for(let A of B)J[A.field]={...J[A.field]||{},$regex:`^${A.value}`},_=V(_,A.span);const f=c(_);for(let A of f)J[A.field]={...J[A.field]||{},$regex:`${A.value}\$`},_=V(_,A.span);const Y=d(_);for(let A of Y)J[A.field]={...J[A.field]||{},$like:A.value},_=V(_,A.span);const z=A1(_);if(z){const A=z.value,L=[{name:{$regex:A}},{role:{$regex:A}},{level:{$regex:A}},{country:{$regex:A}},{title:{$regex:A}},{body:{$regex:A}},{tags:{$in:[A]}}];Z.query.$or=[...Z.query.$or||[],...L],_=V(_,z.span)}else if(H1(_))Z.query.__nlq_no_match="__NLQ_NO_MATCH__";const C=l(_);for(let A of C)J[A.field]={...J[A.field]||{},$exists:!0},_=V(_,A.span);const $=V1(_);if($.after)Z.$after=$.after;if($.before)Z.$before=$.before;for(let A of $.spans)_=V(_,A);const U=m(_);for(let A of U)J[A.field]=A.value,_=V(_,A.span);const N=J1(_);for(let A of N)J.name=A.value,_=V(_,A.span);const R=X1(_);for(let A of R)J.country=A.value,_=V(_,A.span);const g=a(_);for(let A of g)J[A.field]={...J[A.field]||{},$between:[A.min,A.max]},_=V(_,A.span);const W=Y1(_);for(let A of W){if(A.op==="eq")J[A.field]=A.value;else J[A.field]={...J[A.field]||{},[A.op]:A.value};_=V(_,A.span)}const D=r(_);for(let A of D){if(A.op==="eq")J[A.field]=A.value;else J[A.field]={...J[A.field]||{},[A.op]:A.value};_=V(_,A.span)}const v=n(_);for(let A of v)J[A.field]={...J[A.field]||{},$not:{$eq:A.value}},_=V(_,A.span);const q=o(_);for(let A of q){if(A.kind==="in")J.id={...J.id||{},$in:A.values};else if(A.kind==="eq")J.id=A.value;_=V(_,A.span)}const X=s(_);for(let A of X)J[A.field]={...J[A.field]||{},$in:A.values},_=V(_,A.span);const P=$1(_);if(P)Z.order=P.order,Z.field=P.field;const b=M1(_);if(b!=null)Z.$limit=b;if(Z.order&&!Z.field){const A=Object.keys(J)[0];if(A)Z.field=A}if(Object.keys(Z.query).length===0){const A=!!Z.order,L=Z.$limit!=null,h=!!(Z.$after||Z.$before);if(!A&&!L&&!h)Z.query.__nlq_no_match="__NLQ_NO_MATCH__"}if(Z.$_ors&&Z.$_ors.length)Z.query.$or=[...Z.query.$or||[],...Z.$_ors],delete Z.$_ors;return Z.query=F1(Z.query),Z},i=function(j){return j.replace(/\s+/g," ").trim()},V=function(j,H){if(!H)return j;return i(`${j.slice(0,H.start)} ${j.slice(H.end)}`)},x=function(j){const H=/^(?:searches\s+for|search\s+for|searches|search|finds?|gets?|lists?|returns?|shows?|filters?)\s+/i;return j.replace(H,"")},p=function(j){const H=[],_=[{re:/\bwhose\s+([a-z][\w\.]*)\s+(includes|including|has)\s+((?:"[^\"]+"|[A-Za-z0-9_\-]+)(?:\s*,\s*(?:"[^\"]+"|[A-Za-z0-9_\-]+))*)/ig,mode:"in",list:!0},{re:/\b([a-z][\w\.]*)\s+(includes|including|has)\s+((?:"[^\"]+"|[A-Za-z0-9_\-]+)(?:\s*,\s*(?:"[^\"]+"|[A-Za-z0-9_\-]+))*)/ig,mode:"in",list:!0},{re:/\bwhose\s+([a-z][\w\.]*)\s+(?:contains|containing)\s+(?:the\s+(?:word|phrase|number|value|text|string|token|term|email|url|date|time|datetime)s?\s*:?\s*)?"([^\"]+)"/ig,mode:"contains"},{re:/\bwhose\s+([a-z][\w\.]*)\s+(?:contains|containing)\s+(?:the\s+(?:word|phrase|number|value|text|string|token|term|email|url|date|time|datetime)s?\s*:?\s*)?([A-Za-z0-9_\-]+)/ig,mode:"contains"},{re:/\b([a-z][\w\.]*)\s+(?:contains|containing)\s+(?:the\s+(?:word|phrase|number|value|text|string|token|term|email|url|date|time|datetime)s?\s*:?\s*)?"([^\"]+)"/ig,mode:"contains"},{re:/\b([a-z][\w\.]*)\s+(?:contains|containing)\s+(?:the\s+(?:word|phrase|number|value|text|string|token|term|email|url|date|time|datetime)s?\s*:?\s*)?([A-Za-z0-9_\-]+)/ig,mode:"contains"}];for(let{re:Z,mode:J,list:M}of _){let F;while((F=Z.exec(j))!==null){const G=F[1];if(J==="in"&&M){const B=F[3].split(/\s*,\s*/).map((f)=>f.replace(/^"|"$/g,""));H.push({field:G,mode:"in",values:B,span:{start:F.index,end:F.index+F[0].length}})}else if(J==="contains"){const Q=F[2];H.push({field:G,mode:"contains",value:Q,span:{start:F.index,end:F.index+F[0].length}})}}}return H},u=function(j){const H=[],_=/\b(?:whose\s+)?([a-z][\w\.]*)\s+starts\s+with\s+"([^\"]+)"/ig;let Z;while((Z=_.exec(j))!==null)H.push({field:Z[1],value:Z[2],span:{start:Z.index,end:Z.index+Z[0].length}});const J=/\b(?:whose\s+)?([a-z][\w\.]*)\s+starts\s+with\s+([A-Za-z0-9_\-]+)/ig;while((Z=J.exec(j))!==null)H.push({field:Z[1],value:Z[2],span:{start:Z.index,end:Z.index+Z[0].length}});return H},c=function(j){const H=[],_=/\b(?:whose\s+)?([a-z][\w\.]*)\s+ends\s+with\s+"([^\"]+)"/ig;let Z;while((Z=_.exec(j))!==null)H.push({field:Z[1],value:Z[2],span:{start:Z.index,end:Z.index+Z[0].length}});const J=/\b(?:whose\s+)?([a-z][\w\.]*)\s+ends\s+with\s+([A-Za-z0-9_\-]+)/ig;while((Z=J.exec(j))!==null)H.push({field:Z[1],value:Z[2],span:{start:Z.index,end:Z.index+Z[0].length}});return H},d=function(j){const H=[];let _;const Z=/\b(?:whose\s+)?([a-z][\w\.]*)\s+like\s+"([^\"]+)"/ig;while((_=Z.exec(j))!==null)H.push({field:_[1],value:_[2],span:{start:_.index,end:_.index+_[0].length}});const J=/\b(?:whose\s+)?([a-z][\w\.]*)\s+like\s+([A-Za-z0-9_%\-\.\*]+)/ig;while((_=J.exec(j))!==null)H.push({field:_[1],value:_[2],span:{start:_.index,end:_.index+_[0].length}});return H},A1=function(j){const _=/\b(?:full[-\s]?text\s+search|text\s+search)\s+(?:"([^\"]+)"|([A-Za-z0-9_\-]+))/i.exec(j);if(_)return{value:_[1]||_[2],span:{start:_.index,end:_.index+_[0].length}};return null},H1=function(j){return/\b(?:full[-\s]?text\s+search|text\s+search|full[-\s]?text)\b/i.test(j)},n=function(j){const H=[];let _;const Z=/\b([a-z][\w\.]*)\s*(?:!=|is\s+not|not\s+equals)\s+"([^\"]+)"\b/ig;while((_=Z.exec(j))!==null)H.push({field:_[1],value:_[2],span:{start:_.index,end:_.index+_[0].length}});const J=/\b([a-z][\w\.]*)\s*(?:!=|is\s+not|not\s+equals)\s+([A-Za-z0-9_\-\.]+)\b/ig;while((_=J.exec(j))!==null)H.push({field:_[1],value:K(_[2]),span:{start:_.index,end:_.index+_[0].length}});return H},s=function(j){const H=[];let _;const Z=/\b([a-z][\w\.]*)\s+is\s+([A-Za-z0-9_\-]+)\s+or\s+([A-Za-z0-9_\-]+)(?:\s+or\s+([A-Za-z0-9_\-]+))*/ig;while((_=Z.exec(j))!==null){const M=_[1],F=_[0].replace(new RegExp(`^${_[1]}\\s+is\\s+`,"i"),"").split(/\s+or\s+/i).map((G)=>G.trim().replace(/[,\.]$/,""));H.push({field:M,values:F,span:{start:_.index,end:_.index+_[0].length}})}const J=/\b([a-z][\w\.]*)\s+in\s+((?:"[^\"]+"|[A-Za-z0-9_\-]+)(?:\s*,\s*(?:"[^\"]+"|[A-Za-z0-9_\-]+))*)/ig;while((_=J.exec(j))!==null){const M=_[1],G=_[2].split(/\s*,\s*/).map((Q)=>Q.replace(/^"|"$/g,""));H.push({field:M,values:G,span:{start:_.index,end:_.index+_[0].length}})}return H},l=function(j){const H=[];let _;const Z=/\b(?:has|with|having)\s+([a-z][\w\.]*)\b(?!\s+(?:"[^"]+"|[A-Za-z0-9_\-.]+)\b)/ig;while((_=Z.exec(j))!==null)H.push({field:_[1],span:{start:_.index,end:_.index+_[0].length}});const J=/\b(?:has|with|having)\s+([a-z][\w\.]*)\s+exists\b/ig;while((_=J.exec(j))!==null)H.push({field:_[1],span:{start:_.index,end:_.index+_[0].length}});const M=/\bwhose\s+([a-z][\w\.]*)\s+exists\b/ig;while((_=M.exec(j))!==null)H.push({field:_[1],span:{start:_.index,end:_.index+_[0].length}});const F=/\b([a-z][\w\.]*)\s+exists\b/ig;while((_=F.exec(j))!==null)H.push({field:_[1],span:{start:_.index,end:_.index+_[0].length}});return H},m=function(j){const H=[];let _;const Z=/\bwith\s+([a-z][\w\.]*)\s+("[^"]+"|[A-Za-z0-9_\-.]+)\b/ig;while((_=Z.exec(j))!==null){const J=_[1],M=T(_[2]);H.push({field:J,value:M,span:{start:_.index,end:_.index+_[0].length}})}return H},J1=function(j){const H=[],_=/\bname\s+(?:"([^"]+)"|(([A-Z][a-zA-Z]+)(?:\s+[A-Z][a-zA-Z]+)*))\b/g;let Z;while((Z=_.exec(j))!==null){const J=Z[1]||(Z[2]?Z[2].trim():null);if(!J)continue;H.push({value:J,span:{start:Z.index,end:Z.index+Z[0].length}})}return H},X1=function(j){const H=[],_=/\bfrom\s+(?:"([^"]+)"|([A-Za-z][A-Za-z]+))\b/ig;let Z;while((Z=_.exec(j))!==null){const J=Z[1]||Z[2];H.push({value:J,span:{start:Z.index,end:Z.index+Z[0].length}})}return H},a=function(j){const H=[],_=/\b([a-z][\w\.]*)\s+between\s+(?:"([^"]+)"|([0-9]{4}-[0-9]{2}-[0-9]{2}[T\d:._+\-Z]*))\s*(?:and|,|to)\s*(?:"([^"]+)"|([0-9]{4}-[0-9]{2}-[0-9]{2}[T\d:._+\-Z]*))\b/ig;let Z;const J=[];while((Z=_.exec(j))!==null){const F={start:Z.index,end:Z.index+Z[0].length};H.push({field:Z[1],min:Z[2]||Z[3],max:Z[4]||Z[5],span:F}),J.push(F)}const M=/\b([a-z][\w\.]*)\s+between\s+(-?\d+(?:\.\d+)?)\s*(?:and|,|to)\s*(-?\d+(?:\.\d+)?)\b/ig;while((Z=M.exec(j))!==null){const F={start:Z.index,end:Z.index+Z[0].length};if(J.some((Q)=>!(F.end<=Q.start||F.start>=Q.end)))continue;H.push({field:Z[1],min:K(Z[2]),max:K(Z[3]),span:F})}return H},o=function(j){const H=[],_=/\bids?\b\s+((?:-?\d+(?:\.\d+)?\s*,\s*)+-?\d+(?:\.\d+)?)\b/ig;let Z;while((Z=_.exec(j))!==null){const F=Z[1].split(/\s*,\s*/).map(K);H.push({kind:"in",values:F,span:{start:Z.index,end:Z.index+Z[0].length}})}const J=/\bids?\b\s+(-?\d+(?:\.\d+)?)\b/ig;while((Z=J.exec(j))!==null){const M={start:Z.index,end:Z.index+Z[0].length};if(!H.some((G)=>!(M.end<=G.span.start||M.start>=G.span.end)))H.push({kind:"eq",value:K(Z[1]),span:M})}return H},r=function(j){const H=[];let _;const Z=/\b([a-z][\w\.]*)\s*(?:>=|at\s+least)\s*(-?\d+(?:\.\d+)?)\b/ig;while((_=Z.exec(j))!==null)H.push({field:_[1],op:"$gte",value:K(_[2]),span:{start:_.index,end:_.index+_[0].length}});const J=/\b([a-z][\w\.]*)\s*(?:<=|at\s+most)\s*(-?\d+(?:\.\d+)?)\b/ig;while((_=J.exec(j))!==null)H.push({field:_[1],op:"$lte",value:K(_[2]),span:{start:_.index,end:_.index+_[0].length}});const M=/\b([a-z][\w\.]*)\s*(?:>|greater\s+than|more\s+than)\s*(-?\d+(?:\.\d+)?)\b/ig;while((_=M.exec(j))!==null)H.push({field:_[1],op:"$gt",value:K(_[2]),span:{start:_.index,end:_.index+_[0].length}});const F=/\b([a-z][\w\.]*)\s*(?:<|less\s+than|fewer\s+than)\s*(-?\d+(?:\.\d+)?)\b/ig;while((_=F.exec(j))!==null)H.push({field:_[1],op:"$lt",value:K(_[2]),span:{start:_.index,end:_.index+_[0].length}});const G=/\b([a-z][\w\.]*)\s*(?:=|equals|is)(?!\s+not)\s*"([^"]+)"\b/ig;while((_=G.exec(j))!==null)H.push({field:_[1],op:"eq",value:_[2],span:{start:_.index,end:_.index+_[0].length}});const Q=/\b([a-z][\w\.]*)\s*(?:=|equals|is)(?!\s+not)\s*([a-z0-9_\-\.]+)\b/ig;while((_=Q.exec(j))!==null)H.push({field:_[1],op:"eq",value:K(_[2]),span:{start:_.index,end:_.index+_[0].length}});return H},Y1=function(j){const H=[];let _;const Z=/\b([a-z][\w\.]*)\s+(on\s+or\s+after|on\s+or\s+before|after|before|on)\s+(?:"([^"]+)"|([0-9]{4}-[0-9]{2}-[0-9]{2}[T\d:._+\-Z]*))\b/ig;while((_=Z.exec(j))!==null){const J=_[1],M=_[2].toLowerCase().replace(/\s+/g," "),F=_[3]||_[4];let G="$gt";if(M==="before")G="$lt";else if(M==="on")G="eq";else if(M==="on or after")G="$gte";else if(M==="on or before")G="$lte";H.push({field:J,op:G,value:F,span:{start:_.index,end:_.index+_[0].length}})}return H},$1=function(j){const H=[{re:/\b(?:order|sort|sorted)\s+by\s+([a-z][\w\.]*)\s*(asc|ascending|desc|descending)?\b/i,groups:{field:1,dir:2}},{re:/\b(?:order|sort|sorted)\s+(asc|ascending|desc|descending)\s+by\s+([a-z][\w\.]*)\b/i,groups:{dir:1,field:2}}];for(let _ of H){const Z=j.match(_.re);if(Z){const J=(Z[_.groups.dir]||"asc").toLowerCase(),M=/desc|descending/.test(J)?"desc":"asc";return{field:Z[_.groups.field],order:M}}}return null},M1=function(j){const H=j.match(/\blimit\s+(\d+)\b/i);return H?Number(H[1]):null},K=function(j){const H=Number(j);return Number.isFinite(H)?H:j},w=function(j){if(!Array.isArray(j))return j;const H=[],_=(Z)=>{const J=Array.isArray(Z?._edgeResult)?Z._edgeResult:null;if(J&&J.length)for(let M of J)_(M);else H.push(Z)};for(let Z of j)_(Z);return H},U1=function(j){const H=[];let _;const Z=/\b([a-z][\w\.]*)\s*(=|is|equals)\s*("[^"]+"|[A-Za-z0-9_\-.]+)\s+or\s+\1\s*(=|is|equals)\s*("[^"]+"|[A-Za-z0-9_\-.]+)\b/ig;while((_=Z.exec(j))!==null){const F={[_[1]]:T(_[3])},G={[_[1]]:T(_[5])};H.push({left:F,right:G,span:{start:_.index,end:_.index+_[0].length}})}const J=/\b([a-z][\w\.]*)\s+(?:contains|containing)\s+("[^"]+"|[A-Za-z0-9_\-.]+)\s+or\s+\1\s+(?:contains|containing)\s+("[^"]+"|[A-Za-z0-9_\-.]+)\b/ig;while((_=J.exec(j))!==null){const F={[_[1]]:{$contains:T(_[2])}},G={[_[1]]:{$contains:T(_[3])}};H.push({left:F,right:G,span:{start:_.index,end:_.index+_[0].length}})}const M=/\b([a-z][\w\.]*)\s+starts\s+with\s+("[^"]+"|[A-Za-z0-9_\-]+)\s+or\s+\1\s+starts\s+with\s+("[^"]+"|[A-Za-z0-9_\-]+)\b/ig;while((_=M.exec(j))!==null){const F=String(T(_[2])),G=String(T(_[3])),Q={[_[1]]:{$regex:`^${F}`}},B={[_[1]]:{$regex:`^${G}`}};H.push({left:Q,right:B,span:{start:_.index,end:_.index+_[0].length}})}return H},T=function(j){if(!j)return j;const H=j.replace(/^"|"$/g,"");return K(H)},F1=function(j){if(!j||typeof j!=="object")return j;const{$edge:H,..._}=j,Z=H?e(H):void 0,J=Object.keys(_);if(J.length>1){const M={};if(Z)M.$edge=Z;return M.$and=J.map((F)=>({[F]:_[F]})),M}return{..._,...H?{$edge:Z}:{}}},e=function(j){if(!j||typeof j!=="object")return j;const{$edge:H,..._}=j,Z=Object.keys(_),J=H?e(H):void 0;if(Z.length>1){const M={};if(J)M.$edge=J;return M.$and=Z.map((F)=>({[F]:_[F]})),M}return{..._,...J?{$edge:J}:{}}},Q1=function(j){const _=/\bonly\s+([A-Z][a-zA-Z]+)s?\b/ig.exec(j);if(!_)return null;return{type:O(_[1]),span:{start:_.index,end:_.index+_[0].length}}},G1=function(j){const _=/\b(?:a|an)\s+([A-Z][a-zA-Z]+)s?\b/ig.exec(j);if(!_)return null;return{type:O(_[1]),span:{start:_.index,end:_.index+_[0].length}}},W1=function(j){if(/^(?:full[-\s]?text\s+search|text\s+search)\b/i.test(j))return null;const H=j.match(/^([A-Z][a-zA-Z]+)s?\b/);if(!H)return null;return{type:O(H[1]),span:{start:0,end:H[0].length}}},B1=function(j){const H=j.split(/\bthen\b/ig).map((G)=>G.trim()).filter(Boolean);let _=null,Z=null,J=null,M=null;for(let G of H){const Q=x(G),B=Z?.type?"type":Z?.role?"role":null,f=B?String(Z[B]).toLowerCase():null;let Y=Q.match(/\bdescendant[s]?\s+of\s+type\s+([A-Za-z][A-Za-z]+)s?\b/i),z=null,C="role",$=null,U=null,N=!1,R=Q.match(/\b(?:that|this|those|their|its)\s+([A-Za-z][A-Za-z]+)\s*'s\s+descendant[s]?\b/i);if(!R)R=Q.match(/\b(?:that|this|those|their|its)\s+([A-Za-z][A-Za-z]+)s?\s+descendant[s]?\b/i);if(R){const X=O(R[1]).toLowerCase();if(f&&X===f)N=!0,$=R.index,U=R.index+R[0].length}if(Y)z=O(Y[1]),$=Y.index,U=Y.index+Y[0].length,C="type";else if(Y=!N&&Q.match(/\b(?:that|this|those|their|its|a|an)?\s*([A-Za-z][A-Za-z]+)s?(?:'s)?\s+descendant[s]?\b/i),Y)z=O(Y[1]),$=Y.index,U=Y.index+Y[0].length;else if(Y=!N&&Q.match(/\bdescendant[s]?\s+(?:of\s+)?(?!named\b|called\b|with\b)([A-Za-z][A-Za-z]+)s?\b/i),Y)z=O(Y[1]),$=Y.index,U=Y.index+Y[0].length;else if(Y=Q.match(/\bchild(?:ren)?\s+of\s+type\s+([A-Za-z][A-Za-z]+)s?\b/i),Y)z=O(Y[1]),$=Y.index,U=Y.index+Y[0].length,C="type";else if(Y=Q.match(/\bchild(?:ren)?\s+(?:of\s+)?([A-Za-z][A-Za-z]+)s?\b/i),Y)z=O(Y[1]),$=Y.index,U=Y.index+Y[0].length;else if(Y=Q.match(/\b(?:that|this|those|their|its)?\s*([A-Za-z][A-Za-z]+)s?(?:'s)?\s+child(?:ren)?\b/i),Y)z=O(Y[1]),$=Y.index,U=Y.index+Y[0].length;else if(Y=Q.match(/\bgrandchild(?:ren)?\s+of\s+type\s+([A-Za-z][A-Za-z]+)s?\b/i),Y)z=O(Y[1]),$=Y.index,U=Y.index+Y[0].length,C="type";else if(Y=Q.match(/\bgrandchild(?:ren)?\s+(?:of\s+)?([A-Za-z][A-Za-z]+)s?\b/i),Y)z=O(Y[1]),$=Y.index,U=Y.index+Y[0].length;else if(Y=Q.match(/\b(?:that|this|those|their|its)?\s*([A-Za-z][A-Za-z]+)s?(?:'s)?\s+grandchild(?:ren)?\b/i),Y)z=O(Y[1]),$=Y.index,U=Y.index+Y[0].length;const g=/\b(descendant|child|children|grandchild|grandchildren)\b/i.test(Q);let W=null;if(z)W={[C]:z};else if(g)W={};else continue;const D=Q.match(/\b(?:named|called)\s+"([^"]+)"|\b(?:named|called)\s+([A-Za-z0-9_\-]+)\b|\bwith\s+name\s+"([^"]+)"|\bwith\s+name\s+([A-Za-z0-9_\-]+)\b/i);if(D){const X=D[1]||D[2]||D[3]||D[4];W.name=X;const P=D.index,b=D[0].length;if($===null||P<$)$=P;const A=P+b;if(U===null||A>U)U=A}for(let X of p(Q)){if(X.mode==="in"){const P=X.values??[X.value];W[X.field]={...W[X.field]||{},$in:P}}else W[X.field]={...W[X.field]||{},$contains:X.value};$=$==null?X.span.start:Math.min($,X.span.start),U=U==null?X.span.end:Math.max(U,X.span.end)}for(let X of u(Q))W[X.field]={...W[X.field]||{},$regex:`^${X.value}`},$=$==null?X.span.start:Math.min($,X.span.start),U=U==null?X.span.end:Math.max(U,X.span.end);for(let X of c(Q))W[X.field]={...W[X.field]||{},$regex:`${X.value}\$`},$=$==null?X.span.start:Math.min($,X.span.start),U=U==null?X.span.end:Math.max(U,X.span.end);for(let X of a(Q))W[X.field]={...W[X.field]||{},$between:[X.min,X.max]},$=$==null?X.span.start:Math.min($,X.span.start),U=U==null?X.span.end:Math.max(U,X.span.end);for(let X of r(Q)){if(X.op==="eq")W[X.field]=X.value;else W[X.field]={...W[X.field]||{},[X.op]:X.value};$=$==null?X.span.start:Math.min($,X.span.start),U=U==null?X.span.end:Math.max(U,X.span.end)}for(let X of n(Q))W[X.field]={...W[X.field]||{},$not:{$eq:X.value}},$=$==null?X.span.start:Math.min($,X.span.start),U=U==null?X.span.end:Math.max(U,X.span.end);for(let X of s(Q))W[X.field]={...W[X.field]||{},$in:X.values},$=$==null?X.span.start:Math.min($,X.span.start),U=U==null?X.span.end:Math.max(U,X.span.end);const v=l(Q);for(let X of v)W[X.field]={...W[X.field]||{},$exists:!0},$=$==null?X.span.start:Math.min($,X.span.start),U=U==null?X.span.end:Math.max(U,X.span.end);let q=Q.replace(/\b(?:has|with|having)\s+[a-z][\w\.]*\s+exists\b/ig," ").replace(/\bwhose\s+[a-z][\w\.]*\s+exists\b/ig," ").replace(/\b([a-z][\w\.]*)\s+exists\b/ig," ").replace(/\b(?:whose\s+)?([a-z][\w\.]*)\s+starts\s+with\s+(?:"[^\"]+"|[A-Za-z0-9_\-]+)/ig," ");for(let X of d(Q))W[X.field]={...W[X.field]||{},$like:X.value},$=$==null?X.span.start:Math.min($,X.span.start),U=U==null?X.span.end:Math.max(U,X.span.end);for(let X of m(q))W[X.field]=X.value,$=$==null?X.span.start:Math.min($,X.span.start),U=U==null?X.span.end:Math.max(U,X.span.end);for(let X of o(Q)){if(X.kind==="in")W.id={...W.id||{},$in:X.values};else if(X.kind==="eq")W.id=X.value;$=$==null?X.span.start:Math.min($,X.span.start),U=U==null?X.span.end:Math.max(U,X.span.end)}if(!W||Object.keys(W).length===0)continue;if(!_)_=W,Z=W,J=J??j.indexOf(Q)+($??0),M=j.indexOf(Q)+(U??0);else{const X=Z.type?"type":Z.role?"role":null,P=X?String(Z[X]).toLowerCase():null,b=W.type?"type":W.role?"role":null,A=b?String(W[b]).toLowerCase():null;if(!Z.$edge||typeof Z.$edge!=="object")Z.$edge={};const L=Z.$edge,h=L.type?"type":L.role?"role":null,z1=h?String(L[h]).toLowerCase():null,y=(E)=>{const k={};for(let[I,t]of Object.entries(W)){if(I==="$edge")continue;if(E&&(I==="type"||I==="role"))continue;k[I]=t}return k};if(A&&P&&A===P)Object.assign(L,y(!0));else if(A){for(let E of["type","role"])delete L[E];Object.assign(L,y(!1))}else Object.assign(L,y(!1));Z=Z.$edge;const S=j.indexOf(Q);if(J===null)J=S+($??0);M=S+(U??0)}}if(!_)return null;const F=J!=null&&M!=null?{start:J,end:M}:void 0;return{edge:_,span:F}},O=function(j){if(!j)return j;if(/ies$/i.test(j))return j.replace(/ies$/i,"y");if(/ses$/i.test(j))return j.replace(/es$/i,"e");if(/s$/i.test(j))return j.replace(/s$/i,"");return j},V1=function(j){const H={after:null,before:null,spans:[]},_=[{kind:"after",re:/\b(?:start(?:ing)?\s+)?after\s+(?:id\s+)?(?:"([^"]+)"|([A-Za-z0-9_\-]+))(?=\s|$)/ig},{kind:"before",re:/\b(?:before|until)\s+(?:id\s+)?(?:"([^"]+)"|([A-Za-z0-9_\-]+))(?=\s|$)/ig}];for(let Z of _){let J;while((J=Z.re.exec(j))!==null){const M=J[1]||J[2];if(Z.kind==="after"&&!H.after)H.after=M;if(Z.kind==="before"&&!H.before)H.before=M;H.spans.push({start:J.index,end:J.index+J[0].length})}}return H},L1=(j)=>{return console.log("\uD83E\uDDE0 NLQ module loaded (local DSL)."),_1(j)};export{_1 as withModule,L1 as init};
