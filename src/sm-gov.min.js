var h,z=[],x,w=!1,B=async()=>{for(let k of z)try{const{results:T=[]}=await h.map({});if(!T.length)continue;await Promise.all(T.map(async({id:j,timestamp:f})=>{const[,q]=j.split(":");if(!k.offsetTimestamp||f.physical<=Date.now()-k.offsetTimestamp)await D(k.then,q)}))}catch(T){console.error("\u274C GOVERNANCE ERROR: Failed to process rule.",{rule:k,error:T.message})}},D=async(k,T)=>{if(!k.assignRole)return;const{result:j}=await h.get(`user:${T}`),f=j?.value?.role;if(!f||f==="superadmin"||f===k.assignRole)return;await h.sm.executeWithPermission("assignRole"),await h.sm.assignRole(T,k.assignRole)},F=()=>{if(w)return;console.log("\u2705 GOVERNANCE ENGINE: Activated. Starting periodic checks."),x=setInterval(B,4000),w=!0},H=()=>{if(!w)return;clearInterval(x),x=null,w=!1,console.log("\uD83D\uDED1 GOVERNANCE ENGINE: Deactivated. Pausing checks.")},K=(k,{governanceRules:T,superAdmins:j}={})=>{if(!k||!T)return console.error("\u274C GOVERNANCE: Initialization failed: gdb instance and rules are required.");h=k,z=T,k.sm.setGovernanceStateChangeCallback(async({isActive:f,activeAddress:q})=>{if(f&&q&&j.includes(q))await h.sm.executeWithPermission("assignRole"),F();else H()})};export{K as start};
