function createRadixIndex(options = {}) {
  let index = {},
    fragmentedIndexes = {}
  const maxSize = options.maxSize || 1048576,
    encode = options.encode,
    decode = options.decode,
    pako = options.pako
  function upsert(id, value) {
    if (
      (extractPrefixes(value).forEach((prefix) => {
        if (!index[prefix]) index[prefix] = []
        if (!index[prefix].includes(id)) index[prefix].push(id)
      }),
      JSON.stringify(index).length > maxSize)
    )
      splitIndex()
  }
  function remove(id, value) {
    extractPrefixes(value).forEach((prefix) => {
      if (index[prefix]) {
        if (((index[prefix] = index[prefix].filter((itemId) => itemId !== id)), index[prefix].length === 0))
          delete index[prefix]
      }
    })
  }
  function extractPrefixes(value) {
    const prefixes = []
    if (typeof value === 'string')
      for (let i = 1; i <= value.length; i++) prefixes.push(value.substring(0, i))
    else if (typeof value === 'number') prefixes.push(String(value))
    else if (typeof value === 'object' && value !== null)
      Object.keys(value).forEach((key) => {
        prefixes.push(key.toString())
        const val = value[key]
        if (typeof val === 'string' || typeof val === 'number') prefixes.push(`${key}:${val}`)
      })
    return prefixes
  }
  function splitIndex() {
    const keys = Object.keys(index),
      midpoint = Math.ceil(keys.length / 2),
      fragment1 = {},
      fragment2 = {}
    keys.slice(0, midpoint).forEach((key) => {
      fragment1[key] = index[key]
    }),
      keys.slice(midpoint).forEach((key) => {
        fragment2[key] = index[key]
      }),
      (fragmentedIndexes.fragment1 = fragment1),
      (fragmentedIndexes.fragment2 = fragment2),
      (index = {})
  }
  function mergeFragments() {
    for (const fragment of Object.values(fragmentedIndexes)) Object.assign(index, fragment)
    fragmentedIndexes = {}
  }
  function searchByPrefix(prefix) {
    return index[prefix] || []
  }
  function searchAllByPrefix(prefix) {
    return Object.keys(index)
      .filter((key) => key.startsWith(prefix))
      .flatMap((key) => index[key])
  }
  function serialize() {
    if (!encode || !pako) throw new Error('Radix: encode y pako deben estar en options')
    const data = { index: index, fragmentedIndexes: fragmentedIndexes }
    return pako.deflate(encode(data))
  }
  function deserialize(data) {
    if (!decode || !pako) throw new Error('Radix: decode y pako deben estar en options')
    const inflated = pako.inflate(new Uint8Array(data)),
      decoded = decode(inflated)
    ;(index = decoded.index || {}), (fragmentedIndexes = decoded.fragmentedIndexes || {})
  }
  function validateIndex() {
    if (JSON.stringify(index).length > maxSize) throw new Error('Index too large')
    if (!index || typeof index !== 'object') index = {}
  }
  return {
    upsert: upsert,
    remove: remove,
    extractPrefixes: extractPrefixes,
    splitIndex: splitIndex,
    mergeFragments: mergeFragments,
    searchByPrefix: searchByPrefix,
    searchAllByPrefix: searchAllByPrefix,
    serialize: serialize,
    deserialize: deserialize,
    validateIndex: validateIndex
  }
}
function createRadixIndexer(config) {
  const { worker: worker, encode: encode, decode: decode, pako: pako } = config,
    radixIndex = createRadixIndex({ maxSize: config.maxSize || 1048576, encode: encode, decode: decode, pako: pako }),
    indexFileName = config.indexFileName || 'graph_radix_index.msgpack',
    debouncedSave = ((func, delay) => {
      let timeoutId
      return (...args) => {
        clearTimeout(timeoutId), (timeoutId = setTimeout(() => func.apply(null, args), delay))
      }
    })(() => saveIndex(), 200)
  async function loadIndex() {
    try {
      const indexData = await new Promise((resolve, reject) => {
        const messageHandler = (event) => {
          if (event.data.type === 'loaded' && event.data.name === indexFileName)
            worker.removeEventListener('message', messageHandler), resolve(new Uint8Array(event.data.data))
          else if (event.data.type === 'error')
            worker.removeEventListener('message', messageHandler),
              reject(new Error(event.data.message || 'Error loading the Radix index'))
        }
        worker.addEventListener('message', messageHandler),
          worker.postMessage({ type: 'load', name: indexFileName })
      })
      if (indexData.byteLength > 0) radixIndex.deserialize(indexData)
    } catch {}
  }
  async function saveIndex() {
    try {
      const serializedData = radixIndex.serialize()
      await new Promise((resolve, reject) => {
        const messageHandler = (event) => {
          if (event.data.type === 'saved' && event.data.name === indexFileName)
            worker.removeEventListener('message', messageHandler), resolve()
          else if (event.data.type === 'error')
            worker.removeEventListener('message', messageHandler),
              reject(new Error(event.data.message || 'Error saving the Radix index'))
        }
        worker.addEventListener('message', messageHandler),
          worker.postMessage({ type: 'save', name: indexFileName, content: serializedData })
      })
    } catch {}
  }
  async function rebuildIndex() {
    try {
      radixIndex.validateIndex(),
        (typeof config.graph?.getAllNodes === 'function'
          ? await config.graph.getAllNodes()
          : Object.values(config.graph.nodes)
        ).forEach((node) => {
          radixIndex.upsert(node.id, node.value)
        })
    } catch {}
  }
  async function updateIndex(id, value, operation = 'insert') {
    switch (operation) {
      case 'insert':
        radixIndex.upsert(id, value)
        break
      case 'remove':
        radixIndex.remove(id, value)
        break
    }
    debouncedSave()
  }
  function searchByPrefix(prefix) {
    return radixIndex.searchAllByPrefix(prefix)
  }
  return { ready: loadIndex().then(rebuildIndex), updateIndex: updateIndex, searchByPrefix: searchByPrefix }
}
function withRadixModule(graphConfig) {
  const radixIndexer = createRadixIndexer(graphConfig),
    originalPut = graphConfig.put
  graphConfig.put = async function (key, id) {
    const oldValue = id ? this.graph.get(id) : null,
      result = await originalPut.call(this, key, id)
    if (oldValue) await radixIndexer.updateIndex(result, oldValue.value, 'remove')
    return await radixIndexer.updateIndex(result, key, 'insert'), result
  }
  const originalRemove = graphConfig.remove
  graphConfig.remove = async function (key) {
    const node = this.graph.get(key)
    if ((await originalRemove.call(this, key), node)) await radixIndexer.updateIndex(key, node.value, 'remove')
  }
  const originalMap = graphConfig.map
  return (
    (graphConfig.map = async function (...args) {
      const result = await originalMap.call(this, ...args),
        queryObj = args.find((arg) => typeof arg === 'object')
      if (queryObj?.query?.id?.$startsWith) {
        const prefix = queryObj.query.id.$startsWith,
          searchResults = radixIndexer.searchByPrefix(prefix)
        return result.filter((item) => searchResults.includes(item.id))
      }
      return result
    }),
    (graphConfig.searchByPrefix = async function (prefix) {
      return radixIndexer.searchByPrefix(prefix).map((id) => this.graph.get(id))
    }),
    graphConfig
  )
}
var initRadixIndexer = (config) => {
  return console.log('\uD83C\uDF33 RadixIndexer module loaded.'), withRadixModule(config)
}
export { withRadixModule as withModule, initRadixIndexer as init, createRadixIndexer as RadixIndexer }
