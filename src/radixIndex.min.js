function S(H={}){let q={},Y={};const A=H.maxSize||1048576,G=H.encode,K=H.decode,L=H.pako;function Z(C,E){if(_(E).forEach((Q)=>{if(!q[Q])q[Q]=[];if(!q[Q].includes(C))q[Q].push(C)}),JSON.stringify(q).length>A)T()}function X(C,E){_(E).forEach((Q)=>{if(q[Q]){if(q[Q]=q[Q].filter(($)=>$!==C),q[Q].length===0)delete q[Q]}})}function _(C){const E=[];if(typeof C==="string")for(let J=1;J<=C.length;J++)E.push(C.substring(0,J));else if(typeof C==="number")E.push(String(C));else if(typeof C==="object"&&C!==null)Object.keys(C).forEach((J)=>{E.push(J.toString());const Q=C[J];if(typeof Q==="string"||typeof Q==="number")E.push(`${J}:${Q}`)});return E}function T(){const C=Object.keys(q),E=Math.ceil(C.length/2),J={},Q={};C.slice(0,E).forEach(($)=>{J[$]=q[$]}),C.slice(E).forEach(($)=>{Q[$]=q[$]}),Y.fragment1=J,Y.fragment2=Q,q={}}function B(){for(let C of Object.values(Y))Object.assign(q,C);Y={}}function O(C){return q[C]||[]}function V(C){return Object.keys(q).filter((E)=>E.startsWith(C)).flatMap((E)=>q[E])}function D(){if(!G||!L)throw new Error("Radix: encode y pako deben estar en options");const C={index:q,fragmentedIndexes:Y};return L.deflate(G(C))}function U(C){if(!K||!L)throw new Error("Radix: decode y pako deben estar en options");const E=L.inflate(new Uint8Array(C)),J=K(E);q=J.index||{},Y=J.fragmentedIndexes||{}}function W(){if(JSON.stringify(q).length>A)throw new Error("Index too large");if(!q||typeof q!=="object")q={}}return{upsert:Z,remove:X,extractPrefixes:_,splitIndex:T,mergeFragments:B,searchByPrefix:O,searchAllByPrefix:V,serialize:D,deserialize:U,validateIndex:W}}function z(H){const{worker:q,encode:Y,decode:A,pako:G}=H,K=S({maxSize:H.maxSize||1048576,encode:Y,decode:A,pako:G}),L=H.indexFileName||"graph_radix_index.msgpack",X=((U,W)=>{let C;return(...E)=>{clearTimeout(C),C=setTimeout(()=>U.apply(null,E),W)}})(()=>T(),200);async function _(){try{const U=await new Promise((W,C)=>{const E=(J)=>{if(J.data.type==="loaded"&&J.data.name===L)q.removeEventListener("message",E),W(new Uint8Array(J.data.data));else if(J.data.type==="error")q.removeEventListener("message",E),C(new Error(J.data.message||"Error loading the Radix index"))};q.addEventListener("message",E),q.postMessage({type:"load",name:L})});if(U.byteLength>0)K.deserialize(U)}catch{}}async function T(){try{const U=K.serialize();await new Promise((W,C)=>{const E=(J)=>{if(J.data.type==="saved"&&J.data.name===L)q.removeEventListener("message",E),W();else if(J.data.type==="error")q.removeEventListener("message",E),C(new Error(J.data.message||"Error saving the Radix index"))};q.addEventListener("message",E),q.postMessage({type:"save",name:L,content:U})})}catch{}}async function B(){try{K.validateIndex(),(typeof H.graph?.getAllNodes==="function"?await H.graph.getAllNodes():Object.values(H.graph.nodes)).forEach((W)=>{K.upsert(W.id,W.value)})}catch{}}async function O(U,W,C="insert"){switch(C){case"insert":K.upsert(U,W);break;case"remove":K.remove(U,W);break}X()}function V(U){return K.searchAllByPrefix(U)}return{ready:_().then(B),updateIndex:O,searchByPrefix:V}}function R(H){const q=z(H),Y=H.put;H.put=async function(K,L){const Z=L?this.graph.get(L):null,X=await Y.call(this,K,L);if(Z)await q.updateIndex(X,Z.value,"remove");return await q.updateIndex(X,K,"insert"),X};const A=H.remove;H.remove=async function(K){const L=this.graph.get(K);if(await A.call(this,K),L)await q.updateIndex(K,L.value,"remove")};const G=H.map;return H.map=async function(...K){const L=await G.call(this,...K),Z=K.find((X)=>typeof X==="object");if(Z?.query?.id?.$startsWith){const X=Z.query.id.$startsWith,_=q.searchByPrefix(X);return L.filter((T)=>_.includes(T.id))}return L},H.searchByPrefix=async function(K){return q.searchByPrefix(K).map((Z)=>this.graph.get(Z))},H}var w=(H)=>{return console.log("\uD83C\uDF33 RadixIndexer module loaded."),R(H)};export{R as withModule,w as init,z as RadixIndexer};
