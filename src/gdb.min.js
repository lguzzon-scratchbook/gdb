function calculateStringByteLength(string) {
  const stringLength = string.length
  let byteCount = 0,
    charIndex = 0
  while (charIndex < stringLength) {
    let charCode = string.charCodeAt(charIndex++)
    if ((charCode & 4294967168) === 0) {
      byteCount++
    } else if ((charCode & 4294965248) === 0) byteCount += 2
    else {
      if (charCode >= 55296 && charCode <= 56319) {
        if (charIndex < stringLength) {
          const nextCharCode = string.charCodeAt(charIndex)
          if ((nextCharCode & 64512) === 56320)
            ++charIndex, (charCode = ((charCode & 1023) << 10) + (nextCharCode & 1023) + 65536)
        }
      }
      if ((charCode & 4294901760) === 0) byteCount += 3
      else byteCount += 4
    }
  }
  return byteCount
}
function encodeStringToUtf8(string, outputBytes, outputIndex) {
  const stringLength = string.length
  let byteIndex = outputIndex,
    charIndex = 0
  while (charIndex < stringLength) {
    let charCode = string.charCodeAt(charIndex++)
    if ((charCode & 4294967168) === 0) {
      outputBytes[byteIndex++] = charCode
      continue
    } else if ((charCode & 4294965248) === 0) outputBytes[byteIndex++] = ((charCode >> 6) & 31) | 192
    else {
      if (charCode >= 55296 && charCode <= 56319) {
        if (charIndex < stringLength) {
          const nextCharCode = string.charCodeAt(charIndex)
          if ((nextCharCode & 64512) === 56320)
            ++charIndex, (charCode = ((charCode & 1023) << 10) + (nextCharCode & 1023) + 65536)
        }
      }
      if ((charCode & 4294901760) === 0)
        (outputBytes[byteIndex++] = ((charCode >> 12) & 15) | 224), (outputBytes[byteIndex++] = ((charCode >> 6) & 63) | 128)
      else
        (outputBytes[byteIndex++] = ((charCode >> 18) & 7) | 240),
          (outputBytes[byteIndex++] = ((charCode >> 12) & 63) | 128),
          (outputBytes[byteIndex++] = ((charCode >> 6) & 63) | 128)
    }
    outputBytes[byteIndex++] = (charCode & 63) | 128
  }
}
function encodeStringWithEncoder(string, outputBytes, outputIndex) {
  textEncoder.encodeInto(string, outputBytes.subarray(outputIndex))
}
function encodeStringOptimized(string, outputBytes, outputIndex) {
  if (string.length > ENCODER_THRESHOLD) encodeStringWithEncoder(string, outputBytes, outputIndex)
  else encodeStringToUtf8(string, outputBytes, outputIndex)
}
function decodeUtf8Manually(inputBytes, offset, byteLength) {
  let byteIndex = offset
  const endingIndex = byteIndex + byteLength,
    codePoints = []
  let resultString = ''
  while (byteIndex < endingIndex) {
    const byteValue = inputBytes[byteIndex++]
    if ((byteValue & 128) === 0) codePoints.push(byteValue)
    else if ((byteValue & 224) === 192) {
      const continuationByte = inputBytes[byteIndex++] & 63
      codePoints.push(((byteValue & 31) << 6) | continuationByte)
    } else if ((byteValue & 240) === 224) {
      const continuationByte1 = inputBytes[byteIndex++] & 63,
        continuationByte2 = inputBytes[byteIndex++] & 63
      codePoints.push(((byteValue & 31) << 12) | (continuationByte1 << 6) | continuationByte2)
    } else if ((byteValue & 248) === 240) {
      const continuationByte1 = inputBytes[byteIndex++] & 63,
        continuationByte2 = inputBytes[byteIndex++] & 63,
        continuationByte3 = inputBytes[byteIndex++] & 63
      let codePoint = ((byteValue & 7) << 18) | (continuationByte1 << 12) | (continuationByte2 << 6) | continuationByte3
      if (codePoint > 65535)
        (codePoint -= 65536),
          codePoints.push(((codePoint >>> 10) & 1023) | 55296),
          (codePoint = 56320 | (codePoint & 1023))
      codePoints.push(codePoint)
    } else codePoints.push(byteValue)
    if (codePoints.length >= STRING_CHUNK_SIZE) (resultString += String.fromCharCode(...codePoints)), (codePoints.length = 0)
  }
  if (codePoints.length > 0) resultString += String.fromCharCode(...codePoints)
  return resultString
}
function decodeWithDecoder(inputBytes, offset, byteLength) {
  const byteSlice = inputBytes.subarray(offset, offset + byteLength)
  return textDecoder.decode(byteSlice)
}
function decodeStringOptimized(inputBytes, offset, byteLength) {
  if (byteLength > DECODER_THRESHOLD) return decodeWithDecoder(inputBytes, offset, byteLength)
  else return decodeUtf8Manually(inputBytes, offset, byteLength)
}
var textEncoder = new TextEncoder(),
  ENCODER_THRESHOLD = 50,
  STRING_CHUNK_SIZE = 4096,
  textDecoder = new TextDecoder(),
  DECODER_THRESHOLD = 200
class ExtensionData {
  constructor(type, data) {
    ;(this.type = type), (this.data = data)
  }
}
class MessagePackError extends Error {
  constructor(message) {
    super(message)
    const prototype = Object.create(MessagePackError.prototype)
    Object.setPrototypeOf(this, prototype),
      Object.defineProperty(this, 'name', {
        configurable: !0,
        enumerable: !1,
        value: MessagePackError.name
      })
  }
}
function writeUint64(dataView, offset, value) {
  const highBits = value / 4294967296,
    lowBits = value
  dataView.setUint32(offset, highBits), dataView.setUint32(offset + 4, lowBits)
}
function writeInt64(dataView, offset, value) {
  const highBits = Math.floor(value / 4294967296),
    lowBits = value
  dataView.setUint32(offset, highBits), dataView.setUint32(offset + 4, lowBits)
}
function readInt64(dataView, offset) {
  const highBits = dataView.getInt32(offset),
    lowBits = dataView.getUint32(offset + 4)
  return highBits * 4294967296 + lowBits
}
function readUint64(dataView, offset) {
  const highBits = dataView.getUint32(offset),
    lowBits = dataView.getUint32(offset + 4)
  return highBits * 4294967296 + lowBits
}
var UINT32_MAX = 4294967295
function encodeTimestamp({ sec: seconds, nsec: nanoseconds }) {
  if (seconds >= 0 && nanoseconds >= 0 && seconds <= MAX_TIMESTAMP_SECONDS)
    if (nanoseconds === 0 && seconds <= UINT32_MAX) {
      const bytes = new Uint8Array(4)
      return new DataView(bytes.buffer).setUint32(0, seconds), bytes
    } else {
      const highBits = seconds / 4294967296,
        lowBits = seconds & 4294967295,
        bytes = new Uint8Array(8),
        dataView = new DataView(bytes.buffer)
      return dataView.setUint32(0, (nanoseconds << 2) | (highBits & 3)), dataView.setUint32(4, lowBits), bytes
    }
  else {
    const bytes = new Uint8Array(12),
      dataView = new DataView(bytes.buffer)
    return dataView.setUint32(0, nanoseconds), writeInt64(dataView, 4, seconds), bytes
  }
}
function dateToTimestampStruct(date) {
  const timeMs = date.getTime(),
    seconds = Math.floor(timeMs / 1000),
    nanoseconds = (timeMs - seconds * 1000) * 1e6,
    carrySeconds = Math.floor(nanoseconds / 1e9)
  return { sec: seconds + carrySeconds, nsec: nanoseconds - carrySeconds * 1e9 }
}
function encodeDate(date) {
  if (date instanceof Date) {
    const timestampStruct = dateToTimestampStruct(date)
    return encodeTimestamp(timestampStruct)
  } else return null
}
function decodeTimestamp(bytes) {
  const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength)
  switch (bytes.byteLength) {
    case 4:
      return { sec: dataView.getUint32(0), nsec: 0 }
    case 8: {
      const header = dataView.getUint32(0),
        lowBits = dataView.getUint32(4),
        seconds = (header & 3) * 4294967296 + lowBits,
        nanoseconds = header >>> 2
      return { sec: seconds, nsec: nanoseconds }
    }
    case 12: {
      const seconds = readInt64(dataView, 4),
        nanoseconds = dataView.getUint32(0)
      return { sec: seconds, nsec: nanoseconds }
    }
    default:
      throw new MessagePackError(
        `Unrecognized data size for timestamp (expected 4, 8, or 12): ${bytes.length}`
      )
  }
}
function decodeToDate(bytes) {
  const timestampStruct = decodeTimestamp(bytes)
  return new Date(timestampStruct.sec * 1000 + timestampStruct.nsec / 1e6)
}
var TIMESTAMP_TYPE = -1,
  UINT32_MAX = 4294967295,
  MAX_TIMESTAMP_SECONDS = 17179869183,
  timestampCodec = { type: TIMESTAMP_TYPE, encode: encodeDate, decode: decodeToDate }
class ExtensionCodec {
  constructor() {
    ;(this.builtInEncoders = []),
      (this.builtInDecoders = []),
      (this.encoders = []),
      (this.decoders = []),
      this.register(timestampCodec)
  }
  register({ type: type, encode: encoder, decode: decoder }) {
    if (type >= 0) (this.encoders[type] = encoder), (this.decoders[type] = decoder)
    else {
      const index = -1 - type
      ;(this.builtInEncoders[index] = encoder), (this.builtInDecoders[index] = decoder)
    }
  }
  tryToEncode(object, context) {
    for (let i = 0; i < this.builtInEncoders.length; i++) {
      const encoder = this.builtInEncoders[i]
      if (encoder != null) {
        const encoded = encoder(object, context)
        if (encoded != null) {
          const type = -1 - i
          return new ExtensionData(type, encoded)
        }
      }
    }
    for (let i = 0; i < this.encoders.length; i++) {
      const encoder = this.encoders[i]
      if (encoder != null) {
        const encoded = encoder(object, context)
        if (encoded != null) return new ExtensionData(i, encoded)
      }
    }
    if (object instanceof ExtensionData) return object
    return null
  }
  decode(data, type, context) {
    const decoder = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type]
    if (decoder) return decoder(data, type, context)
    else return new ExtensionData(type, data)
  }
}
ExtensionCodec.defaultCodec = new ExtensionCodec()
var isArrayBuffer = (value) =>
  value instanceof ArrayBuffer ||
  (typeof SharedArrayBuffer !== 'undefined' && value instanceof SharedArrayBuffer)
function toUint8Array(input) {
  if (input instanceof Uint8Array) return input
  else if (ArrayBuffer.isView(input))
    return new Uint8Array(input.buffer, input.byteOffset, input.byteLength)
  else if (isArrayBuffer(input)) return new Uint8Array(input)
  else return Uint8Array.from(input)
}
var DEFAULT_MAX_DEPTH = 100,
  DEFAULT_INITIAL_BUFFER_SIZE = 2048
class MessagePackEncoder {
  constructor(options) {
    ;(this.entered = !1),
      (this.extensionCodec = options?.extensionCodec ?? ExtensionCodec.defaultCodec),
      (this.context = options?.context),
      (this.useBigInt64 = options?.useBigInt64 ?? !1),
      (this.maxDepth = options?.maxDepth ?? DEFAULT_MAX_DEPTH),
      (this.initialBufferSize = options?.initialBufferSize ?? DEFAULT_INITIAL_BUFFER_SIZE),
      (this.sortKeys = options?.sortKeys ?? !1),
      (this.forceFloat32 = options?.forceFloat32 ?? !1),
      (this.ignoreUndefined = options?.ignoreUndefined ?? !1),
      (this.forceIntegerToFloat = options?.forceIntegerToFloat ?? !1),
      (this.pos = 0),
      (this.view = new DataView(new ArrayBuffer(this.initialBufferSize))),
      (this.bytes = new Uint8Array(this.view.buffer))
  }
  clone() {
    return new MessagePackEncoder({
      extensionCodec: this.extensionCodec,
      context: this.context,
      useBigInt64: this.useBigInt64,
      maxDepth: this.maxDepth,
      initialBufferSize: this.initialBufferSize,
      sortKeys: this.sortKeys,
      forceFloat32: this.forceFloat32,
      ignoreUndefined: this.ignoreUndefined,
      forceIntegerToFloat: this.forceIntegerToFloat
    })
  }
  reinitializeState() {
    this.pos = 0
  }
  encodeSharedRef(object) {
    if (this.entered) return this.clone().encodeSharedRef(object)
    try {
      return (
        (this.entered = !0),
        this.reinitializeState(),
        this.doEncode(object, 1),
        this.bytes.subarray(0, this.pos)
      )
    } finally {
      this.entered = !1
    }
  }
  encode(object) {
    if (this.entered) return this.clone().encode(object)
    try {
      return (
        (this.entered = !0),
        this.reinitializeState(),
        this.doEncode(object, 1),
        this.bytes.slice(0, this.pos)
      )
    } finally {
      this.entered = !1
    }
  }
  doEncode(object, depth) {
    if (depth > this.maxDepth) throw new Error(`Too deep objects in depth ${depth}`)
    if (object == null) this.encodeNil()
    else if (typeof object === 'boolean') this.encodeBoolean(object)
    else if (typeof object === 'number')
      if (!this.forceIntegerToFloat) this.encodeNumber(object)
      else this.encodeNumberAsFloat(object)
    else if (typeof object === 'string') this.encodeString(object)
    else if (this.useBigInt64 && typeof object === 'bigint') this.encodeBigInt64(object)
    else this.encodeObject(object, depth)
  }
  ensureBufferSizeToWrite(byteCount) {
    const requiredSize = this.pos + byteCount
    if (this.view.byteLength < requiredSize) this.resizeBuffer(requiredSize * 2)
  }
  resizeBuffer(newSize) {
    const newBuffer = new ArrayBuffer(newSize),
      newBytes = new Uint8Array(newBuffer),
      newView = new DataView(newBuffer)
    newBytes.set(this.bytes), (this.view = newView), (this.bytes = newBytes)
  }
  encodeNil() {
    this.writeU8(192)
  }
  encodeBoolean(value) {
    if (value === !1) this.writeU8(194)
    else this.writeU8(195)
  }
  encodeNumber(value) {
    if (!this.forceIntegerToFloat && Number.isSafeInteger(value))
      if (value >= 0)
        if (value < 128) this.writeU8(value)
        else if (value < 256) this.writeU8(204), this.writeU8(value)
        else if (value < 65536) this.writeU8(205), this.writeU16(value)
        else if (value < 4294967296) this.writeU8(206), this.writeU32(value)
        else if (!this.useBigInt64) this.writeU8(207), this.writeU64(value)
        else this.encodeNumberAsFloat(value)
      else if (value >= -32) this.writeU8(224 | (value + 32))
      else if (value >= -128) this.writeU8(208), this.writeI8(value)
      else if (value >= -32768) this.writeU8(209), this.writeI16(value)
      else if (value >= -2147483648) this.writeU8(210), this.writeI32(value)
      else if (!this.useBigInt64) this.writeU8(211), this.writeI64(value)
      else this.encodeNumberAsFloat(value)
    else this.encodeNumberAsFloat(value)
  }
  encodeNumberAsFloat(value) {
    if (this.forceFloat32) this.writeU8(202), this.writeF32(value)
    else this.writeU8(203), this.writeF64(value)
  }
  encodeBigInt64(value) {
    if (value >= BigInt(0)) this.writeU8(207), this.writeBigUint64(value)
    else this.writeU8(211), this.writeBigInt64(value)
  }
  writeStringHeader(byteLength) {
    if (byteLength < 32) this.writeU8(160 + byteLength)
    else if (byteLength < 256) this.writeU8(217), this.writeU8(byteLength)
    else if (byteLength < 65536) this.writeU8(218), this.writeU16(byteLength)
    else if (byteLength < 4294967296) this.writeU8(219), this.writeU32(byteLength)
    else throw new Error(`Too long string: ${byteLength} bytes in UTF-8`)
  }
  encodeString(string) {
    const stringByteLength = calculateStringByteLength(string)
    this.ensureBufferSizeToWrite(5 + stringByteLength),
      this.writeStringHeader(stringByteLength),
      encodeStringOptimized(string, this.bytes, this.pos),
      (this.pos += stringByteLength)
  }
  encodeObject(object, depth) {
    const extensionData = this.extensionCodec.tryToEncode(object, this.context)
    if (extensionData != null) this.encodeExtension(extensionData)
    else if (Array.isArray(object)) this.encodeArray(object, depth)
    else if (ArrayBuffer.isView(object)) this.encodeBinary(object)
    else if (typeof object === 'object') this.encodeMap(object, depth)
    else
      throw new Error(
        `Unrecognized object: ${Object.prototype.toString.apply(object)}`
      )
  }
  encodeBinary(data) {
    const byteLength = data.byteLength
    if (byteLength < 256) this.writeU8(196), this.writeU8(byteLength)
    else if (byteLength < 65536) this.writeU8(197), this.writeU16(byteLength)
    else if (byteLength < 4294967296) this.writeU8(198), this.writeU32(byteLength)
    else throw new Error(`Too large binary: ${byteLength}`)
    const uint8Array = toUint8Array(data)
    this.writeU8a(uint8Array)
  }
  encodeArray(array, depth) {
    const arrayLength = array.length
    if (arrayLength < 16) this.writeU8(144 + arrayLength)
    else if (arrayLength < 65536) this.writeU8(220), this.writeU16(arrayLength)
    else if (arrayLength < 4294967296) this.writeU8(221), this.writeU32(arrayLength)
    else throw new Error(`Too large array: ${arrayLength}`)
    for (const element of array) this.doEncode(element, depth + 1)
  }
  countWithoutUndefined(obj, keys) {
    let count = 0
    for (const key of keys) if (obj[key] !== void 0) count++
    return count
  }
  encodeMap(obj, depth) {
    const keys = Object.keys(obj)
    if (this.sortKeys) keys.sort()
    const mapSize = this.ignoreUndefined ? this.countWithoutUndefined(obj, keys) : keys.length
    if (mapSize < 16) this.writeU8(128 + mapSize)
    else if (mapSize < 65536) this.writeU8(222), this.writeU16(mapSize)
    else if (mapSize < 4294967296) this.writeU8(223), this.writeU32(mapSize)
    else throw new Error(`Too large map object: ${mapSize}`)
    for (const key of keys) {
      const value = obj[key]
      if (!(this.ignoreUndefined && value === void 0))
        this.encodeString(key), this.doEncode(value, depth + 1)
    }
  }
  encodeExtension(extensionData) {
    if (typeof extensionData.data === 'function') {
      const generatedData = extensionData.data(this.pos + 6),
        dataLength = generatedData.length
      if (dataLength >= 4294967296) throw new Error(`Too large extension object: ${dataLength}`)
      this.writeU8(201),
        this.writeU32(dataLength),
        this.writeI8(extensionData.type),
        this.writeU8a(generatedData)
      return
    }
    const extensionDataLength = extensionData.data.length
    if (extensionDataLength === 1) this.writeU8(212)
    else if (extensionDataLength === 2) this.writeU8(213)
    else if (extensionDataLength === 4) this.writeU8(214)
    else if (extensionDataLength === 8) this.writeU8(215)
    else if (extensionDataLength === 16) this.writeU8(216)
    else if (extensionDataLength < 256) this.writeU8(199), this.writeU8(extensionDataLength)
    else if (extensionDataLength < 65536) this.writeU8(200), this.writeU16(extensionDataLength)
    else if (extensionDataLength < 4294967296) this.writeU8(201), this.writeU32(extensionDataLength)
    else throw new Error(`Too large extension object: ${extensionDataLength}`)
    this.writeI8(extensionData.type), this.writeU8a(extensionData.data)
  }
  writeU8(value) {
    this.ensureBufferSizeToWrite(1), this.view.setUint8(this.pos, value), this.pos++
  }
  writeU8a(array) {
    const arrayLength = array.length
    this.ensureBufferSizeToWrite(arrayLength),
      this.bytes.set(array, this.pos),
      (this.pos += arrayLength)
  }
  writeI8(value) {
    this.ensureBufferSizeToWrite(1), this.view.setInt8(this.pos, value), this.pos++
  }
  writeU16(value) {
    this.ensureBufferSizeToWrite(2),
      this.view.setUint16(this.pos, value),
      (this.pos += 2)
  }
  writeI16(value) {
    this.ensureBufferSizeToWrite(2),
      this.view.setInt16(this.pos, value),
      (this.pos += 2)
  }
  writeU32(value) {
    this.ensureBufferSizeToWrite(4),
      this.view.setUint32(this.pos, value),
      (this.pos += 4)
  }
  writeI32(value) {
    this.ensureBufferSizeToWrite(4),
      this.view.setInt32(this.pos, value),
      (this.pos += 4)
  }
  writeF32(value) {
    this.ensureBufferSizeToWrite(4),
      this.view.setFloat32(this.pos, value),
      (this.pos += 4)
  }
  writeF64(value) {
    this.ensureBufferSizeToWrite(8),
      this.view.setFloat64(this.pos, value),
      (this.pos += 8)
  }
  writeU64(value) {
    this.ensureBufferSizeToWrite(8), writeUint64(this.view, this.pos, value), (this.pos += 8)
  }
  writeI64(value) {
    this.ensureBufferSizeToWrite(8), writeInt64(this.view, this.pos, value), (this.pos += 8)
  }
  writeBigUint64(value) {
    this.ensureBufferSizeToWrite(8),
      this.view.setBigUint64(this.pos, value),
      (this.pos += 8)
  }
  writeBigInt64(value) {
    this.ensureBufferSizeToWrite(8),
      this.view.setBigInt64(this.pos, value),
      (this.pos += 8)
  }
}
function encodeSharedRef(object, options) {
  return new MessagePackEncoder(options).encodeSharedRef(object)
}
function toHexString(value) {
  return `${value < 0 ? '-' : ''}0x${Math.abs(value).toString(16).padStart(2, '0')}`
}
var DEFAULT_MAX_KEY_LENGTH = 16,
  DEFAULT_MAX_ENTRIES_PER_KEY = 16
class StringKeyDecoder {
  constructor(maxKeyLength = DEFAULT_MAX_KEY_LENGTH, maxEntriesPerKey = DEFAULT_MAX_ENTRIES_PER_KEY) {
    ;(this.hit = 0),
      (this.miss = 0),
      (this.maxKeyLength = maxKeyLength),
      (this.maxLengthPerKey = maxEntriesPerKey),
      (this.caches = [])
    for (let i = 0; i < this.maxKeyLength; i++) this.caches.push([])
  }
  canBeCached(keyLength) {
    return keyLength > 0 && keyLength <= this.maxKeyLength
  }
  find(inputBytes, offset, byteLength) {
    const cacheForLength = this.caches[byteLength - 1]
    searchLoop: for (const cacheEntry of cacheForLength) {
      const cachedBytes = cacheEntry.bytes
      for (let i = 0; i < byteLength; i++) if (cachedBytes[i] !== inputBytes[offset + i]) continue searchLoop
      return cacheEntry.str
    }
    return null
  }
  store(keyBytes, stringValue) {
    const cacheForLength = this.caches[keyBytes.length - 1],
      cacheEntry = { bytes: keyBytes, str: stringValue }
    if (cacheForLength.length >= this.maxLengthPerKey) cacheForLength[(Math.random() * cacheForLength.length) | 0] = cacheEntry
    else cacheForLength.push(cacheEntry)
  }
  decode(inputBytes, offset, byteLength) {
    const cachedString = this.find(inputBytes, offset, byteLength)
    if (cachedString != null) return this.hit++, cachedString
    this.miss++
    const decodedString = decodeUtf8Manually(inputBytes, offset, byteLength),
      keyBytesForCache = Uint8Array.prototype.slice.call(inputBytes, offset, offset + byteLength)
    return this.store(keyBytesForCache, decodedString), decodedString
  }
}
var ARRAY_STATE_TYPE = 'array',
  MAP_KEY_STATE_TYPE = 'map_key',
  MAP_VALUE_STATE_TYPE = 'map_value',
  defaultMapKeyConverter = (key) => {
    if (typeof key === 'string' || typeof key === 'number') return key
    throw new MessagePackError(`The type of key must be string or number but ${typeof key}`)
  }
class DecodingStack {
  constructor() {
    ;(this.stack = []), (this.stackHeadPosition = -1)
  }
  get length() {
    return this.stackHeadPosition + 1
  }
  top() {
    return this.stack[this.stackHeadPosition]
  }
  pushArrayState(arraySize) {
    const state = this.getUninitializedStateFromPool()
    ;(state.type = ARRAY_STATE_TYPE), (state.position = 0), (state.size = arraySize), (state.array = new Array(arraySize))
  }
  pushMapState(mapSize) {
    const state = this.getUninitializedStateFromPool()
    ;(state.type = MAP_KEY_STATE_TYPE), (state.readCount = 0), (state.size = mapSize), (state.map = {})
  }
  getUninitializedStateFromPool() {
    if (
      (this.stackHeadPosition++, this.stackHeadPosition === this.stack.length)
    ) {
      const newState = {
        type: void 0,
        size: 0,
        array: void 0,
        position: 0,
        readCount: 0,
        map: void 0,
        key: null
      }
      this.stack.push(newState)
    }
    return this.stack[this.stackHeadPosition]
  }
  release(state) {
    if (this.stack[this.stackHeadPosition] !== state)
      throw new Error(
        'Invalid stack state. Released state is not on top of the stack.'
      )
    if (state.type === ARRAY_STATE_TYPE) {
      const arrayState = state
      ;(arrayState.size = 0), (arrayState.array = void 0), (arrayState.position = 0), (arrayState.type = void 0)
    }
    if (state.type === MAP_KEY_STATE_TYPE || state.type === MAP_VALUE_STATE_TYPE) {
      const mapState = state
      ;(mapState.size = 0), (mapState.map = void 0), (mapState.readCount = 0), (mapState.type = void 0)
    }
    this.stackHeadPosition--
  }
  reset() {
    ;(this.stack.length = 0), (this.stackHeadPosition = -1)
  }
}
var NOT_INITIALIZED = -1,
  EMPTY_DATA_VIEW = new DataView(new ArrayBuffer(0)),
  EMPTY_UINT8_ARRAY = new Uint8Array(EMPTY_DATA_VIEW.buffer)
try {
  EMPTY_DATA_VIEW.getInt8(0)
} catch (error) {
  if (!(error instanceof RangeError))
    throw new Error(
      'This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access'
    )
}
var INSUFFICIENT_DATA_ERROR = new RangeError('Insufficient data'),
  DEFAULT_KEY_DECODER = new StringKeyDecoder()
class MessagePackDecoder {
  constructor(options) {
    ;(this.totalPos = 0),
      (this.pos = 0),
      (this.view = EMPTY_DATA_VIEW),
      (this.bytes = EMPTY_UINT8_ARRAY),
      (this.headByte = NOT_INITIALIZED),
      (this.stack = new DecodingStack()),
      (this.entered = !1),
      (this.extensionCodec = options?.extensionCodec ?? ExtensionCodec.defaultCodec),
      (this.context = options?.context),
      (this.useBigInt64 = options?.useBigInt64 ?? !1),
      (this.rawStrings = options?.rawStrings ?? !1),
      (this.maxStrLength = options?.maxStrLength ?? UINT32_MAX),
      (this.maxBinLength = options?.maxBinLength ?? UINT32_MAX),
      (this.maxArrayLength = options?.maxArrayLength ?? UINT32_MAX),
      (this.maxMapLength = options?.maxMapLength ?? UINT32_MAX),
      (this.maxExtLength = options?.maxExtLength ?? UINT32_MAX),
      (this.keyDecoder = options?.keyDecoder !== void 0 ? options.keyDecoder : DEFAULT_KEY_DECODER),
      (this.mapKeyConverter = options?.mapKeyConverter ?? defaultMapKeyConverter)
  }
  clone() {
    return new MessagePackDecoder({
      extensionCodec: this.extensionCodec,
      context: this.context,
      useBigInt64: this.useBigInt64,
      rawStrings: this.rawStrings,
      maxStrLength: this.maxStrLength,
      maxBinLength: this.maxBinLength,
      maxArrayLength: this.maxArrayLength,
      maxMapLength: this.maxMapLength,
      maxExtLength: this.maxExtLength,
      keyDecoder: this.keyDecoder
    })
  }
  reinitializeState() {
    ;(this.totalPos = 0), (this.headByte = NOT_INITIALIZED), this.stack.reset()
  }
  setBuffer(inputData) {
    const uint8Array = toUint8Array(inputData)
    ;(this.bytes = uint8Array),
      (this.view = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength)),
      (this.pos = 0)
  }
  appendBuffer(additionalData) {
    if (this.headByte === NOT_INITIALIZED && !this.hasRemaining(1)) this.setBuffer(additionalData)
    else {
      const remainingBytes = this.bytes.subarray(this.pos),
        newUInt8Array = toUint8Array(additionalData),
        combinedArray = new Uint8Array(remainingBytes.length + newUInt8Array.length)
      combinedArray.set(remainingBytes), combinedArray.set(newUInt8Array, remainingBytes.length), this.setBuffer(combinedArray)
    }
  }
  hasRemaining(byteCount) {
    return this.view.byteLength - this.pos >= byteCount
  }
  createExtraByteError(position) {
    const { view: currentView, pos: currentPos } = this
    return new RangeError(
      `Extra ${currentView.byteLength - currentPos} of ${currentView.byteLength} byte(s) found at buffer[${position}]`
    )
  }
  decode(inputData) {
    if (this.entered) return this.clone().decode(inputData)
    try {
      ;(this.entered = !0), this.reinitializeState(), this.setBuffer(inputData)
      const decodedResult = this.doDecodeSync()
      if (this.hasRemaining(1)) throw this.createExtraByteError(this.pos)
      return decodedResult
    } finally {
      this.entered = !1
    }
  }
  *decodeMulti(inputData) {
    if (this.entered) {
      yield* this.clone().decodeMulti(inputData)
      return
    }
    try {
      ;(this.entered = !0), this.reinitializeState(), this.setBuffer(inputData)
      while (this.hasRemaining(1)) yield this.doDecodeSync()
    } finally {
      this.entered = !1
    }
  }
  async decodeAsync(asyncChunkIterator) {
    if (this.entered) return this.clone().decodeAsync(asyncChunkIterator)
    try {
      this.entered = !0
      let decodingComplete = !1,
        decodedResult
      for await (const chunk of asyncChunkIterator) {
        if (decodingComplete)
          throw ((this.entered = !1), this.createExtraByteError(this.totalPos))
        this.appendBuffer(chunk)
        try {
          ;(decodedResult = this.doDecodeSync()), (decodingComplete = !0)
        } catch (error) {
          if (!(error instanceof RangeError)) throw error
        }
        this.totalPos += this.pos
      }
      if (decodingComplete) {
        if (this.hasRemaining(1)) throw this.createExtraByteError(this.totalPos)
        return decodedResult
      }
      const { headByte: currentHeadByte, pos: currentPos, totalPos: totalPosition } = this
      throw new RangeError(
        `Insufficient data in parsing ${toHexString(currentHeadByte)} at ${totalPosition} (${currentPos} in the current buffer)`
      )
    } finally {
      this.entered = !1
    }
  }
  decodeArrayStream(inputData) {
    return this.decodeMultiAsync(inputData, !0)
  }
  decodeStream(inputData) {
    return this.decodeMultiAsync(inputData, !1)
  }
  async *decodeMultiAsync(chunkIterator, isArrayStream) {
    if (this.entered) {
      yield* this.clone().decodeMultiAsync(chunkIterator, isArrayStream)
      return
    }
    try {
      this.entered = !0
      let isFirstElement = isArrayStream,
        elementsRemaining = -1
      for await (const chunk of chunkIterator) {
        if (isArrayStream && elementsRemaining === 0) throw this.createExtraByteError(this.totalPos)
        if ((this.appendBuffer(chunk), isFirstElement))
          (elementsRemaining = this.readArraySize()), (isFirstElement = !1), this.complete()
        try {
          while (!0) if ((yield this.doDecodeSync(), --elementsRemaining === 0)) break
        } catch (error) {
          if (!(error instanceof RangeError)) throw error
        }
        this.totalPos += this.pos
      }
    } finally {
      this.entered = !1
    }
  }
  doDecodeSync() {
    decodeLoop: while (!0) {
      const typeByte = this.readHeadByte()
      let decodedValue
      if (typeByte >= 224) decodedValue = typeByte - 256
      else if (typeByte < 192)
        if (typeByte < 128) decodedValue = typeByte
        else if (typeByte < 144) {
          const mapSize = typeByte - 128
          if (mapSize !== 0) {
            this.pushMapState(mapSize), this.complete()
            continue
          } else decodedValue = {}
        } else if (typeByte < 160) {
          const arraySize = typeByte - 144
          if (arraySize !== 0) {
            this.pushArrayState(arraySize), this.complete()
            continue
          } else decodedValue = []
        } else {
          const stringLength = typeByte - 160
          decodedValue = this.decodeString(stringLength, 0)
        }
      else if (typeByte === 192) decodedValue = null
      else if (typeByte === 194) decodedValue = !1
      else if (typeByte === 195) decodedValue = !0
      else if (typeByte === 202) decodedValue = this.readF32()
      else if (typeByte === 203) decodedValue = this.readF64()
      else if (typeByte === 204) decodedValue = this.readU8()
      else if (typeByte === 205) decodedValue = this.readU16()
      else if (typeByte === 206) decodedValue = this.readU32()
      else if (typeByte === 207)
        if (this.useBigInt64) decodedValue = this.readU64AsBigInt()
        else decodedValue = this.readU64()
      else if (typeByte === 208) decodedValue = this.readI8()
      else if (typeByte === 209) decodedValue = this.readI16()
      else if (typeByte === 210) decodedValue = this.readI32()
      else if (typeByte === 211)
        if (this.useBigInt64) decodedValue = this.readI64AsBigInt()
        else decodedValue = this.readI64()
      else if (typeByte === 217) {
        const stringLength = this.lookU8()
        decodedValue = this.decodeString(stringLength, 1)
      } else if (typeByte === 218) {
        const stringLength = this.lookU16()
        decodedValue = this.decodeString(stringLength, 2)
      } else if (typeByte === 219) {
        const stringLength = this.lookU32()
        decodedValue = this.decodeString(stringLength, 4)
      } else if (typeByte === 220) {
        const arrayLength = this.readU16()
        if (arrayLength !== 0) {
          this.pushArrayState(arrayLength), this.complete()
          continue
        } else decodedValue = []
      } else if (typeByte === 221) {
        const arrayLength = this.readU32()
        if (arrayLength !== 0) {
          this.pushArrayState(arrayLength), this.complete()
          continue
        } else decodedValue = []
      } else if (typeByte === 222) {
        const mapSize = this.readU16()
        if (mapSize !== 0) {
          this.pushMapState(mapSize), this.complete()
          continue
        } else decodedValue = {}
      } else if (typeByte === 223) {
        const mapSize = this.readU32()
        if (mapSize !== 0) {
          this.pushMapState(mapSize), this.complete()
          continue
        } else decodedValue = {}
      } else if (typeByte === 196) {
        const binaryLength = this.lookU8()
        decodedValue = this.decodeBinary(binaryLength, 1)
      } else if (typeByte === 197) {
        const binaryLength = this.lookU16()
        decodedValue = this.decodeBinary(binaryLength, 2)
      } else if (typeByte === 198) {
        const binaryLength = this.lookU32()
        decodedValue = this.decodeBinary(binaryLength, 4)
      } else if (typeByte === 212) decodedValue = this.decodeExtension(1, 0)
      else if (typeByte === 213) decodedValue = this.decodeExtension(2, 0)
      else if (typeByte === 214) decodedValue = this.decodeExtension(4, 0)
      else if (typeByte === 215) decodedValue = this.decodeExtension(8, 0)
      else if (typeByte === 216) decodedValue = this.decodeExtension(16, 0)
      else if (typeByte === 199) {
        const extensionLength = this.lookU8()
        decodedValue = this.decodeExtension(extensionLength, 1)
      } else if (typeByte === 200) {
        const extensionLength = this.lookU16()
        decodedValue = this.decodeExtension(extensionLength, 2)
      } else if (typeByte === 201) {
        const extensionLength = this.lookU32()
        decodedValue = this.decodeExtension(extensionLength, 4)
      } throw new MessagePackError(`Unrecognized type byte: ${toHexString(typeByte)}`)
      this.complete()
      const decodingStack = this.stack
      while (decodingStack.length > 0) {
        const currentState = decodingStack.top()
        if (currentState.type === ARRAY_STATE_TYPE)
          if (((currentState.array[currentState.position] = decodedValue), currentState.position++, currentState.position === currentState.size))
            (decodedValue = currentState.array), decodingStack.release(currentState)
          else continue decodeLoop
        else if (currentState.type === MAP_KEY_STATE_TYPE) {
          if (decodedValue === '__proto__') throw new MessagePackError('The key __proto__ is not allowed')
          ;(currentState.key = this.mapKeyConverter(decodedValue)), (currentState.type = MAP_VALUE_STATE_TYPE)
          continue decodeLoop
        } else if (((currentState.map[currentState.key] = decodedValue), currentState.readCount++, currentState.readCount === currentState.size))
          (decodedValue = currentState.map), decodingStack.release(currentState)
        else {
          ;(currentState.key = null), (currentState.type = MAP_KEY_STATE_TYPE)
          continue decodeLoop
        }
      }
      return decodedValue
    }
  }
  readHeadByte() {
    if (this.headByte === NOT_INITIALIZED) this.headByte = this.readU8()
    return this.headByte
  }
  complete() {
    this.headByte = NOT_INITIALIZED
  }
  readArraySize() {
    const typeByte = this.readHeadByte()
    switch (typeByte) {
      case 220:
        return this.readU16()
      case 221:
        return this.readU32()
      default:
        if (typeByte < 160) return typeByte - 144
        else throw new MessagePackError(`Unrecognized array type byte: ${toHexString(typeByte)}`)
    }
  }
  pushMapState(mapSize) {
    if (mapSize > this.maxMapLength)
      throw new MessagePackError(
        `Max length exceeded: map length (${mapSize}) > maxMapLength (${this.maxMapLength})`
      )
    this.stack.pushMapState(mapSize)
  }
  pushArrayState(arraySize) {
    if (arraySize > this.maxArrayLength)
      throw new MessagePackError(
        `Max length exceeded: array length (${arraySize}) > maxArrayLength (${this.maxArrayLength})`
      )
    this.stack.pushArrayState(arraySize)
  }
  decodeString(stringLength, headerSize) {
    if (!this.rawStrings || this.stateIsMapKey())
      return this.decodeUtf8String(stringLength, headerSize)
    return this.decodeBinary(stringLength, headerSize)
  }
  decodeUtf8String(stringLength, headerSize) {
    if (stringLength > this.maxStrLength)
      throw new MessagePackError(
        `Max length exceeded: UTF-8 byte length (${stringLength}) > maxStrLength (${this.maxStrLength})`
      )
    if (this.bytes.byteLength < this.pos + headerSize + stringLength) throw INSUFFICIENT_DATA_ERROR
    const stringStartPos = this.pos + headerSize
    let decodedString
    if (this.stateIsMapKey() && this.keyDecoder?.canBeCached(stringLength))
      decodedString = this.keyDecoder.decode(this.bytes, stringStartPos, stringLength)
    else decodedString = decodeStringOptimized(this.bytes, stringStartPos, stringLength)
    return (this.pos += headerSize + stringLength), decodedString
  }
  stateIsMapKey() {
    if (this.stack.length > 0) return this.stack.top().type === MAP_KEY_STATE_TYPE
    return !1
  }
  decodeBinary(binaryLength, headerSize) {
    if (binaryLength > this.maxBinLength)
      throw new MessagePackError(
        `Max length exceeded: bin length (${binaryLength}) > maxBinLength (${this.maxBinLength})`
      )
    if (!this.hasRemaining(binaryLength + headerSize)) throw INSUFFICIENT_DATA_ERROR
    const binaryStartPos = this.pos + headerSize,
      binaryData = this.bytes.subarray(binaryStartPos, binaryStartPos + binaryLength)
    return (this.pos += headerSize + binaryLength), binaryData
  }
  decodeExtension(extensionLength, headerSize) {
    if (extensionLength > this.maxExtLength)
      throw new MessagePackError(
        `Max length exceeded: ext length (${extensionLength}) > maxExtLength (${this.maxExtLength})`
      )
    const extensionType = this.view.getInt8(this.pos + headerSize),
      extensionData = this.decodeBinary(extensionLength, headerSize + 1)
    return this.extensionCodec.decode(extensionData, extensionType, this.context)
  }
  lookU8() {
    return this.view.getUint8(this.pos)
  }
  lookU16() {
    return this.view.getUint16(this.pos)
  }
  lookU32() {
    return this.view.getUint32(this.pos)
  }
  readU8() {
    const value = this.view.getUint8(this.pos)
    return this.pos++, value
  }
  readI8() {
    const value = this.view.getInt8(this.pos)
    return this.pos++, value
  }
  readU16() {
    const value = this.view.getUint16(this.pos)
    return (this.pos += 2), value
  }
  readI16() {
    const value = this.view.getInt16(this.pos)
    return (this.pos += 2), value
  }
  readU32() {
    const value = this.view.getUint32(this.pos)
    return (this.pos += 4), value
  }
  readI32() {
    const value = this.view.getInt32(this.pos)
    return (this.pos += 4), value
  }
  readU64() {
    const value = readUint64(this.view, this.pos)
    return (this.pos += 8), value
  }
  readI64() {
    const value = readInt64(this.view, this.pos)
    return (this.pos += 8), value
  }
  readU64AsBigInt() {
    const value = this.view.getBigUint64(this.pos)
    return (this.pos += 8), value
  }
  readI64AsBigInt() {
    const value = this.view.getBigInt64(this.pos)
    return (this.pos += 8), value
  }
  readF32() {
    const value = this.view.getFloat32(this.pos)
    return (this.pos += 4), value
  }
  readF64() {
    const value = this.view.getFloat64(this.pos)
    return (this.pos += 8), value
  }
}
function B0(J, Q) {
  return new H1(Q).decode(J)
}
var clearArray = (array) => {
    let arrayIndex = array.length
    while (--arrayIndex >= 0) array[arrayIndex] = 0
  },
  TreeDescription = function (staticTree, extraBits, extraBase, elements, maxLength) {
    ;(this.static_tree = staticTree),
      (this.extra_bits = extraBits),
      (this.extra_base = extraBase),
      (this.elems = elements),
      (this.max_length = maxLength),
      (this.has_stree = staticTree?.length)
  },
  DynamicTreeDescription = function (dynamicTree, maxCode, staticDescription) {
    ;(this.dyn_tree = dynamicTree), (this.max_code = 0), (this.stat_desc = staticDescription)
  },
  CompressionConfig = function (goodLength, maxLazy, niceLength, maxChain, compressionFunction) {
    ;(this.good_length = goodLength),
      (this.max_lazy = maxLazy),
      (this.nice_length = niceLength),
      (this.max_chain = maxChain),
      (this.func = compressionFunction)
  },
  DeflateState = function () {
    ;(this.strm = null),
      (this.status = 0),
      (this.pending_buf = null),
      (this.pending_buf_size = 0),
      (this.pending_out = 0),
      (this.pending = 0),
      (this.wrap = 0),
      (this.gzhead = null),
      (this.gzindex = 0),
      (this.method = x1),
      (this.last_flush = -1),
      (this.w_size = 0),
      (this.w_bits = 0),
      (this.w_mask = 0),
      (this.window = null),
      (this.window_size = 0),
      (this.prev = null),
      (this.head = null),
      (this.ins_h = 0),
      (this.hash_size = 0),
      (this.hash_bits = 0),
      (this.hash_mask = 0),
      (this.hash_shift = 0),
      (this.block_start = 0),
      (this.match_length = 0),
      (this.prev_match = 0),
      (this.match_available = 0),
      (this.strstart = 0),
      (this.match_start = 0),
      (this.lookahead = 0),
      (this.prev_length = 0),
      (this.max_chain_length = 0),
      (this.max_lazy_match = 0),
      (this.level = 0),
      (this.strategy = 0),
      (this.good_match = 0),
      (this.nice_match = 0),
      (this.dyn_ltree = new Uint16Array(ZJ * 2)),
      (this.dyn_dtree = new Uint16Array((2 * FJ + 1) * 2)),
      (this.bl_tree = new Uint16Array((2 * zJ + 1) * 2)),
      F0(this.dyn_ltree),
      F0(this.dyn_dtree),
      F0(this.bl_tree),
      (this.l_desc = null),
      (this.d_desc = null),
      (this.bl_desc = null),
      (this.bl_count = new Uint16Array(HJ + 1)),
      (this.heap = new Uint16Array(2 * e1 + 1)),
      F0(this.heap),
      (this.heap_len = 0),
      (this.heap_max = 0),
      (this.depth = new Uint16Array(2 * e1 + 1)),
      F0(this.depth),
      (this.sym_buf = 0),
      (this.lit_bufsize = 0),
      (this.sym_next = 0),
      (this.sym_end = 0),
      (this.opt_len = 0),
      (this.static_len = 0),
      (this.matches = 0),
      (this.insert = 0),
      (this.bi_buf = 0),
      (this.bi_valid = 0)
  },
  ZlibStream = function () {
    ;(this.input = null),
      (this.next_in = 0),
      (this.avail_in = 0),
      (this.total_in = 0),
      (this.output = null),
      (this.next_out = 0),
      (this.avail_out = 0),
      (this.total_out = 0),
      (this.msg = ''),
      (this.state = null),
      (this.data_type = 2),
      (this.adler = 0)
  },
  DeflateStream = function (options) {
    this.options = O1.assign(
      {
        level: aJ,
        method: sJ,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: eJ
      },
      J || {}
    )
    const Q = this.options
    if (Q.raw && Q.windowBits > 0) Q.windowBits = -Q.windowBits
    else if (Q.gzip && Q.windowBits > 0 && Q.windowBits < 16) Q.windowBits += 16
    ;(this.err = 0),
      (this.msg = ''),
      (this.ended = !1),
      (this.chunks = []),
      (this.strm = new A6()),
      (this.strm.avail_out = 0)
    let W = n0.deflateInit2(
      this.strm,
      Q.level,
      Q.method,
      Q.windowBits,
      Q.memLevel,
      Q.strategy
    )
    if (W !== C1) throw new Error(L0[W])
    if (Q.header) n0.deflateSetHeader(this.strm, Q.header)
    if (Q.dictionary) {
      let G
      if (typeof Q.dictionary === 'string') G = W1.string2buf(Q.dictionary)
      else if (N6.call(Q.dictionary) === '[object ArrayBuffer]')
        G = new Uint8Array(Q.dictionary)
      else G = Q.dictionary
      if (((W = n0.deflateSetDictionary(this.strm, G)), W !== C1))
        throw new Error(L0[W])
      this._dict_set = !0
    }
  },
  deflateSync = (inputData, options) => {
    const W = new q1(Q)
    if ((W.push(J, !0), W.err)) throw W.msg || L0[W.err]
    return W.result
  },
  deflateRawSync = (inputData, options) => ((options = options || {}), (options.raw = !0), deflateSync(inputData, options)),
  deflateGzipSync = (inputData, options) => ((options = options || {}), (options.gzip = !0), deflateSync(inputData, options)),
  InflateState = function () {
    ;(this.strm = null),
      (this.mode = 0),
      (this.last = !1),
      (this.wrap = 0),
      (this.havedict = !1),
      (this.flags = 0),
      (this.dmax = 0),
      (this.check = 0),
      (this.total = 0),
      (this.head = null),
      (this.wbits = 0),
      (this.wsize = 0),
      (this.whave = 0),
      (this.wnext = 0),
      (this.window = null),
      (this.hold = 0),
      (this.bits = 0),
      (this.length = 0),
      (this.offset = 0),
      (this.extra = 0),
      (this.lencode = null),
      (this.distcode = null),
      (this.lenbits = 0),
      (this.distbits = 0),
      (this.ncode = 0),
      (this.nlen = 0),
      (this.ndist = 0),
      (this.have = 0),
      (this.next = null),
      (this.lens = new Uint16Array(320)),
      (this.work = new Uint16Array(288)),
      (this.lendyn = null),
      (this.distdyn = null),
      (this.sane = 0),
      (this.back = 0),
      (this.was = 0)
  },
  GzipHeader = function () {
    ;(this.text = 0),
      (this.time = 0),
      (this.xflags = 0),
      (this.os = 0),
      (this.extra = null),
      (this.extra_len = 0),
      (this.name = ''),
      (this.comment = ''),
      (this.hcrc = 0),
      (this.done = !1)
  },
  InflateStream = function (options) {
    this.options = O1.assign(
      { chunkSize: 65536, windowBits: 15, to: '' },
      J || {}
    )
    const Q = this.options
    if (Q.raw && Q.windowBits >= 0 && Q.windowBits < 16) {
      if (((Q.windowBits = -Q.windowBits), Q.windowBits === 0))
        Q.windowBits = -15
    }
    if (Q.windowBits >= 0 && Q.windowBits < 16 && !J?.windowBits)
      Q.windowBits += 32
    if (Q.windowBits > 15 && Q.windowBits < 48) {
      if ((Q.windowBits & 15) === 0) Q.windowBits |= 15
    }
    ;(this.err = 0),
      (this.msg = ''),
      (this.ended = !1),
      (this.chunks = []),
      (this.strm = new A6()),
      (this.strm.avail_out = 0)
    let W = U0.inflateInit2(this.strm, Q.windowBits)
    if (W !== Q1) throw new Error(L0[W])
    if (
      ((this.header = new mW()),
      U0.inflateGetHeader(this.strm, this.header),
      Q.dictionary)
    ) {
      if (typeof Q.dictionary === 'string')
        Q.dictionary = W1.string2buf(Q.dictionary)
      else if (m6.call(Q.dictionary) === '[object ArrayBuffer]')
        Q.dictionary = new Uint8Array(Q.dictionary)
      if (Q.raw) {
        if (((W = U0.inflateSetDictionary(this.strm, Q.dictionary)), W !== Q1))
          throw new Error(L0[W])
      }
    }
  },
  inflateSync = (inputData, options) => {
    const W = new X1(Q)
    if ((W.push(J), W.err)) throw W.msg || L0[W.err]
    return W.result
  },
  inflateRawSync = (inputData, options) => (
    (Q = Q || {}), (Q.raw = !0), P8(J, Q)
  ) /*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
var Z_NO_FLUSH = 0,
  Z_PARTIAL_FLUSH = 1,
  Z_SYNC_FLUSH = 2,
  Z_FULL_FLUSH = 3,
  MIN_MATCH = 258,
  DIST_CODES = 29,
  LITERALS = 256,
  CODE_LENGTHS = LITERALS + 1 + DIST_CODES,
  D_CODES = 30,
  BL_CODES = 19,
  HEAP_SIZE = 2 * CODE_LENGTHS + 1,
  MAX_BITS = 15,
  BUFSIZE = 16,
  REP_3_6 = 7,
  END_BLOCK = 256,
  REPZ_3_10 = 16,
  REPZ_11_138 = 17,
  REPZ_31_258 = 18,
  extra_lbits = new Uint8Array([
    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5,
    5, 5, 5, 0
  ]),
  extra_dbits = new Uint8Array([
    0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10,
    11, 11, 12, 12, 13, 13
  ]),
  extra_blbits = new Uint8Array([
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7
  ]),
  bl_order = new Uint8Array([
    16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15
  ]),
  LITERALS_BUFSIZE = 512,
  static_ltree = new Array((CODE_LENGTHS + 2) * 2)
clearArray(static_ltree)
var static_dtree = new Array(D_CODES * 2)
clearArray(static_dtree)
var dyn_dtree = new Array(LITERALS_BUFSIZE)
clearArray(dyn_dtree)
var length_code = new Array(MIN_MATCH - MIN_MATCH + 1)
clearArray(length_code)
var dist_code = new Array(DIST_CODES)
clearArray(dist_code)
var bl_count = new Array(D_CODES)
clearArray(bl_count)
static_l_desc,
  static_d_desc,
  static_bl_desc,
  d_code = (distance) => {
    return distance < 256 ? dyn_dtree[distance] : dyn_dtree[256 + (distance >>> 7)]
  },
  put_word = (stream, word) => {
    ;(stream.pending_buf[stream.pending++] = word & 255),
      (stream.pending_buf[stream.pending++] = (word >>> 8) & 255)
  },
  send_bits = (stream, value, bitLength) => {
    if (stream.bi_valid > BUFSIZE - bitLength)
      (stream.bi_buf |= (value << stream.bi_valid) & 65535),
        put_word(stream, stream.bi_buf),
        (stream.bi_buf = value >> (BUFSIZE - stream.bi_valid)),
        (stream.bi_valid += bitLength - BUFSIZE)
    else (stream.bi_buf |= (value << stream.bi_valid) & 65535), (stream.bi_valid += bitLength)
  },
  send_code = (stream, code, tree) => {
    send_bits(stream, tree[code * 2], tree[code * 2 + 1])
  },
  bi_reverse = (code, len) => {
    let result = 0
    do (result |= code & 1), (code >>>= 1), (result <<= 1)
    while (--len > 0)
    return result >>> 1
  },
  bi_flush = (stream) => {
    if (stream.bi_valid === 16) put_word(stream, stream.bi_buf), (stream.bi_buf = 0), (stream.bi_valid = 0)
    else if (stream.bi_valid >= 8)
      (stream.pending_buf[stream.pending++] = stream.bi_buf & 255),
        (stream.bi_buf >>= 8),
        (stream.bi_valid -= 8)
  },
  gen_bitlen = (compressionState, treeDescription) => {
    const { dyn_tree: tree, max_code: maxCode } = treeDescription,
      static_tree = treeDescription.stat_desc.static_tree,
      has_stree = treeDescription.stat_desc.has_stree,
      extra_bits = treeDescription.stat_desc.extra_bits,
      extra_base = treeDescription.stat_desc.extra_base,
      max_length = treeDescription.stat_desc.max_length
    let heapIndex,
      symbol,
      treeElement,
      bitLength,
      extra,
      treeCount,
      overflow = 0
    for (bitLength = 0; bitLength <= MAX_BITS; bitLength++) compressionState.bl_count[bitLength] = 0
    tree[compressionState.heap[compressionState.heap_max] * 2 + 1] = 0
    for (heapIndex = compressionState.heap_max + 1; heapIndex < HEAP_SIZE; heapIndex++) {
      if (((symbol = compressionState.heap[heapIndex]), (bitLength = tree[tree[symbol * 2 + 1] * 2 + 1] + 1), bitLength > max_length))
        (bitLength = max_length), overflow++
      if (((tree[symbol * 2 + 1] = bitLength), symbol > maxCode)) continue
      if ((compressionState.bl_count[bitLength]++, (extra = 0), symbol >= extra_base)) extra = extra_bits[symbol - extra_base]
      if (((treeCount = tree[symbol * 2]), (compressionState.opt_len += treeCount * (bitLength + extra)), has_stree))
        compressionState.static_len += treeCount * (static_tree[symbol * 2 + 1] + extra)
    }
    if (overflow === 0) return
    do {
      bitLength = max_length - 1
      while (compressionState.bl_count[bitLength] === 0) bitLength--
      compressionState.bl_count[bitLength]--, (compressionState.bl_count[bitLength + 1] += 2), compressionState.bl_count[max_length]--, (overflow -= 2)
    } while (overflow > 0)
    for (bitLength = max_length; bitLength !== 0; bitLength--) {
      symbol = compressionState.bl_count[bitLength]
      while (symbol !== 0) {
        if (((treeElement = compressionState.heap[--heapIndex]), treeElement > maxCode)) continue
        if (tree[treeElement * 2 + 1] !== bitLength)
          (compressionState.opt_len += (bitLength - tree[treeElement * 2 + 1]) * tree[treeElement * 2]), (tree[treeElement * 2 + 1] = bitLength)
        symbol--
      }
    }
  },
  gen_codes = (tree, maxCode, blCount) => {
    const nextCode = new Array(MAX_BITS + 1)
    let code = 0,
      bits,
      symbol
    for (bits = 1; bits <= MAX_BITS; bits++) (code = (code + blCount[bits - 1]) << 1), (nextCode[bits] = code)
    for (symbol = 0; symbol <= maxCode; symbol++) {
      const len = tree[symbol * 2 + 1]
      if (len === 0) continue
      tree[symbol * 2] = bi_reverse(nextCode[len]++, len)
    }
  },
  tr_static_init = () => {
    let symbol, count, data, length, code
    const dist = new Array(MAX_BITS + 1)
    code = 0
    for (length = 0; length < DIST_CODES - 1; length++) {
      dist_code[length] = code
      for (symbol = 0; symbol < 1 << extra_lbits[length]; symbol++) length_code[code++] = length
    }
    ;(length_code[code - 1] = length), (code = 0)
    for (length = 0; length < 16; length++) {
      bl_count[length] = code
      for (symbol = 0; symbol < 1 << extra_dbits[length]; symbol++) dyn_dtree[code++] = length
    }
    code >>= 7
    for (; length < D_CODES; length++) {
      bl_count[length] = code << 7
      for (symbol = 0; symbol < 1 << (extra_dbits[length] - 7); symbol++) dyn_dtree[256 + code++] = length
    }
    for (count = 0; count <= MAX_BITS; count++) dist[count] = 0
    symbol = 0
    while (symbol <= 143) (static_ltree[symbol * 2 + 1] = 8), symbol++, dist[8]++
    while (symbol <= 255) (static_ltree[symbol * 2 + 1] = 9), symbol++, dist[9]++
    while (symbol <= 279) (static_ltree[symbol * 2 + 1] = 7), symbol++, dist[7]++
    while (symbol <= 287) (static_ltree[symbol * 2 + 1] = 8), symbol++, dist[8]++
    gen_codes(static_ltree, CODE_LENGTHS + 1, dist)
    for (symbol = 0; symbol < D_CODES; symbol++) (static_dtree[symbol * 2 + 1] = 5), (static_dtree[symbol * 2] = bi_reverse(symbol, 5))
    ;(static_l_desc = new TreeDescription(static_ltree, extra_lbits, LITERALS + 1, CODE_LENGTHS, MAX_BITS)),
      (static_d_desc = new TreeDescription(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS)),
      (static_bl_desc = new TreeDescription(bl_count, extra_blbits, 0, BL_CODES, REP_3_6))
  },
  init_block = (compressionState) => {
    let symbol
    for (symbol = 0; symbol < CODE_LENGTHS; symbol++) compressionState.dyn_ltree[symbol * 2] = 0
    for (symbol = 0; symbol < D_CODES; symbol++) compressionState.dyn_dtree[symbol * 2] = 0
    for (symbol = 0; symbol < BL_CODES; symbol++) compressionState.bl_tree[symbol * 2] = 0
    ;(compressionState.dyn_ltree[END_BLOCK * 2] = 1),
      (compressionState.opt_len = compressionState.static_len = 0),
      (compressionState.sym_next = compressionState.matches = 0)
  },
  bi_windup = (stream) => {
    if (stream.bi_valid > 8) put_word(stream, stream.bi_buf)
    else if (stream.bi_valid > 0) stream.pending_buf[stream.pending++] = stream.bi_buf
    ;(stream.bi_buf = 0), (stream.bi_valid = 0)
  },
  smaller = (tree, element1, element2, depth) => {
    const e1 = element1 * 2,
      e2 = element2 * 2
    return tree[e1] < tree[e2] || (tree[e1] === tree[e2] && depth[element1] <= depth[element2])
  },
  pqdownheap = (compressionState, tree, heapIndex) => {
    const element = compressionState.heap[heapIndex]
    let child = heapIndex << 1
    while (child <= compressionState.heap_len) {
      if (child < compressionState.heap_len && smaller(tree, compressionState.heap[child + 1], compressionState.heap[child], compressionState.depth)) child++
      if (smaller(tree, element, compressionState.heap[child], compressionState.depth)) break
      ;(compressionState.heap[heapIndex] = compressionState.heap[child]), (heapIndex = child), (child <<= 1)
    }
    compressionState.heap[heapIndex] = element
  },
  x8 = (J, Q, W) => {
    let G,
      V,
      q = 0,
      Y,
      X
    if (J.sym_next !== 0)
      do
        if (
          ((G = J.pending_buf[J.sym_buf + q++] & 255),
          (G += (J.pending_buf[J.sym_buf + q++] & 255) << 8),
          (V = J.pending_buf[J.sym_buf + q++]),
          G === 0)
        )
          W0(J, V, Q)
        else {
          if (((Y = e0[V]), W0(J, Y + G1 + 1, Q), (X = r1[Y]), X !== 0))
            (V -= X8[Y]), n(J, V, X)
          if ((G--, (Y = $6(G)), W0(J, Y, W), (X = R1[Y]), X !== 0))
            (G -= L1[Y]), n(J, G, X)
        }
      while (q < J.sym_next)
    W0(J, q8, Q)
  },
  o1 = (J, Q) => {
    const W = Q.dyn_tree,
      G = Q.stat_desc.static_tree,
      V = Q.stat_desc.has_stree,
      q = Q.stat_desc.elems
    let Y,
      X,
      z = -1,
      U
    ;(J.heap_len = 0), (J.heap_max = Y6)
    for (Y = 0; Y < q; Y++)
      if (W[Y * 2] !== 0) (J.heap[++J.heap_len] = z = Y), (J.depth[Y] = 0)
      else W[Y * 2 + 1] = 0
    while (J.heap_len < 2)
      if (
        ((U = J.heap[++J.heap_len] = z < 2 ? ++z : 0),
        (W[U * 2] = 1),
        (J.depth[U] = 0),
        J.opt_len--,
        V)
      )
        J.static_len -= G[U * 2 + 1]
    Q.max_code = z
    for (Y = J.heap_len >> 1; Y >= 1; Y--) h1(J, W, Y)
    U = q
    do
      (Y = J.heap[1]),
        (J.heap[1] = J.heap[J.heap_len--]),
        h1(J, W, 1),
        (X = J.heap[1]),
        (J.heap[--J.heap_max] = Y),
        (J.heap[--J.heap_max] = X),
        (W[U * 2] = W[Y * 2] + W[X * 2]),
        (J.depth[U] = (J.depth[Y] >= J.depth[X] ? J.depth[Y] : J.depth[X]) + 1),
        (W[Y * 2 + 1] = W[X * 2 + 1] = U),
        (J.heap[1] = U++),
        h1(J, W, 1)
    while (J.heap_len >= 2)
    ;(J.heap[--J.heap_max] = J.heap[1]), N5(J, Q), j6(W, z, J.bl_count)
  },
  O8 = (J, Q, W) => {
    let G,
      V = -1,
      q,
      Y = Q[1],
      X = 0,
      z = 7,
      U = 4
    if (Y === 0) (z = 138), (U = 3)
    Q[(W + 1) * 2 + 1] = 65535
    for (G = 0; G <= W; G++) {
      if (((q = Y), (Y = Q[(G + 1) * 2 + 1]), ++X < z && q === Y)) continue
      else if (X < U) J.bl_tree[q * 2] += X
      else if (q !== 0) {
        if (q !== V) J.bl_tree[q * 2]++
        J.bl_tree[P6 * 2]++
      } else if (X <= 10) J.bl_tree[K6 * 2]++
      else J.bl_tree[F6 * 2]++
      if (((X = 0), (V = q), Y === 0)) (z = 138), (U = 3)
      else if (q === Y) (z = 6), (U = 3)
      else (z = 7), (U = 4)
    }
  },
  D8 = (J, Q, W) => {
    let G,
      V = -1,
      q,
      Y = Q[1],
      X = 0,
      z = 7,
      U = 4
    if (Y === 0) (z = 138), (U = 3)
    for (G = 0; G <= W; G++) {
      if (((q = Y), (Y = Q[(G + 1) * 2 + 1]), ++X < z && q === Y)) continue
      else if (X < U)
        do W0(J, q, J.bl_tree)
        while (--X !== 0)
      else if (q !== 0) {
        if (q !== V) W0(J, q, J.bl_tree), X--
        W0(J, P6, J.bl_tree), n(J, X - 3, 2)
      } else if (X <= 10) W0(J, K6, J.bl_tree), n(J, X - 3, 3)
      else W0(J, F6, J.bl_tree), n(J, X - 11, 7)
      if (((X = 0), (V = q), Y === 0)) (z = 138), (U = 3)
      else if (q === Y) (z = 6), (U = 3)
      else (z = 7), (U = 4)
    }
  },
  g5 = (J) => {
    let Q
    O8(J, J.dyn_ltree, J.l_desc.max_code),
      O8(J, J.dyn_dtree, J.d_desc.max_code),
      o1(J, J.bl_desc)
    for (Q = V8 - 1; Q >= 3; Q--) if (J.bl_tree[z6[Q] * 2 + 1] !== 0) break
    return (J.opt_len += 3 * (Q + 1) + 5 + 5 + 4), Q
  },
  T5 = (J, Q, W, G) => {
    let V
    n(J, Q - 257, 5), n(J, W - 1, 5), n(J, G - 4, 4)
    for (V = 0; V < G; V++) n(J, J.bl_tree[z6[V] * 2 + 1], 3)
    D8(J, J.dyn_ltree, Q - 1), D8(J, J.dyn_dtree, W - 1)
  },
  v5 = (J) => {
    let Q = 4093624447,
      W
    for (W = 0; W <= 31; W++, Q >>>= 1)
      if (Q & 1 && J.dyn_ltree[W * 2] !== 0) return 0
    if (J.dyn_ltree[18] !== 0 || J.dyn_ltree[20] !== 0 || J.dyn_ltree[26] !== 0)
      return 1
    for (W = 32; W < G1; W++) if (J.dyn_ltree[W * 2] !== 0) return 1
    return 0
  },
  w8 = !1,
  y5 = (J) => {
    if (!w8) S5(), (w8 = !0)
    ;(J.l_desc = new f1(J.dyn_ltree, Z6)),
      (J.d_desc = new f1(J.dyn_dtree, H6)),
      (J.bl_desc = new f1(J.bl_tree, k6)),
      (J.bi_buf = 0),
      (J.bi_valid = 0),
      M6(J)
  },
  L6 = (J, Q, W, G) => {
    if ((n(J, (L5 << 1) + (G ? 1 : 0), 3), R6(J), s0(J, W), s0(J, ~W), W))
      J.pending_buf.set(J.window.subarray(Q, Q + W), J.pending)
    J.pending += W
  },
  E5 = (J) => {
    n(J, U6 << 1, 3), W0(J, q8, X0), A5(J)
  },
  f5 = (J, Q, W, G) => {
    let V,
      q,
      Y = 0
    if (J.level > 0) {
      if (J.strm.data_type === 2) J.strm.data_type = v5(J)
      if (
        (o1(J, J.l_desc),
        o1(J, J.d_desc),
        (Y = g5(J)),
        (V = (J.opt_len + 3 + 7) >>> 3),
        (q = (J.static_len + 3 + 7) >>> 3),
        q <= V)
      )
        V = q
    } else V = q = W + 5
    if (W + 4 <= V && Q !== -1) L6(J, Q, W, G)
    else if (J.strategy === 4 || q === V)
      n(J, (U6 << 1) + (G ? 1 : 0), 3), x8(J, X0, l0)
    else
      n(J, (C5 << 1) + (G ? 1 : 0), 3),
        T5(J, J.l_desc.max_code + 1, J.d_desc.max_code + 1, Y + 1),
        x8(J, J.dyn_ltree, J.dyn_dtree)
    if ((M6(J), G)) R6(J)
  },
  h5 = (J, Q, W) => {
    if (
      ((J.pending_buf[J.sym_buf + J.sym_next++] = Q),
      (J.pending_buf[J.sym_buf + J.sym_next++] = Q >> 8),
      (J.pending_buf[J.sym_buf + J.sym_next++] = W),
      Q === 0)
    )
      J.dyn_ltree[W * 2]++
    else
      J.matches++,
        Q--,
        J.dyn_ltree[(e0[W] + G1 + 1) * 2]++,
        J.dyn_dtree[$6(Q) * 2]++
    return J.sym_next === J.sym_end
  },
  p5 = y5,
  b5 = L6,
  u5 = f5,
  m5 = h5,
  c5 = E5,
  _5 = {
    _tr_init: p5,
    _tr_stored_block: b5,
    _tr_flush_block: u5,
    _tr_tally: m5,
    _tr_align: c5
  },
  d5 = (J, Q, W, G) => {
    let V = (J & 65535) | 0,
      q = ((J >>> 16) & 65535) | 0,
      Y = 0
    while (W !== 0) {
      ;(Y = W > 2000 ? 2000 : W), (W -= Y)
      do (V = (V + Q[G++]) | 0), (q = (q + V) | 0)
      while (--Y)
      ;(V %= 65521), (q %= 65521)
    }
    return V | (q << 16) | 0
  },
  t0 = d5,
  i5 = () => {
    let J,
      Q = []
    for (var W = 0; W < 256; W++) {
      J = W
      for (var G = 0; G < 8; G++) J = J & 1 ? 3988292384 ^ (J >>> 1) : J >>> 1
      Q[W] = J
    }
    return Q
  },
  l5 = new Uint32Array(i5()),
  n5 = (J, Q, W, G) => {
    const V = l5,
      q = G + W
    J ^= -1
    for (let Y = G; Y < q; Y++) J = (J >>> 8) ^ V[(J ^ Q[Y]) & 255]
    return J ^ -1
  },
  _ = n5,
  L0 = {
    2: 'need dictionary',
    1: 'stream end',
    0: '',
    '-1': 'file error',
    '-2': 'stream error',
    '-3': 'data error',
    '-4': 'insufficient memory',
    '-5': 'buffer error',
    '-6': 'incompatible version'
  },
  x0 = {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_MEM_ERROR: -4,
    Z_BUF_ERROR: -5,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    Z_BINARY: 0,
    Z_TEXT: 1,
    Z_UNKNOWN: 2,
    Z_DEFLATED: 8
  },
  {
    _tr_init: r5,
    _tr_stored_block: a1,
    _tr_flush_block: o5,
    _tr_tally: Z0,
    _tr_align: a5
  } = _5,
  {
    Z_NO_FLUSH: H0,
    Z_PARTIAL_FLUSH: e5,
    Z_FULL_FLUSH: s5,
    Z_FINISH: a,
    Z_BLOCK: A8,
    Z_OK: d,
    Z_STREAM_END: N8,
    Z_STREAM_ERROR: Q0,
    Z_DATA_ERROR: t5,
    Z_BUF_ERROR: p1,
    Z_DEFAULT_COMPRESSION: JJ,
    Z_FILTERED: WJ,
    Z_HUFFMAN_ONLY: k1,
    Z_RLE: QJ,
    Z_FIXED: GJ,
    Z_DEFAULT_STRATEGY: VJ,
    Z_UNKNOWN: qJ,
    Z_DEFLATED: x1
  } = x0,
  XJ = 9,
  UJ = 15,
  YJ = 8,
  PJ = 29,
  KJ = 256,
  e1 = KJ + 1 + PJ,
  FJ = 30,
  zJ = 19,
  ZJ = 2 * e1 + 1,
  HJ = 15,
  T = 3,
  z0 = 258,
  G0 = z0 + T + 1,
  kJ = 32,
  v0 = 42,
  U8 = 57,
  s1 = 69,
  t1 = 73,
  J8 = 91,
  W8 = 103,
  M0 = 113,
  d0 = 666,
  l = 1,
  f0 = 2,
  C0 = 3,
  h0 = 4,
  $J = 3,
  R0 = (J, Q) => {
    return (J.msg = L0[Q]), Q
  },
  S8 = (J) => {
    return J * 2 - (J > 4 ? 9 : 0)
  },
  F0 = (J) => {
    let Q = J.length
    while (--Q >= 0) J[Q] = 0
  },
  BJ = (J) => {
    let Q,
      W,
      G,
      V = J.w_size
    ;(Q = J.hash_size), (G = Q)
    do (W = J.head[--G]), (J.head[G] = W >= V ? W - V : 0)
    while (--Q)
    ;(Q = V), (G = Q)
    do (W = J.prev[--G]), (J.prev[G] = W >= V ? W - V : 0)
    while (--Q)
  },
  jJ = (J, Q, W) => ((Q << J.hash_shift) ^ W) & J.hash_mask,
  k0 = jJ,
  r = (J) => {
    const Q = J.state
    let W = Q.pending
    if (W > J.avail_out) W = J.avail_out
    if (W === 0) return
    if (
      (J.output.set(
        Q.pending_buf.subarray(Q.pending_out, Q.pending_out + W),
        J.next_out
      ),
      (J.next_out += W),
      (Q.pending_out += W),
      (J.total_out += W),
      (J.avail_out -= W),
      (Q.pending -= W),
      Q.pending === 0)
    )
      Q.pending_out = 0
  },
  o = (J, Q) => {
    o5(
      J,
      J.block_start >= 0 ? J.block_start : -1,
      J.strstart - J.block_start,
      Q
    ),
      (J.block_start = J.strstart),
      r(J.strm)
  },
  E = (J, Q) => {
    J.pending_buf[J.pending++] = Q
  },
  _0 = (J, Q) => {
    ;(J.pending_buf[J.pending++] = (Q >>> 8) & 255),
      (J.pending_buf[J.pending++] = Q & 255)
  },
  Q8 = (J, Q, W, G) => {
    let V = J.avail_in
    if (V > G) V = G
    if (V === 0) return 0
    if (
      ((J.avail_in -= V),
      Q.set(J.input.subarray(J.next_in, J.next_in + V), W),
      J.state.wrap === 1)
    )
      J.adler = t0(J.adler, Q, V, W)
    else if (J.state.wrap === 2) J.adler = _(J.adler, Q, V, W)
    return (J.next_in += V), (J.total_in += V), V
  },
  C6 = (J, Q) => {
    let { max_chain_length: W, strstart: G } = J,
      V,
      q,
      Y = J.prev_length,
      X = J.nice_match
    const z = J.strstart > J.w_size - G0 ? J.strstart - (J.w_size - G0) : 0,
      U = J.window,
      P = J.w_mask,
      $ = J.prev,
      F = J.strstart + z0
    let K = U[G + Y - 1],
      Z = U[G + Y]
    if (J.prev_length >= J.good_match) W >>= 2
    if (X > J.lookahead) X = J.lookahead
    do {
      if (
        ((V = Q),
        U[V + Y] !== Z ||
          U[V + Y - 1] !== K ||
          U[V] !== U[G] ||
          U[++V] !== U[G + 1])
      )
        continue
      ;(G += 2), V++
      do;
      while (
        U[++G] === U[++V] &&
        U[++G] === U[++V] &&
        U[++G] === U[++V] &&
        U[++G] === U[++V] &&
        U[++G] === U[++V] &&
        U[++G] === U[++V] &&
        U[++G] === U[++V] &&
        U[++G] === U[++V] &&
        G < F
      )
      if (((q = z0 - (F - G)), (G = F - z0), q > Y)) {
        if (((J.match_start = Q), (Y = q), q >= X)) break
        ;(K = U[G + Y - 1]), (Z = U[G + Y])
      }
    } while ((Q = $[Q & P]) > z && --W !== 0)
    if (Y <= J.lookahead) return Y
    return J.lookahead
  },
  y0 = (J) => {
    const Q = J.w_size
    let W, G, V
    do {
      if (
        ((G = J.window_size - J.lookahead - J.strstart),
        J.strstart >= Q + (Q - G0))
      ) {
        if (
          (J.window.set(J.window.subarray(Q, Q + Q - G), 0),
          (J.match_start -= Q),
          (J.strstart -= Q),
          (J.block_start -= Q),
          J.insert > J.strstart)
        )
          J.insert = J.strstart
        BJ(J), (G += Q)
      }
      if (J.strm.avail_in === 0) break
      if (
        ((W = Q8(J.strm, J.window, J.strstart + J.lookahead, G)),
        (J.lookahead += W),
        J.lookahead + J.insert >= T)
      ) {
        ;(V = J.strstart - J.insert),
          (J.ins_h = J.window[V]),
          (J.ins_h = k0(J, J.ins_h, J.window[V + 1]))
        while (J.insert)
          if (
            ((J.ins_h = k0(J, J.ins_h, J.window[V + T - 1])),
            (J.prev[V & J.w_mask] = J.head[J.ins_h]),
            (J.head[J.ins_h] = V),
            V++,
            J.insert--,
            J.lookahead + J.insert < T)
          )
            break
      }
    } while (J.lookahead < G0 && J.strm.avail_in !== 0)
  },
  I6 = (J, Q) => {
    let W =
        J.pending_buf_size - 5 > J.w_size ? J.w_size : J.pending_buf_size - 5,
      G,
      V,
      q,
      Y = 0,
      X = J.strm.avail_in
    do {
      if (((G = 65535), (q = (J.bi_valid + 42) >> 3), J.strm.avail_out < q))
        break
      if (
        ((q = J.strm.avail_out - q),
        (V = J.strstart - J.block_start),
        G > V + J.strm.avail_in)
      )
        G = V + J.strm.avail_in
      if (G > q) G = q
      if (
        G < W &&
        ((G === 0 && Q !== a) || Q === H0 || G !== V + J.strm.avail_in)
      )
        break
      if (
        ((Y = Q === a && G === V + J.strm.avail_in ? 1 : 0),
        a1(J, 0, 0, Y),
        (J.pending_buf[J.pending - 4] = G),
        (J.pending_buf[J.pending - 3] = G >> 8),
        (J.pending_buf[J.pending - 2] = ~G),
        (J.pending_buf[J.pending - 1] = ~G >> 8),
        r(J.strm),
        V)
      ) {
        if (V > G) V = G
        J.strm.output.set(
          J.window.subarray(J.block_start, J.block_start + V),
          J.strm.next_out
        ),
          (J.strm.next_out += V),
          (J.strm.avail_out -= V),
          (J.strm.total_out += V),
          (J.block_start += V),
          (G -= V)
      }
      if (G)
        Q8(J.strm, J.strm.output, J.strm.next_out, G),
          (J.strm.next_out += G),
          (J.strm.avail_out -= G),
          (J.strm.total_out += G)
    } while (Y === 0)
    if (((X -= J.strm.avail_in), X)) {
      if (X >= J.w_size)
        (J.matches = 2),
          J.window.set(
            J.strm.input.subarray(J.strm.next_in - J.w_size, J.strm.next_in),
            0
          ),
          (J.strstart = J.w_size),
          (J.insert = J.strstart)
      else {
        if (J.window_size - J.strstart <= X) {
          if (
            ((J.strstart -= J.w_size),
            J.window.set(J.window.subarray(J.w_size, J.w_size + J.strstart), 0),
            J.matches < 2)
          )
            J.matches++
          if (J.insert > J.strstart) J.insert = J.strstart
        }
        J.window.set(
          J.strm.input.subarray(J.strm.next_in - X, J.strm.next_in),
          J.strstart
        ),
          (J.strstart += X),
          (J.insert += X > J.w_size - J.insert ? J.w_size - J.insert : X)
      }
      J.block_start = J.strstart
    }
    if (J.high_water < J.strstart) J.high_water = J.strstart
    if (Y) return h0
    if (
      Q !== H0 &&
      Q !== a &&
      J.strm.avail_in === 0 &&
      J.strstart === J.block_start
    )
      return f0
    if (
      ((q = J.window_size - J.strstart),
      J.strm.avail_in > q && J.block_start >= J.w_size)
    ) {
      if (
        ((J.block_start -= J.w_size),
        (J.strstart -= J.w_size),
        J.window.set(J.window.subarray(J.w_size, J.w_size + J.strstart), 0),
        J.matches < 2)
      )
        J.matches++
      if (((q += J.w_size), J.insert > J.strstart)) J.insert = J.strstart
    }
    if (q > J.strm.avail_in) q = J.strm.avail_in
    if (q)
      Q8(J.strm, J.window, J.strstart, q),
        (J.strstart += q),
        (J.insert += q > J.w_size - J.insert ? J.w_size - J.insert : q)
    if (J.high_water < J.strstart) J.high_water = J.strstart
    if (
      ((q = (J.bi_valid + 42) >> 3),
      (q = J.pending_buf_size - q > 65535 ? 65535 : J.pending_buf_size - q),
      (W = q > J.w_size ? J.w_size : q),
      (V = J.strstart - J.block_start),
      V >= W || ((V || Q === a) && Q !== H0 && J.strm.avail_in === 0 && V <= q))
    )
      (G = V > q ? q : V),
        (Y = Q === a && J.strm.avail_in === 0 && G === V ? 1 : 0),
        a1(J, J.block_start, G, Y),
        (J.block_start += G),
        r(J.strm)
    return Y ? C0 : l
  },
  b1 = (J, Q) => {
    let W, G
    for (;;) {
      if (J.lookahead < G0) {
        if ((y0(J), J.lookahead < G0 && Q === H0)) return l
        if (J.lookahead === 0) break
      }
      if (((W = 0), J.lookahead >= T))
        (J.ins_h = k0(J, J.ins_h, J.window[J.strstart + T - 1])),
          (W = J.prev[J.strstart & J.w_mask] = J.head[J.ins_h]),
          (J.head[J.ins_h] = J.strstart)
      if (W !== 0 && J.strstart - W <= J.w_size - G0) J.match_length = C6(J, W)
      if (J.match_length >= T)
        if (
          ((G = Z0(J, J.strstart - J.match_start, J.match_length - T)),
          (J.lookahead -= J.match_length),
          J.match_length <= J.max_lazy_match && J.lookahead >= T)
        ) {
          J.match_length--
          do
            J.strstart++,
              (J.ins_h = k0(J, J.ins_h, J.window[J.strstart + T - 1])),
              (W = J.prev[J.strstart & J.w_mask] = J.head[J.ins_h]),
              (J.head[J.ins_h] = J.strstart)
          while (--J.match_length !== 0)
          J.strstart++
        } else
          (J.strstart += J.match_length),
            (J.match_length = 0),
            (J.ins_h = J.window[J.strstart]),
            (J.ins_h = k0(J, J.ins_h, J.window[J.strstart + 1]))
      else (G = Z0(J, 0, J.window[J.strstart])), J.lookahead--, J.strstart++
      if (G) {
        if ((o(J, !1), J.strm.avail_out === 0)) return l
      }
    }
    if (((J.insert = J.strstart < T - 1 ? J.strstart : T - 1), Q === a)) {
      if ((o(J, !0), J.strm.avail_out === 0)) return C0
      return h0
    }
    if (J.sym_next) {
      if ((o(J, !1), J.strm.avail_out === 0)) return l
    }
    return f0
  },
  S0 = (J, Q) => {
    let W, G, V
    for (;;) {
      if (J.lookahead < G0) {
        if ((y0(J), J.lookahead < G0 && Q === H0)) return l
        if (J.lookahead === 0) break
      }
      if (((W = 0), J.lookahead >= T))
        (J.ins_h = k0(J, J.ins_h, J.window[J.strstart + T - 1])),
          (W = J.prev[J.strstart & J.w_mask] = J.head[J.ins_h]),
          (J.head[J.ins_h] = J.strstart)
      if (
        ((J.prev_length = J.match_length),
        (J.prev_match = J.match_start),
        (J.match_length = T - 1),
        W !== 0 &&
          J.prev_length < J.max_lazy_match &&
          J.strstart - W <= J.w_size - G0)
      ) {
        if (
          ((J.match_length = C6(J, W)),
          J.match_length <= 5 &&
            (J.strategy === WJ ||
              (J.match_length === T && J.strstart - J.match_start > 4096)))
        )
          J.match_length = T - 1
      }
      if (J.prev_length >= T && J.match_length <= J.prev_length) {
        ;(V = J.strstart + J.lookahead - T),
          (G = Z0(J, J.strstart - 1 - J.prev_match, J.prev_length - T)),
          (J.lookahead -= J.prev_length - 1),
          (J.prev_length -= 2)
        do
          if (++J.strstart <= V)
            (J.ins_h = k0(J, J.ins_h, J.window[J.strstart + T - 1])),
              (W = J.prev[J.strstart & J.w_mask] = J.head[J.ins_h]),
              (J.head[J.ins_h] = J.strstart)
        while (--J.prev_length !== 0)
        if (
          ((J.match_available = 0), (J.match_length = T - 1), J.strstart++, G)
        ) {
          if ((o(J, !1), J.strm.avail_out === 0)) return l
        }
      } else if (J.match_available) {
        if (((G = Z0(J, 0, J.window[J.strstart - 1])), G)) o(J, !1)
        if ((J.strstart++, J.lookahead--, J.strm.avail_out === 0)) return l
      } else (J.match_available = 1), J.strstart++, J.lookahead--
    }
    if (J.match_available)
      (G = Z0(J, 0, J.window[J.strstart - 1])), (J.match_available = 0)
    if (((J.insert = J.strstart < T - 1 ? J.strstart : T - 1), Q === a)) {
      if ((o(J, !0), J.strm.avail_out === 0)) return C0
      return h0
    }
    if (J.sym_next) {
      if ((o(J, !1), J.strm.avail_out === 0)) return l
    }
    return f0
  },
  MJ = (J, Q) => {
    let W, G, V, q
    const Y = J.window
    for (;;) {
      if (J.lookahead <= z0) {
        if ((y0(J), J.lookahead <= z0 && Q === H0)) return l
        if (J.lookahead === 0) break
      }
      if (((J.match_length = 0), J.lookahead >= T && J.strstart > 0)) {
        if (
          ((V = J.strstart - 1),
          (G = Y[V]),
          G === Y[++V] && G === Y[++V] && G === Y[++V])
        ) {
          q = J.strstart + z0
          do;
          while (
            G === Y[++V] &&
            G === Y[++V] &&
            G === Y[++V] &&
            G === Y[++V] &&
            G === Y[++V] &&
            G === Y[++V] &&
            G === Y[++V] &&
            G === Y[++V] &&
            V < q
          )
          if (((J.match_length = z0 - (q - V)), J.match_length > J.lookahead))
            J.match_length = J.lookahead
        }
      }
      if (J.match_length >= T)
        (W = Z0(J, 1, J.match_length - T)),
          (J.lookahead -= J.match_length),
          (J.strstart += J.match_length),
          (J.match_length = 0)
      else (W = Z0(J, 0, J.window[J.strstart])), J.lookahead--, J.strstart++
      if (W) {
        if ((o(J, !1), J.strm.avail_out === 0)) return l
      }
    }
    if (((J.insert = 0), Q === a)) {
      if ((o(J, !0), J.strm.avail_out === 0)) return C0
      return h0
    }
    if (J.sym_next) {
      if ((o(J, !1), J.strm.avail_out === 0)) return l
    }
    return f0
  },
  RJ = (J, Q) => {
    let W
    for (;;) {
      if (J.lookahead === 0) {
        if ((y0(J), J.lookahead === 0)) {
          if (Q === H0) return l
          break
        }
      }
      if (
        ((J.match_length = 0),
        (W = Z0(J, 0, J.window[J.strstart])),
        J.lookahead--,
        J.strstart++,
        W)
      ) {
        if ((o(J, !1), J.strm.avail_out === 0)) return l
      }
    }
    if (((J.insert = 0), Q === a)) {
      if ((o(J, !0), J.strm.avail_out === 0)) return C0
      return h0
    }
    if (J.sym_next) {
      if ((o(J, !1), J.strm.avail_out === 0)) return l
    }
    return f0
  },
  i0 = [
    new J0(0, 0, 0, 0, I6),
    new J0(4, 4, 8, 4, b1),
    new J0(4, 5, 16, 8, b1),
    new J0(4, 6, 32, 32, b1),
    new J0(4, 4, 16, 16, S0),
    new J0(8, 16, 32, 32, S0),
    new J0(8, 16, 128, 128, S0),
    new J0(8, 32, 128, 256, S0),
    new J0(32, 128, 258, 1024, S0),
    new J0(32, 258, 258, 4096, S0)
  ],
  LJ = (J) => {
    ;(J.window_size = 2 * J.w_size),
      F0(J.head),
      (J.max_lazy_match = i0[J.level].max_lazy),
      (J.good_match = i0[J.level].good_length),
      (J.nice_match = i0[J.level].nice_length),
      (J.max_chain_length = i0[J.level].max_chain),
      (J.strstart = 0),
      (J.block_start = 0),
      (J.lookahead = 0),
      (J.insert = 0),
      (J.match_length = J.prev_length = T - 1),
      (J.match_available = 0),
      (J.ins_h = 0)
  },
  V1 = (J) => {
    if (!J) return 1
    const Q = J.state
    if (
      !Q ||
      Q.strm !== J ||
      (Q.status !== v0 &&
        Q.status !== U8 &&
        Q.status !== s1 &&
        Q.status !== t1 &&
        Q.status !== J8 &&
        Q.status !== W8 &&
        Q.status !== M0 &&
        Q.status !== d0)
    )
      return 1
    return 0
  },
  x6 = (J) => {
    if (V1(J)) return R0(J, Q0)
    ;(J.total_in = J.total_out = 0), (J.data_type = qJ)
    const Q = J.state
    if (((Q.pending = 0), (Q.pending_out = 0), Q.wrap < 0)) Q.wrap = -Q.wrap
    return (
      (Q.status = Q.wrap === 2 ? U8 : Q.wrap ? v0 : M0),
      (J.adler = Q.wrap === 2 ? 0 : 1),
      (Q.last_flush = -2),
      r5(Q),
      d
    )
  },
  O6 = (J) => {
    const Q = x6(J)
    if (Q === d) LJ(J.state)
    return Q
  },
  IJ = (J, Q) => {
    if (V1(J) || J.state.wrap !== 2) return Q0
    return (J.state.gzhead = Q), d
  },
  D6 = (J, Q, W, G, V, q) => {
    if (!J) return Q0
    let Y = 1
    if (Q === JJ) Q = 6
    if (G < 0) (Y = 0), (G = -G)
    else if (G > 15) (Y = 2), (G -= 16)
    if (
      V < 1 ||
      V > XJ ||
      W !== x1 ||
      G < 8 ||
      G > 15 ||
      Q < 0 ||
      Q > 9 ||
      q < 0 ||
      q > GJ ||
      (G === 8 && Y !== 1)
    )
      return R0(J, Q0)
    if (G === 8) G = 9
    const X = new CJ()
    return (
      (J.state = X),
      (X.strm = J),
      (X.status = v0),
      (X.wrap = Y),
      (X.gzhead = null),
      (X.w_bits = G),
      (X.w_size = 1 << X.w_bits),
      (X.w_mask = X.w_size - 1),
      (X.hash_bits = V + 7),
      (X.hash_size = 1 << X.hash_bits),
      (X.hash_mask = X.hash_size - 1),
      (X.hash_shift = ~~((X.hash_bits + T - 1) / T)),
      (X.window = new Uint8Array(X.w_size * 2)),
      (X.head = new Uint16Array(X.hash_size)),
      (X.prev = new Uint16Array(X.w_size)),
      (X.lit_bufsize = 1 << (V + 6)),
      (X.pending_buf_size = X.lit_bufsize * 4),
      (X.pending_buf = new Uint8Array(X.pending_buf_size)),
      (X.sym_buf = X.lit_bufsize),
      (X.sym_end = (X.lit_bufsize - 1) * 3),
      (X.level = Q),
      (X.strategy = q),
      (X.method = W),
      O6(J)
    )
  },
  xJ = (J, Q) => {
    return D6(J, Q, x1, UJ, YJ, VJ)
  },
  OJ = (J, Q) => {
    if (V1(J) || Q > A8 || Q < 0) return J ? R0(J, Q0) : Q0
    const W = J.state
    if (
      !J.output ||
      (J.avail_in !== 0 && !J.input) ||
      (W.status === d0 && Q !== a)
    )
      return R0(J, J.avail_out === 0 ? p1 : Q0)
    const G = W.last_flush
    if (((W.last_flush = Q), W.pending !== 0)) {
      if ((r(J), J.avail_out === 0)) return (W.last_flush = -1), d
    } else if (J.avail_in === 0 && S8(Q) <= S8(G) && Q !== a) return R0(J, p1)
    if (W.status === d0 && J.avail_in !== 0) return R0(J, p1)
    if (W.status === v0 && W.wrap === 0) W.status = M0
    if (W.status === v0) {
      let V = (x1 + ((W.w_bits - 8) << 4)) << 8,
        q = -1
      if (W.strategy >= k1 || W.level < 2) q = 0
      else if (W.level < 6) q = 1
      else if (W.level === 6) q = 2
      else q = 3
      if (((V |= q << 6), W.strstart !== 0)) V |= kJ
      if (((V += 31 - (V % 31)), _0(W, V), W.strstart !== 0))
        _0(W, J.adler >>> 16), _0(W, J.adler & 65535)
      if (((J.adler = 1), (W.status = M0), r(J), W.pending !== 0))
        return (W.last_flush = -1), d
    }
    if (W.status === U8)
      if (((J.adler = 0), E(W, 31), E(W, 139), E(W, 8), !W.gzhead)) {
        if (
          (E(W, 0),
          E(W, 0),
          E(W, 0),
          E(W, 0),
          E(W, 0),
          E(W, W.level === 9 ? 2 : W.strategy >= k1 || W.level < 2 ? 4 : 0),
          E(W, $J),
          (W.status = M0),
          r(J),
          W.pending !== 0)
        )
          return (W.last_flush = -1), d
      } else {
        if (
          (E(
            W,
            (W.gzhead.text ? 1 : 0) +
              (W.gzhead.hcrc ? 2 : 0) +
              (!W.gzhead.extra ? 0 : 4) +
              (!W.gzhead.name ? 0 : 8) +
              (!W.gzhead.comment ? 0 : 16)
          ),
          E(W, W.gzhead.time & 255),
          E(W, (W.gzhead.time >> 8) & 255),
          E(W, (W.gzhead.time >> 16) & 255),
          E(W, (W.gzhead.time >> 24) & 255),
          E(W, W.level === 9 ? 2 : W.strategy >= k1 || W.level < 2 ? 4 : 0),
          E(W, W.gzhead.os & 255),
          W.gzhead.extra?.length)
        )
          E(W, W.gzhead.extra.length & 255),
            E(W, (W.gzhead.extra.length >> 8) & 255)
        if (W.gzhead.hcrc) J.adler = _(J.adler, W.pending_buf, W.pending, 0)
        ;(W.gzindex = 0), (W.status = s1)
      }
    if (W.status === s1) {
      if (W.gzhead.extra) {
        let V = W.pending,
          q = (W.gzhead.extra.length & 65535) - W.gzindex
        while (W.pending + q > W.pending_buf_size) {
          const X = W.pending_buf_size - W.pending
          if (
            (W.pending_buf.set(
              W.gzhead.extra.subarray(W.gzindex, W.gzindex + X),
              W.pending
            ),
            (W.pending = W.pending_buf_size),
            W.gzhead.hcrc && W.pending > V)
          )
            J.adler = _(J.adler, W.pending_buf, W.pending - V, V)
          if (((W.gzindex += X), r(J), W.pending !== 0))
            return (W.last_flush = -1), d
          ;(V = 0), (q -= X)
        }
        const Y = new Uint8Array(W.gzhead.extra)
        if (
          (W.pending_buf.set(Y.subarray(W.gzindex, W.gzindex + q), W.pending),
          (W.pending += q),
          W.gzhead.hcrc && W.pending > V)
        )
          J.adler = _(J.adler, W.pending_buf, W.pending - V, V)
        W.gzindex = 0
      }
      W.status = t1
    }
    if (W.status === t1) {
      if (W.gzhead.name) {
        let V = W.pending,
          q
        do {
          if (W.pending === W.pending_buf_size) {
            if (W.gzhead.hcrc && W.pending > V)
              J.adler = _(J.adler, W.pending_buf, W.pending - V, V)
            if ((r(J), W.pending !== 0)) return (W.last_flush = -1), d
            V = 0
          }
          if (W.gzindex < W.gzhead.name.length)
            q = W.gzhead.name.charCodeAt(W.gzindex++) & 255
          else q = 0
          E(W, q)
        } while (q !== 0)
        if (W.gzhead.hcrc && W.pending > V)
          J.adler = _(J.adler, W.pending_buf, W.pending - V, V)
        W.gzindex = 0
      }
      W.status = J8
    }
    if (W.status === J8) {
      if (W.gzhead.comment) {
        let V = W.pending,
          q
        do {
          if (W.pending === W.pending_buf_size) {
            if (W.gzhead.hcrc && W.pending > V)
              J.adler = _(J.adler, W.pending_buf, W.pending - V, V)
            if ((r(J), W.pending !== 0)) return (W.last_flush = -1), d
            V = 0
          }
          if (W.gzindex < W.gzhead.comment.length)
            q = W.gzhead.comment.charCodeAt(W.gzindex++) & 255
          else q = 0
          E(W, q)
        } while (q !== 0)
        if (W.gzhead.hcrc && W.pending > V)
          J.adler = _(J.adler, W.pending_buf, W.pending - V, V)
      }
      W.status = W8
    }
    if (W.status === W8) {
      if (W.gzhead.hcrc) {
        if (W.pending + 2 > W.pending_buf_size) {
          if ((r(J), W.pending !== 0)) return (W.last_flush = -1), d
        }
        E(W, J.adler & 255), E(W, (J.adler >> 8) & 255), (J.adler = 0)
      }
      if (((W.status = M0), r(J), W.pending !== 0))
        return (W.last_flush = -1), d
    }
    if (
      J.avail_in !== 0 ||
      W.lookahead !== 0 ||
      (Q !== H0 && W.status !== d0)
    ) {
      const V =
        W.level === 0
          ? I6(W, Q)
          : W.strategy === k1
            ? RJ(W, Q)
            : W.strategy === QJ
              ? MJ(W, Q)
              : i0[W.level].func(W, Q)
      if (V === C0 || V === h0) W.status = d0
      if (V === l || V === C0) {
        if (J.avail_out === 0) W.last_flush = -1
        return d
      }
      if (V === f0) {
        if (Q === e5) a5(W)
        else if (Q !== A8) {
          if ((a1(W, 0, 0, !1), Q === s5)) {
            if ((F0(W.head), W.lookahead === 0))
              (W.strstart = 0), (W.block_start = 0), (W.insert = 0)
          }
        }
        if ((r(J), J.avail_out === 0)) return (W.last_flush = -1), d
      }
    }
    if (Q !== a) return d
    if (W.wrap <= 0) return N8
    if (W.wrap === 2)
      E(W, J.adler & 255),
        E(W, (J.adler >> 8) & 255),
        E(W, (J.adler >> 16) & 255),
        E(W, (J.adler >> 24) & 255),
        E(W, J.total_in & 255),
        E(W, (J.total_in >> 8) & 255),
        E(W, (J.total_in >> 16) & 255),
        E(W, (J.total_in >> 24) & 255)
    else _0(W, J.adler >>> 16), _0(W, J.adler & 65535)
    if ((r(J), W.wrap > 0)) W.wrap = -W.wrap
    return W.pending !== 0 ? d : N8
  },
  DJ = (J) => {
    if (V1(J)) return Q0
    const Q = J.state.status
    return (J.state = null), Q === M0 ? R0(J, t5) : d
  },
  wJ = (J, Q) => {
    let W = Q.length
    if (V1(J)) return Q0
    const G = J.state,
      V = G.wrap
    if (V === 2 || (V === 1 && G.status !== v0) || G.lookahead) return Q0
    if (V === 1) J.adler = t0(J.adler, Q, W, 0)
    if (((G.wrap = 0), W >= G.w_size)) {
      if (V === 0)
        F0(G.head), (G.strstart = 0), (G.block_start = 0), (G.insert = 0)
      const z = new Uint8Array(G.w_size)
      z.set(Q.subarray(W - G.w_size, W), 0), (Q = z), (W = G.w_size)
    }
    const { avail_in: q, next_in: Y, input: X } = J
    ;(J.avail_in = W), (J.next_in = 0), (J.input = Q), y0(G)
    while (G.lookahead >= T) {
      let z = G.strstart,
        U = G.lookahead - (T - 1)
      do
        (G.ins_h = k0(G, G.ins_h, G.window[z + T - 1])),
          (G.prev[z & G.w_mask] = G.head[G.ins_h]),
          (G.head[G.ins_h] = z),
          z++
      while (--U)
      ;(G.strstart = z), (G.lookahead = T - 1), y0(G)
    }
    return (
      (G.strstart += G.lookahead),
      (G.block_start = G.strstart),
      (G.insert = G.lookahead),
      (G.lookahead = 0),
      (G.match_length = G.prev_length = T - 1),
      (G.match_available = 0),
      (J.next_in = Y),
      (J.input = X),
      (J.avail_in = q),
      (G.wrap = V),
      d
    )
  },
  AJ = xJ,
  NJ = D6,
  SJ = O6,
  gJ = x6,
  TJ = IJ,
  vJ = OJ,
  yJ = DJ,
  EJ = wJ,
  fJ = 'pako deflate (from Nodeca project)',
  n0 = {
    deflateInit: AJ,
    deflateInit2: NJ,
    deflateReset: SJ,
    deflateResetKeep: gJ,
    deflateSetHeader: TJ,
    deflate: vJ,
    deflateEnd: yJ,
    deflateSetDictionary: EJ,
    deflateInfo: fJ
  },
  hJ = (J, Q) => {
    return Object.hasOwn(J, Q)
  },
  pJ = (J) => {
    const Q = Array.prototype.slice.call(arguments, 1)
    while (Q.length) {
      const W = Q.shift()
      if (!W) continue
      if (typeof W !== 'object') throw new TypeError(`${W}must be non-object`)
      for (const G in W) if (hJ(W, G)) J[G] = W[G]
    }
    return J
  },
  bJ = (J) => {
    let Q = 0
    for (let G = 0, V = J.length; G < V; G++) Q += J[G].length
    const W = new Uint8Array(Q)
    for (let G = 0, V = 0, q = J.length; G < q; G++) {
      const Y = J[G]
      W.set(Y, V), (V += Y.length)
    }
    return W
  },
  O1 = { assign: pJ, flattenChunks: bJ },
  w6 = !0
try {
  String.fromCharCode.apply(null, new Uint8Array(1))
} catch (_J) {
  w6 = !1
}
var J1 = new Uint8Array(256)
for (let J = 0; J < 256; J++)
  J1[J] =
    J >= 252 ? 6 : J >= 248 ? 5 : J >= 240 ? 4 : J >= 224 ? 3 : J >= 192 ? 2 : 1
J1[254] = J1[254] = 1
var uJ = (J) => {
    if (typeof TextEncoder === 'function' && TextEncoder.prototype.encode)
      return new TextEncoder().encode(J)
    let Q,
      W,
      G,
      V,
      q,
      Y = J.length,
      X = 0
    for (V = 0; V < Y; V++) {
      if (((W = J.charCodeAt(V)), (W & 64512) === 55296 && V + 1 < Y)) {
        if (((G = J.charCodeAt(V + 1)), (G & 64512) === 56320))
          (W = 65536 + ((W - 55296) << 10) + (G - 56320)), V++
      }
      X += W < 128 ? 1 : W < 2048 ? 2 : W < 65536 ? 3 : 4
    }
    Q = new Uint8Array(X)
    for (q = 0, V = 0; q < X; V++) {
      if (((W = J.charCodeAt(V)), (W & 64512) === 55296 && V + 1 < Y)) {
        if (((G = J.charCodeAt(V + 1)), (G & 64512) === 56320))
          (W = 65536 + ((W - 55296) << 10) + (G - 56320)), V++
      }
      if (W < 128) Q[q++] = W
      else if (W < 2048) (Q[q++] = 192 | (W >>> 6)), (Q[q++] = 128 | (W & 63))
      else if (W < 65536)
        (Q[q++] = 224 | (W >>> 12)),
          (Q[q++] = 128 | ((W >>> 6) & 63)),
          (Q[q++] = 128 | (W & 63))
      else
        (Q[q++] = 240 | (W >>> 18)),
          (Q[q++] = 128 | ((W >>> 12) & 63)),
          (Q[q++] = 128 | ((W >>> 6) & 63)),
          (Q[q++] = 128 | (W & 63))
    }
    return Q
  },
  mJ = (J, Q) => {
    if (Q < 65534) {
      if (J.subarray && w6)
        return String.fromCharCode.apply(
          null,
          J.length === Q ? J : J.subarray(0, Q)
        )
    }
    let W = ''
    for (let G = 0; G < Q; G++) W += String.fromCharCode(J[G])
    return W
  },
  cJ = (J, Q) => {
    const W = Q || J.length
    if (typeof TextDecoder === 'function' && TextDecoder.prototype.decode)
      return new TextDecoder().decode(J.subarray(0, Q))
    let G, V
    const q = new Array(W * 2)
    for (V = 0, G = 0; G < W; ) {
      let Y = J[G++]
      if (Y < 128) {
        q[V++] = Y
        continue
      }
      let X = J1[Y]
      if (X > 4) {
        ;(q[V++] = 65533), (G += X - 1)
        continue
      }
      Y &= X === 2 ? 31 : X === 3 ? 15 : 7
      while (X > 1 && G < W) (Y = (Y << 6) | (J[G++] & 63)), X--
      if (X > 1) {
        q[V++] = 65533
        continue
      }
      if (Y < 65536) q[V++] = Y
      else
        (Y -= 65536),
          (q[V++] = 55296 | ((Y >> 10) & 1023)),
          (q[V++] = 56320 | (Y & 1023))
    }
    return mJ(q, V)
  },
  _J = (J, Q) => {
    if (((Q = Q || J.length), Q > J.length)) Q = J.length
    let W = Q - 1
    while (W >= 0 && (J[W] & 192) === 128) W--
    if (W < 0) return Q
    if (W === 0) return Q
    return W + J1[J[W]] > Q ? W : Q
  },
  W1 = { string2buf: uJ, buf2string: cJ, utf8border: _J },
  A6 = dJ,
  N6 = Object.prototype.toString,
  {
    Z_NO_FLUSH: iJ,
    Z_SYNC_FLUSH: lJ,
    Z_FULL_FLUSH: nJ,
    Z_FINISH: rJ,
    Z_OK: C1,
    Z_STREAM_END: oJ,
    Z_DEFAULT_COMPRESSION: aJ,
    Z_DEFAULT_STRATEGY: eJ,
    Z_DEFLATED: sJ
  } = x0
q1.prototype.push = function (J, Q) {
  const W = this.strm,
    G = this.options.chunkSize
  let V, q
  if (this.ended) return !1
  if (Q === ~~Q) q = Q
  else q = Q === !0 ? rJ : iJ
  if (typeof J === 'string') W.input = W1.string2buf(J)
  else if (N6.call(J) === '[object ArrayBuffer]') W.input = new Uint8Array(J)
  else W.input = J
  ;(W.next_in = 0), (W.avail_in = W.input.length)
  for (;;) {
    if (W.avail_out === 0)
      (W.output = new Uint8Array(G)), (W.next_out = 0), (W.avail_out = G)
    if ((q === lJ || q === nJ) && W.avail_out <= 6) {
      this.onData(W.output.subarray(0, W.next_out)), (W.avail_out = 0)
      continue
    }
    if (((V = n0.deflate(W, q)), V === oJ)) {
      if (W.next_out > 0) this.onData(W.output.subarray(0, W.next_out))
      return (
        (V = n0.deflateEnd(this.strm)),
        this.onEnd(V),
        (this.ended = !0),
        V === C1
      )
    }
    if (W.avail_out === 0) {
      this.onData(W.output)
      continue
    }
    if (q > 0 && W.next_out > 0) {
      this.onData(W.output.subarray(0, W.next_out)), (W.avail_out = 0)
      continue
    }
    if (W.avail_in === 0) break
  }
  return !0
}
q1.prototype.onData = function (J) {
  this.chunks.push(J)
}
q1.prototype.onEnd = function (J) {
  if (J === C1) this.result = O1.flattenChunks(this.chunks)
  ;(this.chunks = []), (this.err = J), (this.msg = this.strm.msg)
}
var WW = q1,
  QW = Y8,
  GW = tJ,
  VW = JW,
  qW = x0,
  XW = { Deflate: WW, deflate: QW, deflateRaw: GW, gzip: VW, constants: qW },
  $1 = 16209,
  UW = 16191,
  YW = function J(Q, W) {
    let G, V, q, Y, X, z, U, P, $, F, K, Z, I, M, j, L, C, k, g, p, R, v, A, D
    const N = Q.state
    ;(G = Q.next_in),
      (A = Q.input),
      (V = G + (Q.avail_in - 5)),
      (q = Q.next_out),
      (D = Q.output),
      (Y = q - (W - Q.avail_out)),
      (X = q + (Q.avail_out - 257)),
      (z = N.dmax),
      (U = N.wsize),
      (P = N.whave),
      ($ = N.wnext),
      (F = N.window),
      (K = N.hold),
      (Z = N.bits),
      (I = N.lencode),
      (M = N.distcode),
      (j = (1 << N.lenbits) - 1),
      (L = (1 << N.distbits) - 1)
    J: do {
      if (Z < 15) (K += A[G++] << Z), (Z += 8), (K += A[G++] << Z), (Z += 8)
      C = I[K & j]
      for (;;) {
        if (
          ((k = C >>> 24),
          (K >>>= k),
          (Z -= k),
          (k = (C >>> 16) & 255),
          k === 0)
        )
          D[q++] = C & 65535
        else if (k & 16) {
          if (((g = C & 65535), (k &= 15), k)) {
            if (Z < k) (K += A[G++] << Z), (Z += 8)
            ;(g += K & ((1 << k) - 1)), (K >>>= k), (Z -= k)
          }
          if (Z < 15) (K += A[G++] << Z), (Z += 8), (K += A[G++] << Z), (Z += 8)
          C = M[K & L]
          for (;;) {
            if (
              ((k = C >>> 24),
              (K >>>= k),
              (Z -= k),
              (k = (C >>> 16) & 255),
              k & 16)
            ) {
              if (((p = C & 65535), (k &= 15), Z < k)) {
                if (((K += A[G++] << Z), (Z += 8), Z < k))
                  (K += A[G++] << Z), (Z += 8)
              }
              if (((p += K & ((1 << k) - 1)), p > z)) {
                ;(Q.msg = 'invalid distance too far back'), (N.mode = $1)
                break J
              }
              if (((K >>>= k), (Z -= k), (k = q - Y), p > k)) {
                if (((k = p - k), k > P)) {
                  if (N.sane) {
                    ;(Q.msg = 'invalid distance too far back'), (N.mode = $1)
                    break J
                  }
                }
                if (((R = 0), (v = F), $ === 0)) {
                  if (((R += U - k), k < g)) {
                    g -= k
                    do D[q++] = F[R++]
                    while (--k)
                    ;(R = q - p), (v = D)
                  }
                } else if ($ < k) {
                  if (((R += U + $ - k), (k -= $), k < g)) {
                    g -= k
                    do D[q++] = F[R++]
                    while (--k)
                    if (((R = 0), $ < g)) {
                      ;(k = $), (g -= k)
                      do D[q++] = F[R++]
                      while (--k)
                      ;(R = q - p), (v = D)
                    }
                  }
                } else if (((R += $ - k), k < g)) {
                  g -= k
                  do D[q++] = F[R++]
                  while (--k)
                  ;(R = q - p), (v = D)
                }
                while (g > 2)
                  (D[q++] = v[R++]),
                    (D[q++] = v[R++]),
                    (D[q++] = v[R++]),
                    (g -= 3)
                if (g) {
                  if (((D[q++] = v[R++]), g > 1)) D[q++] = v[R++]
                }
              } else {
                R = q - p
                do
                  (D[q++] = D[R++]),
                    (D[q++] = D[R++]),
                    (D[q++] = D[R++]),
                    (g -= 3)
                while (g > 2)
                if (g) {
                  if (((D[q++] = D[R++]), g > 1)) D[q++] = D[R++]
                }
              }
            } else if ((k & 64) === 0) {
              C = M[(C & 65535) + (K & ((1 << k) - 1))]
              continue
            } else {
              ;(Q.msg = 'invalid distance code'), (N.mode = $1)
              break J
            }
            break
          }
        } else if ((k & 64) === 0) {
          C = I[(C & 65535) + (K & ((1 << k) - 1))]
          continue
        } else if (k & 32) {
          N.mode = UW
          break J
        } else {
          ;(Q.msg = 'invalid literal/length code'), (N.mode = $1)
          break J
        }
        break
      }
    } while (G < V && q < X)
    ;(g = Z >> 3),
      (G -= g),
      (Z -= g << 3),
      (K &= (1 << Z) - 1),
      (Q.next_in = G),
      (Q.next_out = q),
      (Q.avail_in = G < V ? 5 + (V - G) : 5 - (G - V)),
      (Q.avail_out = q < X ? 257 + (X - q) : 257 - (q - X)),
      (N.hold = K),
      (N.bits = Z)
    return
  },
  g0 = 15,
  g8 = 852,
  T8 = 592,
  v8 = 0,
  u1 = 1,
  y8 = 2,
  PW = new Uint16Array([
    3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67,
    83, 99, 115, 131, 163, 195, 227, 258, 0, 0
  ]),
  KW = new Uint8Array([
    16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19,
    19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
  ]),
  FW = new Uint16Array([
    1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513,
    769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0
  ]),
  zW = new Uint8Array([
    16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24,
    24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64
  ]),
  ZW = (J, Q, W, G, V, q, Y, X) => {
    const z = X.bits
    let U = 0,
      P = 0,
      $ = 0,
      F = 0,
      K = 0,
      Z = 0,
      I = 0,
      M = 0,
      j = 0,
      L = 0,
      C,
      k,
      g,
      p,
      R,
      v = null,
      A
    const D = new Uint16Array(g0 + 1),
      N = new Uint16Array(g0 + 1)
    let V0 = null,
      p0,
      t,
      Y0
    for (U = 0; U <= g0; U++) D[U] = 0
    for (P = 0; P < G; P++) D[Q[W + P]]++
    K = z
    for (F = g0; F >= 1; F--) if (D[F] !== 0) break
    if (K > F) K = F
    if (F === 0)
      return (
        (V[q++] = (1 << 24) | (64 << 16) | 0),
        (V[q++] = (1 << 24) | (64 << 16) | 0),
        (X.bits = 1),
        0
      )
    for ($ = 1; $ < F; $++) if (D[$] !== 0) break
    if (K < $) K = $
    M = 1
    for (U = 1; U <= g0; U++) if (((M <<= 1), (M -= D[U]), M < 0)) return -1
    if (M > 0 && (J === v8 || F !== 1)) return -1
    N[1] = 0
    for (U = 1; U < g0; U++) N[U + 1] = N[U] + D[U]
    for (P = 0; P < G; P++) if (Q[W + P] !== 0) Y[N[Q[W + P]]++] = P
    if (J === v8) (v = V0 = Y), (A = 20)
    else if (J === u1) (v = PW), (V0 = KW), (A = 257)
    else (v = FW), (V0 = zW), (A = 0)
    if (
      ((L = 0),
      (P = 0),
      (U = $),
      (R = q),
      (Z = K),
      (I = 0),
      (g = -1),
      (j = 1 << K),
      (p = j - 1),
      (J === u1 && j > g8) || (J === y8 && j > T8))
    )
      return 1
    for (;;) {
      if (((p0 = U - I), Y[P] + 1 < A)) (t = 0), (Y0 = Y[P])
      else if (Y[P] >= A) (t = V0[Y[P] - A]), (Y0 = v[Y[P] - A])
      else (t = 96), (Y0 = 0)
      ;(C = 1 << (U - I)), (k = 1 << Z), ($ = k)
      do (k -= C), (V[R + (L >> I) + k] = (p0 << 24) | (t << 16) | Y0 | 0)
      while (k !== 0)
      C = 1 << (U - 1)
      while (L & C) C >>= 1
      if (C !== 0) (L &= C - 1), (L += C)
      else L = 0
      if ((P++, --D[U] === 0)) {
        if (U === F) break
        U = Q[W + Y[P]]
      }
      if (U > K && (L & p) !== g) {
        if (I === 0) I = K
        ;(R += $), (Z = U - I), (M = 1 << Z)
        while (Z + I < F) {
          if (((M -= D[Z + I]), M <= 0)) break
          Z++, (M <<= 1)
        }
        if (((j += 1 << Z), (J === u1 && j > g8) || (J === y8 && j > T8)))
          return 1
        ;(g = L & p), (V[g] = (K << 24) | (Z << 16) | (R - q) | 0)
      }
    }
    if (L !== 0) V[R + L] = ((U - I) << 24) | (64 << 16) | 0
    return (X.bits = K), 0
  },
  r0 = ZW,
  HW = 0,
  S6 = 1,
  g6 = 2,
  {
    Z_FINISH: E8,
    Z_BLOCK: kW,
    Z_TREES: B1,
    Z_OK: I0,
    Z_STREAM_END: $W,
    Z_NEED_DICT: BW,
    Z_STREAM_ERROR: e,
    Z_DATA_ERROR: T6,
    Z_MEM_ERROR: v6,
    Z_BUF_ERROR: jW,
    Z_DEFLATED: f8
  } = x0,
  D1 = 16180,
  h8 = 16181,
  p8 = 16182,
  b8 = 16183,
  u8 = 16184,
  m8 = 16185,
  c8 = 16186,
  _8 = 16187,
  d8 = 16188,
  i8 = 16189,
  I1 = 16190,
  q0 = 16191,
  m1 = 16192,
  l8 = 16193,
  c1 = 16194,
  n8 = 16195,
  r8 = 16196,
  o8 = 16197,
  a8 = 16198,
  j1 = 16199,
  M1 = 16200,
  e8 = 16201,
  s8 = 16202,
  t8 = 16203,
  J6 = 16204,
  W6 = 16205,
  _1 = 16206,
  Q6 = 16207,
  G6 = 16208,
  h = 16209,
  y6 = 16210,
  E6 = 16211,
  MW = 852,
  RW = 592,
  LW = 15,
  CW = LW,
  V6 = (J) => {
    return (
      ((J >>> 24) & 255) +
      ((J >>> 8) & 65280) +
      ((J & 65280) << 8) +
      ((J & 255) << 24)
    )
  },
  O0 = (J) => {
    if (!J) return 1
    const Q = J.state
    if (!Q || Q.strm !== J || Q.mode < D1 || Q.mode > E6) return 1
    return 0
  },
  f6 = (J) => {
    if (O0(J)) return e
    const Q = J.state
    if (((J.total_in = J.total_out = Q.total = 0), (J.msg = ''), Q.wrap))
      J.adler = Q.wrap & 1
    return (
      (Q.mode = D1),
      (Q.last = 0),
      (Q.havedict = 0),
      (Q.flags = -1),
      (Q.dmax = 32768),
      (Q.head = null),
      (Q.hold = 0),
      (Q.bits = 0),
      (Q.lencode = Q.lendyn = new Int32Array(MW)),
      (Q.distcode = Q.distdyn = new Int32Array(RW)),
      (Q.sane = 1),
      (Q.back = -1),
      I0
    )
  },
  h6 = (J) => {
    if (O0(J)) return e
    const Q = J.state
    return (Q.wsize = 0), (Q.whave = 0), (Q.wnext = 0), f6(J)
  },
  p6 = (J, Q) => {
    let W
    if (O0(J)) return e
    const G = J.state
    if (Q < 0) (W = 0), (Q = -Q)
    else if (((W = (Q >> 4) + 5), Q < 48)) Q &= 15
    if (Q && (Q < 8 || Q > 15)) return e
    if (G.window !== null && G.wbits !== Q) G.window = null
    return (G.wrap = W), (G.wbits = Q), h6(J)
  },
  b6 = (J, Q) => {
    if (!J) return e
    const W = new IW()
    ;(J.state = W), (W.strm = J), (W.window = null), (W.mode = D1)
    const G = p6(J, Q)
    if (G !== I0) J.state = null
    return G
  },
  xW = (J) => {
    return b6(J, CW)
  },
  q6 = !0,
  d1,
  i1,
  OW = (J) => {
    if (q6) {
      ;(d1 = new Int32Array(512)), (i1 = new Int32Array(32))
      let Q = 0
      while (Q < 144) J.lens[Q++] = 8
      while (Q < 256) J.lens[Q++] = 9
      while (Q < 280) J.lens[Q++] = 7
      while (Q < 288) J.lens[Q++] = 8
      r0(S6, J.lens, 0, 288, d1, 0, J.work, { bits: 9 }), (Q = 0)
      while (Q < 32) J.lens[Q++] = 5
      r0(g6, J.lens, 0, 32, i1, 0, J.work, { bits: 5 }), (q6 = !1)
    }
    ;(J.lencode = d1), (J.lenbits = 9), (J.distcode = i1), (J.distbits = 5)
  },
  u6 = (J, Q, W, G) => {
    let V
    const q = J.state
    if (q.window === null)
      (q.wsize = 1 << q.wbits),
        (q.wnext = 0),
        (q.whave = 0),
        (q.window = new Uint8Array(q.wsize))
    if (G >= q.wsize)
      q.window.set(Q.subarray(W - q.wsize, W), 0),
        (q.wnext = 0),
        (q.whave = q.wsize)
    else {
      if (((V = q.wsize - q.wnext), V > G)) V = G
      if ((q.window.set(Q.subarray(W - G, W - G + V), q.wnext), (G -= V), G))
        q.window.set(Q.subarray(W - G, W), 0),
          (q.wnext = G),
          (q.whave = q.wsize)
      else {
        if (((q.wnext += V), q.wnext === q.wsize)) q.wnext = 0
        if (q.whave < q.wsize) q.whave += V
      }
    }
    return 0
  },
  DW = (J, Q) => {
    let W,
      G,
      V,
      q,
      Y,
      X,
      z,
      U,
      P,
      $,
      F,
      K,
      Z,
      I,
      M = 0,
      j,
      L,
      C,
      k,
      g,
      p,
      R,
      v
    const A = new Uint8Array(4)
    let D, N
    const V0 = new Uint8Array([
      16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15
    ])
    if (O0(J) || !J.output || (!J.input && J.avail_in !== 0)) return e
    if (((W = J.state), W.mode === q0)) W.mode = m1
    ;(Y = J.next_out),
      (V = J.output),
      (z = J.avail_out),
      (q = J.next_in),
      (G = J.input),
      (X = J.avail_in),
      (U = W.hold),
      (P = W.bits),
      ($ = X),
      (F = z),
      (v = I0)
    J: for (;;)
      switch (W.mode) {
        case D1:
          if (W.wrap === 0) {
            W.mode = m1
            break
          }
          while (P < 16) {
            if (X === 0) break J
            X--, (U += G[q++] << P), (P += 8)
          }
          if (W.wrap & 2 && U === 35615) {
            if (W.wbits === 0) W.wbits = 15
            ;(W.check = 0),
              (A[0] = U & 255),
              (A[1] = (U >>> 8) & 255),
              (W.check = _(W.check, A, 2, 0)),
              (U = 0),
              (P = 0),
              (W.mode = h8)
            break
          }
          if (W.head) W.head.done = !1
          if (!(W.wrap & 1) || (((U & 255) << 8) + (U >> 8)) % 31) {
            ;(J.msg = 'incorrect header check'), (W.mode = h)
            break
          }
          if ((U & 15) !== f8) {
            ;(J.msg = 'unknown compression method'), (W.mode = h)
            break
          }
          if (((U >>>= 4), (P -= 4), (R = (U & 15) + 8), W.wbits === 0))
            W.wbits = R
          if (R > 15 || R > W.wbits) {
            ;(J.msg = 'invalid window size'), (W.mode = h)
            break
          }
          ;(W.dmax = 1 << W.wbits),
            (W.flags = 0),
            (J.adler = W.check = 1),
            (W.mode = U & 512 ? i8 : q0),
            (U = 0),
            (P = 0)
          break
        case h8:
          while (P < 16) {
            if (X === 0) break J
            X--, (U += G[q++] << P), (P += 8)
          }
          if (((W.flags = U), (W.flags & 255) !== f8)) {
            ;(J.msg = 'unknown compression method'), (W.mode = h)
            break
          }
          if (W.flags & 57344) {
            ;(J.msg = 'unknown header flags set'), (W.mode = h)
            break
          }
          if (W.head) W.head.text = (U >> 8) & 1
          if (W.flags & 512 && W.wrap & 4)
            (A[0] = U & 255),
              (A[1] = (U >>> 8) & 255),
              (W.check = _(W.check, A, 2, 0))
          ;(U = 0), (P = 0), (W.mode = p8)
        case p8:
          while (P < 32) {
            if (X === 0) break J
            X--, (U += G[q++] << P), (P += 8)
          }
          if (W.head) W.head.time = U
          if (W.flags & 512 && W.wrap & 4)
            (A[0] = U & 255),
              (A[1] = (U >>> 8) & 255),
              (A[2] = (U >>> 16) & 255),
              (A[3] = (U >>> 24) & 255),
              (W.check = _(W.check, A, 4, 0))
          ;(U = 0), (P = 0), (W.mode = b8)
        case b8:
          while (P < 16) {
            if (X === 0) break J
            X--, (U += G[q++] << P), (P += 8)
          }
          if (W.head) (W.head.xflags = U & 255), (W.head.os = U >> 8)
          if (W.flags & 512 && W.wrap & 4)
            (A[0] = U & 255),
              (A[1] = (U >>> 8) & 255),
              (W.check = _(W.check, A, 2, 0))
          ;(U = 0), (P = 0), (W.mode = u8)
        case u8:
          if (W.flags & 1024) {
            while (P < 16) {
              if (X === 0) break J
              X--, (U += G[q++] << P), (P += 8)
            }
            if (((W.length = U), W.head)) W.head.extra_len = U
            if (W.flags & 512 && W.wrap & 4)
              (A[0] = U & 255),
                (A[1] = (U >>> 8) & 255),
                (W.check = _(W.check, A, 2, 0))
            ;(U = 0), (P = 0)
          } else if (W.head) W.head.extra = null
          W.mode = m8
        case m8:
          if (W.flags & 1024) {
            if (((K = W.length), K > X)) K = X
            if (K) {
              if (W.head) {
                if (((R = W.head.extra_len - W.length), !W.head.extra))
                  W.head.extra = new Uint8Array(W.head.extra_len)
                W.head.extra.set(G.subarray(q, q + K), R)
              }
              if (W.flags & 512 && W.wrap & 4) W.check = _(W.check, G, K, q)
              ;(X -= K), (q += K), (W.length -= K)
            }
            if (W.length) break J
          }
          ;(W.length = 0), (W.mode = c8)
        case c8:
          if (W.flags & 2048) {
            if (X === 0) break J
            K = 0
            do
              if (((R = G[q + K++]), W.head && R && W.length < 65536))
                W.head.name += String.fromCharCode(R)
            while (R && K < X)
            if (W.flags & 512 && W.wrap & 4) W.check = _(W.check, G, K, q)
            if (((X -= K), (q += K), R)) break J
          } else if (W.head) W.head.name = null
          ;(W.length = 0), (W.mode = _8)
        case _8:
          if (W.flags & 4096) {
            if (X === 0) break J
            K = 0
            do
              if (((R = G[q + K++]), W.head && R && W.length < 65536))
                W.head.comment += String.fromCharCode(R)
            while (R && K < X)
            if (W.flags & 512 && W.wrap & 4) W.check = _(W.check, G, K, q)
            if (((X -= K), (q += K), R)) break J
          } else if (W.head) W.head.comment = null
          W.mode = d8
        case d8:
          if (W.flags & 512) {
            while (P < 16) {
              if (X === 0) break J
              X--, (U += G[q++] << P), (P += 8)
            }
            if (W.wrap & 4 && U !== (W.check & 65535)) {
              ;(J.msg = 'header crc mismatch'), (W.mode = h)
              break
            }
            ;(U = 0), (P = 0)
          }
          if (W.head) (W.head.hcrc = (W.flags >> 9) & 1), (W.head.done = !0)
          ;(J.adler = W.check = 0), (W.mode = q0)
          break
        case i8:
          while (P < 32) {
            if (X === 0) break J
            X--, (U += G[q++] << P), (P += 8)
          }
          ;(J.adler = W.check = V6(U)), (U = 0), (P = 0), (W.mode = I1)
        case I1:
          if (W.havedict === 0)
            return (
              (J.next_out = Y),
              (J.avail_out = z),
              (J.next_in = q),
              (J.avail_in = X),
              (W.hold = U),
              (W.bits = P),
              BW
            )
          ;(J.adler = W.check = 1), (W.mode = q0)
        case q0:
          if (Q === kW || Q === B1) break J
        case m1:
          if (W.last) {
            ;(U >>>= P & 7), (P -= P & 7), (W.mode = _1)
            break
          }
          while (P < 3) {
            if (X === 0) break J
            X--, (U += G[q++] << P), (P += 8)
          }
          switch (((W.last = U & 1), (U >>>= 1), (P -= 1), U & 3)) {
            case 0:
              W.mode = l8
              break
            case 1:
              if ((OW(W), (W.mode = j1), Q === B1)) {
                ;(U >>>= 2), (P -= 2)
                break J
              }
              break
            case 2:
              W.mode = r8
              break
            case 3:
              ;(J.msg = 'invalid block type'), (W.mode = h)
          }
          ;(U >>>= 2), (P -= 2)
          break
        case l8:
          ;(U >>>= P & 7), (P -= P & 7)
          while (P < 32) {
            if (X === 0) break J
            X--, (U += G[q++] << P), (P += 8)
          }
          if ((U & 65535) !== ((U >>> 16) ^ 65535)) {
            ;(J.msg = 'invalid stored block lengths'), (W.mode = h)
            break
          }
          if (
            ((W.length = U & 65535), (U = 0), (P = 0), (W.mode = c1), Q === B1)
          )
            break J
        case c1:
          W.mode = n8
        case n8:
          if (((K = W.length), K)) {
            if (K > X) K = X
            if (K > z) K = z
            if (K === 0) break J
            V.set(G.subarray(q, q + K), Y),
              (X -= K),
              (q += K),
              (z -= K),
              (Y += K),
              (W.length -= K)
            break
          }
          W.mode = q0
          break
        case r8:
          while (P < 14) {
            if (X === 0) break J
            X--, (U += G[q++] << P), (P += 8)
          }
          if (
            ((W.nlen = (U & 31) + 257),
            (U >>>= 5),
            (P -= 5),
            (W.ndist = (U & 31) + 1),
            (U >>>= 5),
            (P -= 5),
            (W.ncode = (U & 15) + 4),
            (U >>>= 4),
            (P -= 4),
            W.nlen > 286 || W.ndist > 30)
          ) {
            ;(J.msg = 'too many length or distance symbols'), (W.mode = h)
            break
          }
          ;(W.have = 0), (W.mode = o8)
        case o8:
          while (W.have < W.ncode) {
            while (P < 3) {
              if (X === 0) break J
              X--, (U += G[q++] << P), (P += 8)
            }
            ;(W.lens[V0[W.have++]] = U & 7), (U >>>= 3), (P -= 3)
          }
          while (W.have < 19) W.lens[V0[W.have++]] = 0
          if (
            ((W.lencode = W.lendyn),
            (W.lenbits = 7),
            (D = { bits: W.lenbits }),
            (v = r0(HW, W.lens, 0, 19, W.lencode, 0, W.work, D)),
            (W.lenbits = D.bits),
            v)
          ) {
            ;(J.msg = 'invalid code lengths set'), (W.mode = h)
            break
          }
          ;(W.have = 0), (W.mode = a8)
        case a8:
          while (W.have < W.nlen + W.ndist) {
            for (;;) {
              if (
                ((M = W.lencode[U & ((1 << W.lenbits) - 1)]),
                (j = M >>> 24),
                (L = (M >>> 16) & 255),
                (C = M & 65535),
                j <= P)
              )
                break
              if (X === 0) break J
              X--, (U += G[q++] << P), (P += 8)
            }
            if (C < 16) (U >>>= j), (P -= j), (W.lens[W.have++] = C)
            else {
              if (C === 16) {
                N = j + 2
                while (P < N) {
                  if (X === 0) break J
                  X--, (U += G[q++] << P), (P += 8)
                }
                if (((U >>>= j), (P -= j), W.have === 0)) {
                  ;(J.msg = 'invalid bit length repeat'), (W.mode = h)
                  break
                }
                ;(R = W.lens[W.have - 1]),
                  (K = 3 + (U & 3)),
                  (U >>>= 2),
                  (P -= 2)
              } else if (C === 17) {
                N = j + 3
                while (P < N) {
                  if (X === 0) break J
                  X--, (U += G[q++] << P), (P += 8)
                }
                ;(U >>>= j),
                  (P -= j),
                  (R = 0),
                  (K = 3 + (U & 7)),
                  (U >>>= 3),
                  (P -= 3)
              } else {
                N = j + 7
                while (P < N) {
                  if (X === 0) break J
                  X--, (U += G[q++] << P), (P += 8)
                }
                ;(U >>>= j),
                  (P -= j),
                  (R = 0),
                  (K = 11 + (U & 127)),
                  (U >>>= 7),
                  (P -= 7)
              }
              if (W.have + K > W.nlen + W.ndist) {
                ;(J.msg = 'invalid bit length repeat'), (W.mode = h)
                break
              }
              while (K--) W.lens[W.have++] = R
            }
          }
          if (W.mode === h) break
          if (W.lens[256] === 0) {
            ;(J.msg = 'invalid code -- missing end-of-block'), (W.mode = h)
            break
          }
          if (
            ((W.lenbits = 9),
            (D = { bits: W.lenbits }),
            (v = r0(S6, W.lens, 0, W.nlen, W.lencode, 0, W.work, D)),
            (W.lenbits = D.bits),
            v)
          ) {
            ;(J.msg = 'invalid literal/lengths set'), (W.mode = h)
            break
          }
          if (
            ((W.distbits = 6),
            (W.distcode = W.distdyn),
            (D = { bits: W.distbits }),
            (v = r0(g6, W.lens, W.nlen, W.ndist, W.distcode, 0, W.work, D)),
            (W.distbits = D.bits),
            v)
          ) {
            ;(J.msg = 'invalid distances set'), (W.mode = h)
            break
          }
          if (((W.mode = j1), Q === B1)) break J
        case j1:
          W.mode = M1
        case M1:
          if (X >= 6 && z >= 258) {
            if (
              ((J.next_out = Y),
              (J.avail_out = z),
              (J.next_in = q),
              (J.avail_in = X),
              (W.hold = U),
              (W.bits = P),
              YW(J, F),
              (Y = J.next_out),
              (V = J.output),
              (z = J.avail_out),
              (q = J.next_in),
              (G = J.input),
              (X = J.avail_in),
              (U = W.hold),
              (P = W.bits),
              W.mode === q0)
            )
              W.back = -1
            break
          }
          W.back = 0
          for (;;) {
            if (
              ((M = W.lencode[U & ((1 << W.lenbits) - 1)]),
              (j = M >>> 24),
              (L = (M >>> 16) & 255),
              (C = M & 65535),
              j <= P)
            )
              break
            if (X === 0) break J
            X--, (U += G[q++] << P), (P += 8)
          }
          if (L && (L & 240) === 0) {
            ;(k = j), (g = L), (p = C)
            for (;;) {
              if (
                ((M = W.lencode[p + ((U & ((1 << (k + g)) - 1)) >> k)]),
                (j = M >>> 24),
                (L = (M >>> 16) & 255),
                (C = M & 65535),
                k + j <= P)
              )
                break
              if (X === 0) break J
              X--, (U += G[q++] << P), (P += 8)
            }
            ;(U >>>= k), (P -= k), (W.back += k)
          }
          if (((U >>>= j), (P -= j), (W.back += j), (W.length = C), L === 0)) {
            W.mode = W6
            break
          }
          if (L & 32) {
            ;(W.back = -1), (W.mode = q0)
            break
          }
          if (L & 64) {
            ;(J.msg = 'invalid literal/length code'), (W.mode = h)
            break
          }
          ;(W.extra = L & 15), (W.mode = e8)
        case e8:
          if (W.extra) {
            N = W.extra
            while (P < N) {
              if (X === 0) break J
              X--, (U += G[q++] << P), (P += 8)
            }
            ;(W.length += U & ((1 << W.extra) - 1)),
              (U >>>= W.extra),
              (P -= W.extra),
              (W.back += W.extra)
          }
          ;(W.was = W.length), (W.mode = s8)
        case s8:
          for (;;) {
            if (
              ((M = W.distcode[U & ((1 << W.distbits) - 1)]),
              (j = M >>> 24),
              (L = (M >>> 16) & 255),
              (C = M & 65535),
              j <= P)
            )
              break
            if (X === 0) break J
            X--, (U += G[q++] << P), (P += 8)
          }
          if ((L & 240) === 0) {
            ;(k = j), (g = L), (p = C)
            for (;;) {
              if (
                ((M = W.distcode[p + ((U & ((1 << (k + g)) - 1)) >> k)]),
                (j = M >>> 24),
                (L = (M >>> 16) & 255),
                (C = M & 65535),
                k + j <= P)
              )
                break
              if (X === 0) break J
              X--, (U += G[q++] << P), (P += 8)
            }
            ;(U >>>= k), (P -= k), (W.back += k)
          }
          if (((U >>>= j), (P -= j), (W.back += j), L & 64)) {
            ;(J.msg = 'invalid distance code'), (W.mode = h)
            break
          }
          ;(W.offset = C), (W.extra = L & 15), (W.mode = t8)
        case t8:
          if (W.extra) {
            N = W.extra
            while (P < N) {
              if (X === 0) break J
              X--, (U += G[q++] << P), (P += 8)
            }
            ;(W.offset += U & ((1 << W.extra) - 1)),
              (U >>>= W.extra),
              (P -= W.extra),
              (W.back += W.extra)
          }
          if (W.offset > W.dmax) {
            ;(J.msg = 'invalid distance too far back'), (W.mode = h)
            break
          }
          W.mode = J6
        case J6:
          if (z === 0) break J
          if (((K = F - z), W.offset > K)) {
            if (((K = W.offset - K), K > W.whave)) {
              if (W.sane) {
                ;(J.msg = 'invalid distance too far back'), (W.mode = h)
                break
              }
            }
            if (K > W.wnext) (K -= W.wnext), (Z = W.wsize - K)
            else Z = W.wnext - K
            if (K > W.length) K = W.length
            I = W.window
          } else (I = V), (Z = Y - W.offset), (K = W.length)
          if (K > z) K = z
          ;(z -= K), (W.length -= K)
          do V[Y++] = I[Z++]
          while (--K)
          if (W.length === 0) W.mode = M1
          break
        case W6:
          if (z === 0) break J
          ;(V[Y++] = W.length), z--, (W.mode = M1)
          break
        case _1:
          if (W.wrap) {
            while (P < 32) {
              if (X === 0) break J
              X--, (U |= G[q++] << P), (P += 8)
            }
            if (((F -= z), (J.total_out += F), (W.total += F), W.wrap & 4 && F))
              J.adler = W.check = W.flags
                ? _(W.check, V, F, Y - F)
                : t0(W.check, V, F, Y - F)
            if (((F = z), W.wrap & 4 && (W.flags ? U : V6(U)) !== W.check)) {
              ;(J.msg = 'incorrect data check'), (W.mode = h)
              break
            }
            ;(U = 0), (P = 0)
          }
          W.mode = Q6
        case Q6:
          if (W.wrap && W.flags) {
            while (P < 32) {
              if (X === 0) break J
              X--, (U += G[q++] << P), (P += 8)
            }
            if (W.wrap & 4 && U !== (W.total & 4294967295)) {
              ;(J.msg = 'incorrect length check'), (W.mode = h)
              break
            }
            ;(U = 0), (P = 0)
          }
          W.mode = G6
        case G6:
          v = $W
          break J
        case h:
          v = T6
          break J
        case y6:
          return v6
        default:
          return e
      }
    if (
      ((J.next_out = Y),
      (J.avail_out = z),
      (J.next_in = q),
      (J.avail_in = X),
      (W.hold = U),
      (W.bits = P),
      W.wsize || (F !== J.avail_out && W.mode < h && (W.mode < _1 || Q !== E8)))
    ) {
      if (u6(J, J.output, J.next_out, F - J.avail_out));
    }
    if (
      (($ -= J.avail_in),
      (F -= J.avail_out),
      (J.total_in += $),
      (J.total_out += F),
      (W.total += F),
      W.wrap & 4 && F)
    )
      J.adler = W.check = W.flags
        ? _(W.check, V, F, J.next_out - F)
        : t0(W.check, V, F, J.next_out - F)
    if (
      ((J.data_type =
        W.bits +
        (W.last ? 64 : 0) +
        (W.mode === q0 ? 128 : 0) +
        (W.mode === j1 || W.mode === c1 ? 256 : 0)),
      (($ === 0 && F === 0) || Q === E8) && v === I0)
    )
      v = jW
    return v
  },
  wW = (J) => {
    if (O0(J)) return e
    const Q = J.state
    if (Q.window) Q.window = null
    return (J.state = null), I0
  },
  AW = (J, Q) => {
    if (O0(J)) return e
    const W = J.state
    if ((W.wrap & 2) === 0) return e
    return (W.head = Q), (Q.done = !1), I0
  },
  NW = (J, Q) => {
    const W = Q.length
    let G, V, q
    if (O0(J)) return e
    if (((G = J.state), G.wrap !== 0 && G.mode !== I1)) return e
    if (G.mode === I1) {
      if (((V = 1), (V = t0(V, Q, W, 0)), V !== G.check)) return T6
    }
    if (((q = u6(J, Q, W, W)), q)) return (G.mode = y6), v6
    return (G.havedict = 1), I0
  },
  SW = h6,
  gW = p6,
  TW = f6,
  vW = xW,
  yW = b6,
  EW = DW,
  fW = wW,
  hW = AW,
  pW = NW,
  bW = 'pako inflate (from Nodeca project)',
  U0 = {
    inflateReset: SW,
    inflateReset2: gW,
    inflateResetKeep: TW,
    inflateInit: vW,
    inflateInit2: yW,
    inflate: EW,
    inflateEnd: fW,
    inflateGetHeader: hW,
    inflateSetDictionary: pW,
    inflateInfo: bW
  },
  mW = uW,
  m6 = Object.prototype.toString,
  {
    Z_NO_FLUSH: cW,
    Z_FINISH: _W,
    Z_OK: Q1,
    Z_STREAM_END: l1,
    Z_NEED_DICT: n1,
    Z_STREAM_ERROR: dW,
    Z_DATA_ERROR: X6,
    Z_MEM_ERROR: iW
  } = x0
X1.prototype.push = function (J, Q) {
  const W = this.strm,
    G = this.options.chunkSize,
    V = this.options.dictionary
  let q, Y, X
  if (this.ended) return !1
  if (Q === ~~Q) Y = Q
  else Y = Q === !0 ? _W : cW
  if (m6.call(J) === '[object ArrayBuffer]') W.input = new Uint8Array(J)
  else W.input = J
  ;(W.next_in = 0), (W.avail_in = W.input.length)
  for (;;) {
    if (W.avail_out === 0)
      (W.output = new Uint8Array(G)), (W.next_out = 0), (W.avail_out = G)
    if (((q = U0.inflate(W, Y)), q === n1 && V)) {
      if (((q = U0.inflateSetDictionary(W, V)), q === Q1)) q = U0.inflate(W, Y)
      else if (q === X6) q = n1
    }
    while (W.avail_in > 0 && q === l1 && W.state.wrap > 0 && J[W.next_in] !== 0)
      U0.inflateReset(W), (q = U0.inflate(W, Y))
    switch (q) {
      case dW:
      case X6:
      case n1:
      case iW:
        return this.onEnd(q), (this.ended = !0), !1
    }
    if (((X = W.avail_out), W.next_out)) {
      if (W.avail_out === 0 || q === l1)
        if (this.options.to === 'string') {
          const z = W1.utf8border(W.output, W.next_out),
            U = W.next_out - z,
            P = W1.buf2string(W.output, z)
          if (((W.next_out = U), (W.avail_out = G - U), U))
            W.output.set(W.output.subarray(z, z + U), 0)
          this.onData(P)
        } else
          this.onData(
            W.output.length === W.next_out
              ? W.output
              : W.output.subarray(0, W.next_out)
          )
    }
    if (q === Q1 && X === 0) continue
    if (q === l1)
      return (
        (q = U0.inflateEnd(this.strm)), this.onEnd(q), (this.ended = !0), !0
      )
    if (W.avail_in === 0) break
  }
  return !0
}
X1.prototype.onData = function (J) {
  this.chunks.push(J)
}
X1.prototype.onEnd = function (J) {
  if (J === Q1)
    if (this.options.to === 'string') this.result = this.chunks.join('')
    else this.result = O1.flattenChunks(this.chunks)
  ;(this.chunks = []), (this.err = J), (this.msg = this.strm.msg)
}
var nW = X1,
  rW = P8,
  oW = lW,
  aW = P8,
  eW = x0,
  sW = { Inflate: nW, inflate: rW, inflateRaw: oW, ungzip: aW, constants: eW },
  { Deflate: tW, deflate: J7, deflateRaw: W7, gzip: Q7 } = XW,
  { Inflate: G7, inflate: V7, inflateRaw: q7, ungzip: X7 } = sW,
  U7 = tW,
  Y7 = J7,
  P7 = W7,
  K7 = Q7,
  F7 = G7,
  z7 = V7,
  Z7 = q7,
  H7 = X7,
  k7 = x0,
  D0 = {
    Deflate: U7,
    deflate: Y7,
    deflateRaw: P7,
    gzip: K7,
    Inflate: F7,
    inflate: z7,
    inflateRaw: Z7,
    ungzip: H7,
    constants: k7
  }
function resolveConflict(existingNode, incomingNode, hybridClock) {
  let resolvedTimestamp = incomingNode.timestamp
  if (resolvedTimestamp?.physical > Date.now() + 7200000)
    resolvedTimestamp = { physical: Date.now() + 7200000, logical: resolvedTimestamp.logical }
  if (
    incomingNode?.value?.priority === true &&
    typeof incomingNode.id === 'string' &&
    incomingNode.id.startsWith('user:') &&
    'role' in incomingNode.value
  ) {
    const { priority: priorityValue, ...restValue } = incomingNode.value
    return { resolved: true, value: restValue, timestamp: resolvedTimestamp }
  }
  if (incomingNode?.value?.priority !== void 0) {
    const { priority: priorityValue, ...restValue } = incomingNode.value
    incomingNode = { ...incomingNode, value: restValue }
  }
  if (!existingNode?.timestamp) return { resolved: true, value: incomingNode.value, timestamp: resolvedTimestamp }
  if (hybridClock.compare(resolvedTimestamp, existingNode.timestamp) <= 0) return { resolved: false }
  return { resolved: true, value: incomingNode.value, timestamp: resolvedTimestamp }
}
function createOplogManager(databaseId, maxSize = 50) {
  const storageKey = `gdb_oplog_${databaseId}`
  let oplogEntries = []
  function loadFromStorage() {
    try {
      const storedData = localStorage.getItem(storageKey)
      oplogEntries = storedData ? JSON.parse(storedData) : []
    } catch (error) {
      console.error('\u274C GDB: Failed to load oplog from localStorage:', error),
        (oplogEntries = [])
    }
  }
  function saveToStorage() {
    try {
      localStorage.setItem(storageKey, JSON.stringify(oplogEntries))
    } catch (error) {
      console.error('\u274C GDB: Failed to save oplog to localStorage:', error)
    }
  }
  return (
    loadFromStorage(),
    {
      remove(entryId) {
        ;(oplogEntries = oplogEntries.filter((entry) => entry.id !== entryId)), saveToStorage()
      },
      add(entry) {
        if ((oplogEntries.push(entry), oplogEntries.length > maxSize)) oplogEntries.shift()
        saveToStorage()
      },
      getDelta(sinceTimestamp, compareFunction) {
        if (!sinceTimestamp) return [...oplogEntries]
        return oplogEntries.filter((entry) => compareFunction(entry.timestamp, sinceTimestamp) > 0)
      },
      getOldest() {
        return oplogEntries[0]
      },
      clear() {
        ;(oplogEntries = []), localStorage.removeItem(storageKey)
      }
    }
  )
}
var createWorker = () => {
    const pendingOperations = new Map(),
      acquireLock = async (fileName, operation) => {
        const operationQueue = pendingOperations.get(fileName) ?? []
        pendingOperations.set(fileName, operationQueue)
        const lastPromise = operationQueue[operationQueue.length - 1] ?? Promise.resolve()
        let resolvePromise
        const newPromise = new Promise((resolve) => (resolvePromise = resolve))
        operationQueue.push(newPromise)
        try {
          return await lastPromise, await operation()
        } finally {
          if ((operationQueue.shift(), resolvePromise(), !operationQueue.length)) pendingOperations.delete(fileName)
        }
      },
      requestFileLock = (fileName, operation) =>
        navigator.locks?.request?.(`opfs:${fileName}`, { mode: 'exclusive' }, operation) ??
        acquireLock(fileName, operation),
      testSyncAccess = async () => {
        try {
          const directory = await navigator.storage.getDirectory(),
            fileHandle = await (
              await directory.getFileHandle('~opfs-sync-test', { create: !0 })
            ).createSyncAccessHandle?.()
          return await fileHandle?.close(), await directory.removeEntry('~opfs-sync-test'), !!fileHandle
        } catch {
          return !1
        }
      }
    let storageMode = 'idb'
    const initializeStorage = (async () => {
        if (await testSyncAccess()) {
          storageMode = 'sync'
          return
        }
        try {
          const directory = await navigator.storage.getDirectory(),
            fileHandle = await (
              await directory.getFileHandle('~opfs-async-test', { create: !0 })
            ).createWritable?.()
          await fileHandle?.close(),
            await directory.removeEntry('~opfs-async-test'),
            (storageMode = fileHandle ? 'async' : 'idb')
        } catch {
          storageMode = 'idb'
        }
      })(),
      storageDirectory = navigator.storage.getDirectory(),
      idbFallback = (() => {
        let dbPromise
        const getDb = () =>
          (dbPromise ??= new Promise((resolve, reject) => {
            const request = indexedDB.open('opfs-fallback-db', 1)
            ;(request.onupgradeneeded = () => request.result.createObjectStore('files')),
              (request.onsuccess = () => resolve(request.result)),
              (request.onerror = () => reject(request.error))
          }))
        return {
          get: async (fileName) => {
            const db = await getDb()
            return new Promise((resolve, reject) => {
              const transaction = db.transaction('files', 'readonly')
                .objectStore('files')
                .get(fileName)
              ;(transaction.onsuccess = () => resolve(transaction.result || new Uint8Array())),
                (transaction.onerror = () => reject(transaction.error))
            })
          },
          set: async (fileName, data) => {
            const db = await getDb()
            return new Promise((resolve, reject) => {
              const transaction = db.transaction('files', 'readwrite')
                .objectStore('files')
                .put(data, fileName)
              ;(transaction.onsuccess = () => resolve()), (transaction.onerror = () => reject(transaction.error))
            })
          }
        }
      })(),
      loadFile = async (fileName) => {
        await initializeStorage
        try {
          if (storageMode === 'idb') {
            const data = await idbFallback.get(fileName)
            self.postMessage({ type: 'loaded', name: fileName, data }, [data.buffer])
            return
          }
          const fileHandle = await (await storageDirectory).getFileHandle(fileName).catch(() => null)
          if (!fileHandle) {
            const emptyData = new Uint8Array()
            self.postMessage({ type: 'loaded', name: fileName, data: emptyData }, [emptyData.buffer])
            return
          }
          const syncRead = async () => {
            try {
              const accessHandle = await fileHandle.createSyncAccessHandle()
              try {
                const fileSize = accessHandle.getSize(),
                  buffer = new Uint8Array(fileSize),
                  bytesRead = accessHandle.read(buffer, { at: 0 }),
                  fileData = buffer.slice(0, bytesRead)
                self.postMessage({ type: 'loaded', name: fileName, data: fileData }, [
                  fileData.buffer
                ])
              } finally {
                accessHandle.close()
              }
            } catch (error) {
              if (error?.name === 'NoModificationAllowedError') {
                const file = await fileHandle.getFile(),
                  fileBuffer = new Uint8Array(await file.arrayBuffer())
                self.postMessage({ type: 'loaded', name: fileName, data: fileBuffer }, [
                  fileBuffer.buffer
                ])
              } else throw error
            }
          }
          if (storageMode === 'sync') {
            await requestFileLock(fileName, syncRead)
            return
          }
          const file = await fileHandle.getFile(),
            fileBuffer = new Uint8Array(await file.arrayBuffer())
          self.postMessage({ type: 'loaded', name: fileName, data: fileBuffer }, [fileBuffer.buffer])
        } catch (error) {
          if (error?.name === 'NotFoundError') {
            const emptyData = new Uint8Array()
            self.postMessage({ type: 'loaded', name: fileName, data: emptyData }, [emptyData.buffer])
            return
          }
          console.error(`\u274C Worker file load error for '${fileName}':`, error),
            self.postMessage({
              type: 'error',
              name: fileName,
              message: error?.message ?? 'Error reading file'
            })
        }
      },
      saveFile = async (fileName, content) => {
        if ((await initializeStorage, !(content instanceof Uint8Array)))
          return {
            type: 'error',
            name: fileName,
            message: 'Content must be a Uint8Array'
          }
        return requestFileLock(fileName, async () => {
          try {
            if (storageMode === 'idb')
              return await idbFallback.set(fileName, content), { type: 'saved', name: fileName }
            const fileHandle = await (await storageDirectory).getFileHandle(fileName, { create: !0 })
            if (storageMode === 'sync') {
              const accessHandle = await fileHandle.createSyncAccessHandle()
              try {
                accessHandle.truncate(0), accessHandle.write(content, { at: 0 }), accessHandle.flush()
              } finally {
                accessHandle.close()
              }
            } else {
              const writable = await fileHandle.createWritable()
              try {
                await writable.write(content)
              } finally {
                await writable.close()
              }
            }
            return { type: 'saved', name: fileName }
          } catch (error) {
            return {
              type: 'error',
              name: fileName,
              message: error?.message ?? 'Error saving file'
            }
          }
        })
      }
    self.onmessage = async ({ data: message }) => {
      const { type: actionType, name: fileName, content: fileContent } = message
      await initializeStorage
      const handlers = { load: () => loadFile(fileName), save: () => saveFile(fileName, fileContent) }
      try {
        const handler = handlers[actionType],
          result = handler
            ? await handler()
            : { type: 'error', message: `Unrecognized action type: ${actionType}` }
        if (result?.type) self.postMessage(result)
      } catch (error) {
        console.error('\u274C Worker unexpected error:', error),
          self.postMessage({
            type: 'error',
            name: fileName,
            message: error?.message ?? 'Unexpected worker error'
          })
      }
    }
  },
  d6 = createWorker
var queryOperators = {
    $eq: (value, compareValue) => value === compareValue,
    $ne: (value, compareValue) => value !== compareValue,
    $gt: (value, compareValue) => value > compareValue,
    $gte: (value, compareValue) => value >= compareValue,
    $lt: (value, compareValue) => value < compareValue,
    $lte: (value, compareValue) => value <= compareValue,
    $in: (value, compareValue) =>
      Array.isArray(compareValue) &&
      (Array.isArray(value) ? value.some((item) => compareValue.includes(item)) : compareValue.includes(value)),
    $between: (value, [min, max]) => value >= min && value <= max,
    $exists: (value, shouldExist) => (shouldExist ? value !== void 0 : value === void 0),
    $startsWith: (value, prefix) => typeof value === 'string' && value.startsWith(prefix),
    $endsWith: (value, suffix) => typeof value === 'string' && value.endsWith(suffix),
    $contains: (value, substring) => typeof value === 'string' && value.includes(substring),
    $text: {
      global: (object, searchText) => {
        const normalizeText = (text) =>
            String(text)
              .normalize('NFD')
              .replace(/[\u0300-\u036f]/g, '')
              .toLowerCase()
              .replace(/[^\w\s]/g, ''),
          normalizedSearchText = normalizeText(searchText)
        return Object.values(object).some((value) =>
          typeof value === 'object' ? null.fieldSearch(value, normalizedSearchText) : normalizeText(value).includes(normalizedSearchText)
        )
      },
      field: (fieldValue, searchText) => {
        const normalizeText = (text) =>
            String(text)
              .normalize('NFD')
              .replace(/[\u0300-\u036f]/g, '')
              .toLowerCase()
              .replace(/[^\w\s]/g, ''),
          normalizedSearchText = normalizeText(searchText)
        return Array.isArray(fieldValue)
          ? fieldValue.some((item) => normalizeText(item).includes(normalizedSearchText))
          : normalizeText(fieldValue).includes(normalizedSearchText)
      }
    },
    $like: (value, pattern) =>
      typeof value === 'string' &&
      typeof pattern === 'string' &&
      new RegExp(`^${pattern.replace(/%/g, '.*').replace(/_/g, '.')}$`, 'i').test(value),
    $regex: (value, regexConfig) =>
      typeof value === 'string' && new RegExp(regexConfig.$regex || regexConfig, 'i').test(value),
    $and: (value, conditions, context) => conditions.every((condition) => context.createFilter(condition, context.allNodes)(value)),
    $or: (value, conditions, context) => conditions.some((condition) => context.createFilter(condition, context.allNodes)(value)),
    $not: (value, condition, context) => !context.createFilter(condition, context.allNodes)(value),
    $edge: (node, edgeQuery, context) => {
      if (!node.edges?.length || typeof edgeQuery !== 'object' || edgeQuery === null) return false
      const edgeFilter = context.createFilter(edgeQuery, context.allNodes),
        edgesToTraverse = [...node.edges],
        visitedNodes = new Set(edgesToTraverse).add(node.id),
        matchingNodes = []
      while (edgesToTraverse.length) {
        const currentEdgeId = edgesToTraverse.shift(),
          connectedNode = context.allNodes[currentEdgeId]
        if (!connectedNode) continue
        if (edgeFilter(connectedNode)) matchingNodes.push(connectedNode)
        connectedNode.edges?.forEach((neighborId) => !visitedNodes.has(neighborId) && visitedNodes.add(neighborId) && edgesToTraverse.push(neighborId))
      }
      if (matchingNodes.length) node._edgeResult = matchingNodes
      return matchingNodes.length > 0
    }
  },
  getNestedProperty = (object, propertyPath) =>
    propertyPath.split('.').reduce(
      (currentObject, propertyName) => (currentObject && typeof currentObject === 'object' && propertyName in currentObject ? currentObject[propertyName] : void 0),
      object
    ),
  createFilter = (queryConditions, allNodes) => {
    if (Object.keys(queryConditions).length === 0) return () => true
    return (node) =>
      Object.entries(queryConditions).every(([conditionKey, conditionValue]) => {
        if (conditionKey.startsWith('$'))
          return queryOperators[conditionKey](node, conditionValue, { createFilter: createFilter, allNodes: allNodes })
        let fieldValue = getNestedProperty(node.value, conditionKey)
        if (fieldValue === void 0) fieldValue = getNestedProperty(node, conditionKey)
        if (typeof conditionValue !== 'object' || conditionValue === null) return queryOperators.$eq(fieldValue, conditionValue)
        return Object.entries(conditionValue).every(([operator, operatorValue]) => {
          if (operator === '$text') return queryOperators.$text.field(fieldValue, operatorValue)
          if (operator === '$between' && operatorValue.every((date) => date instanceof Date))
            return queryOperators.$between(new Date(fieldValue), operatorValue)
          return queryOperators[operator]?.(fieldValue, operatorValue, { createFilter: createFilter, allNodes: allNodes }) ?? false
        })
      })
  },
  executeQuery = (allNodes, queryOptions) => {
    const { $edge: edgeQuery, ...nodeQuery } = queryOptions.query || {},
      nodeFilter = createFilter(nodeQuery, allNodes),
      filteredNodes = Object.values(allNodes).filter(nodeFilter)
    let resultNodes = [
      ...(edgeQuery
        ? (() => {
            const edgeFilter = createFilter({ $edge: edgeQuery }, allNodes)
            filteredNodes.forEach((node) => edgeFilter(node))
            const edgeResultMap = new Map()
            return (
              filteredNodes.forEach((node) => {
                if (node._edgeResult)
                  node._edgeResult.forEach((edgeNode) => edgeResultMap.set(edgeNode.id, edgeNode)),
                    delete node._edgeResult
              }),
              Array.from(edgeResultMap.values())
            )
          })()
        : filteredNodes)
    ]
    if (queryOptions.field) {
      const sortOrder = queryOptions.order === 'asc' ? 1 : -1
      resultNodes.sort((nodeA, nodeB) => {
        const valueA = getNestedProperty(nodeA.value, queryOptions.field),
          valueB = getNestedProperty(nodeB.value, queryOptions.field)
        if (typeof valueA === 'string' && typeof valueB === 'string')
          return valueA.localeCompare(valueB) * sortOrder
        return ((valueA ?? 0) - (valueB ?? 0)) * sortOrder
      })
    }
    if (queryOptions.$after) {
      const afterIndex = resultNodes.findIndex((node) => node.id === queryOptions.$after)
      resultNodes = afterIndex >= 0 ? resultNodes.slice(afterIndex + 1) : []
    }
    if (queryOptions.$before) {
      const beforeIndex = resultNodes.findIndex((node) => node.id === queryOptions.$before)
      resultNodes = beforeIndex >= 0 ? resultNodes.slice(0, beforeIndex) : []
    }
    if (queryOptions.$limit) resultNodes = resultNodes.slice(0, queryOptions.$limit)
    return resultNodes
  }
function createHybridClock() {
  let physicalTime = Date.now(),
    logicalCounter = 0
  return {
    now() {
      const currentTime = Date.now()
      return (physicalTime = Math.max(physicalTime, currentTime)), logicalCounter++, { physical: physicalTime, logical: logicalCounter }
    },
    update(remoteTimestamp) {
      if (
        !remoteTimestamp ||
        typeof remoteTimestamp.physical !== 'number' ||
        typeof remoteTimestamp.logical !== 'number'
      ) {
        console.warn(
          '\u26A0\uFE0F HybridClock.update received an invalid remote timestamp.',
          remoteTimestamp
        )
        return
      }
      ;(physicalTime = Math.max(physicalTime, remoteTimestamp.physical)), (logicalCounter = Math.max(logicalCounter, remoteTimestamp.logical) + 1)
    },
    compare(timestampA, timestampB) {
      if (!timestampA && !timestampB) return 0
      if (!timestampA) return -1
      if (!timestampB) return 1
      if (timestampA.physical > timestampB.physical) return 1
      if (timestampA.physical < timestampB.physical) return -1
      if (timestampA.logical > timestampB.logical) return 1
      if (timestampA.logical < timestampB.logical) return -1
      return 0
    }
  }
}
async function initializeOPFS() {
  if (
    (console.info(
      navigator?.storage?.getDirectory
        ? '\u2705 OPFS is enabled.'
        : '\uD83D\uDEAB OPFS is not available.'
    ),
    navigator?.storage?.getDirectory)
  )
    await navigator.storage.getDirectory()
}
var createInMemoryGraphManager = () => {
  const graphState = { nodes: {} }
  return {
    get nodes() {
      return graphState.nodes
    },
    set nodes(nodeData) {
      graphState.nodes = nodeData || {}
    },
    upsert(nodeId, nodeValue, timestamp) {
      const existingNode = graphState.nodes[nodeId]
      graphState.nodes[nodeId] = {
        id: nodeId,
        value: nodeValue && typeof nodeValue === 'object' ? deepClone(nodeValue) : nodeValue,
        edges: existingNode?.edges ? [...existingNode.edges] : [],
        timestamp: timestamp
      }
    },
    get(nodeId) {
      return graphState.nodes[nodeId] || null
    },
    link(sourceId, targetId, timestamp) {
      const sourceNode = graphState.nodes[sourceId],
        targetNode = graphState.nodes[targetId]
      if (sourceNode && targetNode && !sourceNode.edges.includes(targetId))
        graphState.nodes[sourceId] = { ...sourceNode, edges: [...sourceNode.edges, targetId], timestamp: timestamp }
    },
    getAllNodes() {
      return Object.values(graphState.nodes)
    },
    serialize() {
      return pako.deflate(encodeMessagePack(graphState.nodes))
    },
    deserialize(serializedData) {
      graphState.nodes = decodeMessagePack(pako.inflate(new Uint8Array(serializedData)))
    }
  }
}
async function initializeGenosDB(databaseId, options = {}) {
  console.info(
    '\x1B[36m\u26A1 GenosDB: Empowering distributed graph databases with real-time synchronization and scalability. Learn more: https://github.com/estebanrfp/gdb \u26A1\x1B[0m'
  )
  const {
      rtc: enableRTC = false,
      password: rtcPassword,
      sm: securityModuleOptions = false,
      audit: auditOptions = false,
      ii: identityModuleOptions = false,
      rx: reactiveModuleOptions = false,
      ai: aiModuleOptions = false,
      geo: geoModuleOptions = false,
      nlq: nlqModuleOptions = false,
      saveDelay: autoSaveDelay = 200,
      oplogSize: operationLogSize = 20
    } = options,
    graphManager = createInMemoryGraphManager(),
    hybridClock = createHybridClock(),
    oplogManager = createOplogManager(databaseId, operationLogSize),
    middlewareStack = []
  let lastSyncTimestamp = null,
    changeListeners = [],
    workerInstance = null,
    syncChannel = null,
    broadcastChannel = null,
    roomChannel = null
  const pendingOperations = [],
    databaseInstance = {}
  Object.defineProperties(databaseInstance, {
    syncChannel: { get: () => syncChannel },
    broadcastChannel: { get: () => broadcastChannel },
    hybridClock: { get: () => hybridClock },
    graph: {
      get: () => ({ getAllNodes: () => graphManager.getAllNodes(), get: (nodeId) => graphManager.get(nodeId) })
    },
    worker: { get: () => workerInstance },
    oplog: { get: () => oplogManager },
    options: { get: () => options },
    pako: { get: () => pako },
    encode: { get: () => encodeMessagePack },
    decode: { get: () => decodeMessagePack },
    deepClone: { get: () => deepClone }
  })
  async function loadModule(moduleName, moduleOptions) {
    try {
      const module = await import(new URL(`./${moduleName}.min.js`, import.meta.url).href),
        options = moduleOptions && typeof moduleOptions === 'object' ? moduleOptions : {},
        moduleExports = await module.init?.(databaseInstance, module, options)
      if (moduleExports) Object.assign(databaseInstance, moduleExports)
      return module
    } catch (error) {
      throw (console.error(`\u274C Initialization of ${moduleName} failed:`, error), error)
    }
  }
  function loadLastSyncTimestamp() {
    const timestampData = localStorage.getItem(`${databaseId}_time`)
    lastSyncTimestamp = timestampData ? JSON.parse(timestampData) : null
  }
  function saveLastSyncTimestamp(timestamp) {
    ;(lastSyncTimestamp = timestamp), localStorage.setItem(`${databaseId}_time`, JSON.stringify(timestamp))
  }
  function initializeWorker() {
    try {
      const workerBlobUrl = URL.createObjectURL(
        new Blob([`(${createWorker.toString()})()`], { type: 'application/javascript' })
      )
      ;(workerInstance = new Worker(workerBlobUrl)),
        URL.revokeObjectURL(workerBlobUrl),
        workerInstance.addEventListener('message', ({ data: message }) =>
          console.info(`\uD83D\uDCBE ${message.name} ${message.type}`)
        ),
        console.info('\u2699\uFE0F Worker initialized successfully.')
    } catch ({ message: error }) {
      console.error('\u274C Failed to initialize worker:', error)
    }
  }
  function notifyChangeListeners() {
    const currentGraphState = { ...graphManager.nodes }
    changeListeners.forEach((listener) => listener(currentGraphState))
  }
  const throttledNotifyListeners = throttleAnimationFrame(() => notifyChangeListeners()),
    debouncedSyncOperations = debounceAsync(async () => {
      const operations = pendingOperations.splice(0, pendingOperations.length)
      if (!operations.length) return false
      return await syncChannel.send(operations), true
    }, 16)
  async function loadDatabaseFromWorker() {
    try {
      const graphData = await ((fileName) =>
        new Promise((resolve, reject) => {
          const messageHandler = async ({ data: response }) => {
            if (response.type === 'loaded' && response.name === fileName)
              workerInstance.removeEventListener('message', messageHandler), resolve(new Uint8Array(response.data))
            else if (response.type === 'error')
              workerInstance.removeEventListener('message', messageHandler),
                reject(new Error(response.message || 'Unknown error'))
          }
          workerInstance.addEventListener('message', messageHandler),
            workerInstance.postMessage({ type: 'load', name: fileName })
        }))(`${databaseId}_graph.msgpack`).catch(() => new Uint8Array())
      graphData.byteLength > 0
        ? graphManager.deserialize(graphData)
        : console.info(
            '\uD83D\uDCBE New database. File will be created on first save.'
          )
    } catch ({ message: error }) {
      console.error('\u274C Error loading the graph:', error)
    }
  }
  async function saveDatabaseToWorker() {
    try {
      const serializedData = graphManager.serialize()
      return (
        await ((fileName, data) =>
          new Promise((resolve, reject) => {
            const messageHandler = ({ data: response }) => {
              if (response.type === 'saved' && response.name === fileName)
                workerInstance.removeEventListener('message', messageHandler), resolve()
              else if (response.type === 'error')
                workerInstance.removeEventListener('message', messageHandler),
                  reject(new Error(response.message || 'Save error'))
            }
            workerInstance.addEventListener('message', messageHandler),
              workerInstance.postMessage({ type: 'save', name: fileName, content: data })
          }))(`${databaseId}_graph.msgpack`, serializedData),
        broadcastChannel.postMessage('update'),
        !0
      )
    } catch ({ message: error }) {
      throw (console.error('\u274C Save error:', error), new Error('Save failed'))
    }
  }
  const debouncedSave = debounceAsync(() => saveDatabaseToWorker(), autoSaveDelay)
  async function processOperations(operations) {
    let hasChanges = !1,
      latestTimestamp = null
    const updateLatestTimestamp = (timestamp) => {
        if (!latestTimestamp || hybridClock.compare(timestamp, latestTimestamp) > 0) latestTimestamp = timestamp
      },
      decodeOperations = (operationsData) => {
        try {
          if (operationsData instanceof Uint8Array) return decodeMessagePack(pako.inflate(operationsData))
          if (Array.isArray(operationsData)) return operationsData
          if (operationsData && typeof operationsData === 'object')
            return decodeMessagePack(pako.inflate(new Uint8Array(Object.values(operationsData))))
        } catch (error) {
          console.error('\u274C deltaSync decode failed', error)
        }
        return null
      },
      operationHandlers = {
        upsert: (operation) => {
          const existingNode = graphManager.get(operation.id),
            { resolved: isResolved, value: nodeValue, timestamp: newTimestamp } = resolveConflict(existingNode, operation, hybridClock)
          if (!isResolved) return
          graphManager.upsert(operation.id, nodeValue, newTimestamp),
            hybridClock.update(newTimestamp),
            oplogManager.add({ type: 'upsert', id: operation.id, timestamp: newTimestamp }),
            (hasChanges = !0),
            updateLatestTimestamp(newTimestamp)
        },
        remove: (operation) => {
          const existingNode = graphManager.get(operation.id)
          if (!existingNode || hybridClock.compare(existingNode.timestamp, operation.timestamp) >= 0) return
          delete graphManager.nodes[operation.id],
            hybridClock.update(operation.timestamp),
            oplogManager.add({ type: 'remove', id: operation.id, timestamp: operation.timestamp }),
            (hasChanges = !0),
            updateLatestTimestamp(operation.timestamp)
        },
        link: (operation) => {
          const sourceNode = graphManager.get(operation.sourceId),
            targetNode = graphManager.get(operation.targetId)
          if (!sourceNode || !targetNode || hybridClock.compare(sourceNode.timestamp, operation.timestamp) >= 0) return
          graphManager.link(operation.sourceId, operation.targetId, operation.timestamp),
            hybridClock.update(operation.timestamp),
            oplogManager.add({ type: 'link', ...operation }),
            (hasChanges = !0),
            updateLatestTimestamp(operation.timestamp)
        },
        sync: async ({ timestamp: remoteTimestamp }) => {
          const oldestOp = oplogManager.getOldest()
          if (remoteTimestamp == null || (oldestOp && hybridClock.compare(remoteTimestamp, oldestOp.timestamp) < 0))
            return (
              console.info(
                '\uD83D\uDCA5 [FALLBACK] Peer too far behind \u2192 sending FULL state.'
              ),
              syncChannel.send([
                {
                  type: 'fullStateSync',
                  graphData: graphManager.serialize(),
                  timestamp: lastSyncTimestamp
                }
              ])
            )
          const deltaOps = oplogManager.getDelta(remoteTimestamp, hybridClock.compare)
          if (!deltaOps.length) return
          const enrichedOps = deltaOps.map((op) =>
            op.type === 'upsert' ? { ...op, value: graphManager.get(op.id)?.value } : op
          )
          console.info(`\uD83D\uDE80 [DELTA SYNC SENDING] ${enrichedOps.length} ops.`),
            await syncChannel.send([
              {
                type: 'deltaSync',
                operations: pako.deflate(encodeMessagePack(enrichedOps)),
                timestamp: lastSyncTimestamp
              }
            ])
        },
        deltaSync: ({ operations: operationsData }) => {
          const decodedOps = decodeOperations(operationsData)
          if (!Array.isArray(decodedOps)) {
            console.warn('\u26A0\uFE0F deltaSync payload not array. Ignored.')
            return
          }
          console.log(
            `\uD83D\uDEF0\uFE0F [DELTA SYNC RECEIVED] ${decodedOps.length} ops.`
          )
          for (const operation of decodedOps)
            if (operation && operationHandlers[operation.type]) operationHandlers[operation.type](operation)
            else if (operation) console.warn(`\uD83E\uDD37 Unknown op: ${operation.type}`)
        },
        fullStateSync: async ({ graphData: graphData, timestamp: remoteTimestamp }) => {
          if (lastSyncTimestamp && remoteTimestamp && hybridClock.compare(lastSyncTimestamp, remoteTimestamp) > 0) {
            console.log('\uD83D\uDD04 Local newer, ignoring full sync.')
            return
          }
          if (!(graphData instanceof Uint8Array))
            if (graphData && typeof graphData === 'object') graphData = new Uint8Array(Object.values(graphData))
            else {
              console.error('\u274C Invalid full graph data received')
              return
            }
          try {
            if (
              (console.log(
                '\uD83D\uDCE6 [FULL SYNC RECEIVED] Applying full graph.'
              ),
              graphManager.deserialize(graphData),
              oplogManager.clear(),
              (hasChanges = !0),
              remoteTimestamp)
            )
              updateLatestTimestamp(remoteTimestamp), hybridClock.update(remoteTimestamp)
          } catch (error) {
            console.error('\u274C Full sync failed:', error)
          }
        }
      }
    for (const operation of operations)
      if (operationHandlers[operation.type]) await operationHandlers[operation.type](operation)
      else console.warn(`\uD83E\uDD37 Unknown type: ${operation.type}`)
    if (latestTimestamp && (!lastSyncTimestamp || hybridClock.compare(latestTimestamp, lastSyncTimestamp) > 0))
      console.info(`\uD83D\uDCC8 [GLOBAL TS] Advanced to ${latestTimestamp.logical}`), saveLastSyncTimestamp(latestTimestamp)
    if (hasChanges)
      console.info('\uD83D\uDCBE [STATE CHANGED] Saving + emitting.'),
        await debouncedSave(),
        notifyChangeListeners()
  }
  Object.assign(databaseInstance, {
    use(middleware) {
      if (typeof middleware === 'function') middlewareStack.push(middleware)
    },
    async put(nodeValue, nodeId) {
      const timestamp = hybridClock.now()
      saveLastSyncTimestamp(timestamp),
        (nodeId = nodeId ?? crypto.randomUUID()),
        graphManager.upsert(nodeId, nodeValue, timestamp),
        oplogManager.add({ type: 'upsert', id: nodeId, timestamp: timestamp }),
        debouncedSave()
      try {
        pendingOperations.push({ type: 'upsert', id: nodeId, value: nodeValue, timestamp: timestamp }),
          debouncedSyncOperations().catch(() => {})
      } finally {
        notifyChangeListeners()
      }
      return nodeId
    },
    async link(sourceId, targetId) {
      const timestamp = hybridClock.now()
      if (!graphManager.nodes[sourceId] || !graphManager.nodes[targetId]) {
        console.warn(
          `\u26A0\uFE0F One or both nodes (${sourceId}, ${targetId}) do not exist.`
        )
        return
      }
      graphManager.link(sourceId, targetId, timestamp),
        oplogManager.add({ type: 'link', sourceId: sourceId, targetId: targetId, timestamp: timestamp }),
        debouncedSave(),
        saveLastSyncTimestamp(timestamp)
      try {
        pendingOperations.push({ type: 'link', sourceId: sourceId, targetId: targetId, timestamp: timestamp }),
          debouncedSyncOperations().catch(() => {})
      } finally {
        notifyChangeListeners()
      }
    },
    async remove(nodeId) {
      const timestamp = hybridClock.now(),
        existingNode = graphManager.get(nodeId)
      if (!existingNode) return console.warn(`\u26A0\uFE0F Node with ID '${nodeId}' not found.`)
      delete graphManager.nodes[nodeId],
        oplogManager.add({ type: 'remove', id: nodeId, timestamp: timestamp }),
        Object.values(graphManager.nodes).forEach(
          (node) => (node.edges = node.edges.filter((edgeId) => edgeId !== nodeId))
        ),
        debouncedSave(),
        saveLastSyncTimestamp(timestamp)
      try {
        pendingOperations.push({ type: 'remove', id: nodeId, value: existingNode.value, timestamp: timestamp }),
          debouncedSyncOperations().catch(() => {})
      } finally {
        notifyChangeListeners()
      }
    },
    async get(nodeId, callback = null) {
      if (typeof nodeId !== 'string') return { result: null }
      const node = graphManager.get(nodeId)
      if (!node) {
        if (callback) callback(null)
        return { result: null }
      }
      const cloneNode = (nodeData) => {
        if (!nodeData) return null
        const value =
          nodeData.value !== null && typeof nodeData.value === 'object'
            ? { ...nodeData.value }
            : nodeData.value
        return { ...nodeData, value: value }
      }
      if (!callback) return { result: cloneNode(node) }
      let lastTimestamp = node.timestamp
      callback(cloneNode(node))
      const changeListener = (graphState) => {
        const currentNode = graphState[nodeId]
        if (currentNode) {
          if (hybridClock.compare(currentNode.timestamp, lastTimestamp) > 0) (lastTimestamp = currentNode.timestamp), callback(cloneNode(currentNode))
        } else callback(null), changeListeners.splice(changeListeners.indexOf(changeListener), 1)
      }
      return (
        changeListeners.push(changeListener),
        {
          result: cloneNode(node),
          unsubscribe: () => {
            const index = changeListeners.indexOf(changeListener)
            if (index > -1) changeListeners.splice(index, 1)
          }
        }
      )
    },
    async map(...args) {
      let queryOptions = {
          ...{
            realtime: !1,
            query: {},
            field: null,
            order: 'asc',
            $limit: null,
            $after: null,
            $before: null
          }
        },
        callback = null,
        hasRealtimeOption = !1
      args.forEach((arg) =>
        typeof arg === 'function'
          ? (callback = arg)
          : arg &&
            typeof arg === 'object' &&
            ((hasRealtimeOption = hasRealtimeOption || 'realtime' in arg), Object.assign(queryOptions, arg))
      ),
        callback && !hasRealtimeOption && (queryOptions.realtime = !0)
      let results = executeQuery(graphManager.nodes, queryOptions),
        changeHandler = null
      const processChanges = (newNodes) => {
        const oldNodesMap = new Map(results.map((node) => [node.id, node])),
          newNodesMap = new Map(newNodes.map((node) => [node.id, node])),
          addedNodes = [],
          updatedNodes = [],
          removedNodes = []
        for (const [nodeId, newNode] of newNodesMap) {
          const oldNode = oldNodesMap.get(nodeId)
          if (!oldNode) addedNodes.push(newNode)
          else if (
            (newNode.timestamp?.physical || 0) !== (oldNode.timestamp?.physical || 0) ||
            (newNode.timestamp?.logical || 0) !== (oldNode.timestamp?.logical || 0) ||
            !arraysEqual(newNode.edges || [], oldNode.edges || [])
          )
            updatedNodes.push(newNode)
        }
        for (const [nodeId] of oldNodesMap) if (!newNodesMap.has(nodeId)) removedNodes.push(oldNodesMap.get(nodeId))
        const notifyChange = (node, action) =>
          callback({
            id: node.id,
            value: action === 'removed' ? null : node.value,
            edges: node.edges || [],
            timestamp: node.timestamp || null,
            action: action
          })
        addedNodes.forEach((node) => notifyChange(node, 'added')),
          removedNodes.forEach((node) => notifyChange(node, 'removed')),
          updatedNodes.forEach((node) => notifyChange(node, 'updated'))
      }
      if (callback) {
        if (
          (results.forEach((node) => {
            callback({
              id: node.id,
              value: node.value,
              edges: node.edges,
              timestamp: node.timestamp,
              action: 'initial'
            })
          }),
          queryOptions.realtime)
        ) {
          const getNodeSignature = (node) => {
            const physical = node.timestamp?.physical || 0,
              logical = node.timestamp?.logical || 0,
              edgesSignature = (node.edges || []).join(',')
            return `${node.id}:${physical}:${logical}:${edgesSignature}`
          }
          ;(changeHandler = (graphState) => {
            const newResults = executeQuery(graphState, queryOptions)
            if (newResults.length !== results.length) processChanges(newResults), (results = newResults)
            else {
              const oldSignatures = results.map(getNodeSignature),
                newSignatures = newResults.map(getNodeSignature)
              if (!arraysEqual(oldSignatures, newSignatures)) processChanges(newResults), (results = newResults)
            }
          }),
            changeListeners.push(changeHandler)
        }
      }
      return {
        results: results,
        ...(queryOptions.realtime &&
          callback &&
          changeHandler && {
            unsubscribe: () => {
              const index = changeListeners.indexOf(changeHandler)
              index > -1 && changeListeners.splice(index, 1)
            }
          })
      }
    },
    async clear() {
      graphManager.nodes = {}
      try {
        await (await navigator.storage.getDirectory()).removeEntry(
          `${databaseId}_graph.msgpack`
        )
      } catch ({ message: error }) {
        console.warn(`\u26A0\uFE0F Error deleting _graph.msgpack: ${error}`)
      }
      loadLastSyncTimestamp(), console.info('\u2705 All data has been deleted.')
    }
  }),
    loadLastSyncTimestamp(),
    notifyChangeListeners(),
    await initializeOPFS(),
    await loadDatabaseFromWorker()
  const modulePromises = []
  if (securityModuleOptions) modulePromises.push(loadModule('sm', securityModuleOptions))
  if (aiModuleOptions) modulePromises.push(loadModule('ai', aiModuleOptions))
  if (reactiveModuleOptions) modulePromises.push(loadModule('rx', reactiveModuleOptions))
  if (identityModuleOptions) modulePromises.push(loadModule('ii', identityModuleOptions))
  if (auditOptions) modulePromises.push(loadModule('audit', auditOptions))
  if (geoModuleOptions) modulePromises.push(loadModule('geo', geoModuleOptions))
  if (nlqModuleOptions) modulePromises.push(loadModule('nlq', nlqModuleOptions))
  await Promise.all(modulePromises)
  const roomName = `graph-sync-room-${databaseId}`
  if (enableRTC) {
    const { join: joinRoom } = await loadModule('genosrtc'),
      { relayUrls: relayUrls, turnConfig: turnConfig } = enableRTC?.constructor === Object ? enableRTC : {},
      rtcConfig = { appId: '1234', ...(rtcPassword && { password: rtcPassword }) }
    if (relayUrls) rtcConfig.relayUrls = relayUrls
    if (turnConfig) rtcConfig.turnConfig = turnConfig
    const room = joinRoom(rtcConfig, roomName)
    ;(syncChannel = room.channel('syncGraph')),
      (roomChannel = joinRoom(rtcConfig, `app-sync-${databaseId}`)),
      (databaseInstance.room = roomChannel),
      room.on('peer:join', async (peerId) => {
        console.info('\u26A1 New peer connected:', peerId),
          syncChannel.send([{ type: 'sync', timestamp: lastSyncTimestamp }])
      }),
      room.on('peer:leave', (peerId) => {
        console.info('\u26A1 Peer disconnected:', peerId)
      }),
      syncChannel?.on('message', async (messageData) => {
        let operations
        try {
          if (messageData instanceof Uint8Array || messageData instanceof ArrayBuffer) {
            const decodedData = decodeMessagePack(messageData)
            operations = Array.isArray(decodedData) ? decodedData : [decodedData]
          } else operations = Array.isArray(messageData) ? messageData : [messageData]
        } catch (error) {
          return console.error('\u274C Failed to decode MessagePack:', error)
        }
        const nodeMap = new Map(
          [
            ...new Set(
              operations.flatMap((op) =>
                ['id', 'sourceId', 'targetId']
                  .map((field) => op?.[field])
                  .filter(Boolean)
              )
            )
          ]
            .map((nodeId) => (graphManager.get(nodeId) ? [nodeId, deepClone(graphManager.get(nodeId))] : null))
            .filter(Boolean)
        )
        for (const middleware of middlewareStack)
          try {
            if (((operations = await middleware(operations, nodeMap)), !operations || !operations.length)) return
          } catch (error) {
            console.error('\u274C Middleware error, discarding message.', error)
            return
          }
        await processOperations(operations)
      })
  }
  return (
    (broadcastChannel = new BroadcastChannel(`graphdb_sync_${databaseId}`)),
    (broadcastChannel.onmessage = async (event) => {
      if (event.data === 'update')
        console.info('\uD83D\uDD04 Update received from another tab...'),
          await loadDatabaseFromWorker(),
          notifyChangeListeners(),
          notifyChangeListeners()
    }),
    console.info(`\u2705 GenosDB [ \x1B[32m${databaseId}\x1B[0m ] instance is ready.`),
    databaseInstance
  )
}
var arraysEqual = (arrayA, arrayB) => arrayA.length === arrayB.length && arrayA.every((item, index) => item === arrayB[index]),
  deepClone = (object) =>
    object && typeof object === 'object'
      ? (globalThis.structuredClone?.(object) ?? JSON.parse(JSON.stringify(object)))
      : object,
  debounceAsync = (asyncFunction, timeout = 16) => {
    let timeoutId = null,
      promiseState = null
    return (...args) => {
      if (!promiseState)
        (promiseState = {}),
          (promiseState.promise = new Promise((resolve, reject) => ((promiseState.resolve = resolve), (promiseState.reject = reject))))
      if (timeoutId)
        ('cancelIdleCallback' in window ? cancelIdleCallback : clearTimeout)(timeoutId)
      const executeFunction = async () => {
        timeoutId = null
        try {
          promiseState.resolve(await asyncFunction(...args))
        } catch (error) {
          promiseState.reject(error)
        } finally {
          promiseState = null
        }
      }
      return (
        (timeoutId =
          'requestIdleCallback' in window
            ? requestIdleCallback(executeFunction, { timeout: timeout })
            : setTimeout(executeFunction, timeout)),
        promiseState.promise
      )
    }
  },
  throttleAnimationFrame = (callbackFunction) => {
    let animationFrameId = null
    return () => {
      if (animationFrameId !== null) return
      animationFrameId = requestAnimationFrame(() => {
        ;(animationFrameId = null), callbackFunction()
      })
    }
  }
export { initializeGenosDB as gdb }
