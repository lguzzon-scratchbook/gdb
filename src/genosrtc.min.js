var A0=typeof globalThis==="object"&&("crypto"in globalThis)?globalThis.crypto:void 0;function w0($){return $ instanceof Uint8Array||ArrayBuffer.isView($)&&$.constructor.name==="Uint8Array"}function d0($){if(!Number.isSafeInteger($)||$<0)throw new Error("positive integer expected, got "+$)}function $0($,...J){if(!w0($))throw new Error("Uint8Array expected");if(J.length>0&&!J.includes($.length))throw new Error("Uint8Array expected of length "+J+", got length="+$.length)}function Y8($){if(typeof $!=="function"||typeof $.create!=="function")throw new Error("Hash should be wrapped by utils.createHasher");d0($.outputLen),d0($.blockLen)}function b0($,J=!0){if($.destroyed)throw new Error("Hash instance has been destroyed");if(J&&$.finished)throw new Error("Hash#digest() has already been called")}function U$($,J){$0($);const q=J.outputLen;if($.length<q)throw new Error("digestInto() expects output buffer of length at least "+q)}function I0(...$){for(let J=0;J<$.length;J++)$[J].fill(0)}function X8($){return new DataView($.buffer,$.byteOffset,$.byteLength)}function Q0($,J){return $<<32-J|$>>>J}function Z0($){if($0($),j$)return $.toHex();let J="";for(let q=0;q<$.length;q++)J+=OQ[$[q]];return J}var z$=function($){if($>=X0._0&&$<=X0._9)return $-X0._0;if($>=X0.A&&$<=X0.F)return $-(X0.A-10);if($>=X0.a&&$<=X0.f)return $-(X0.a-10);return};function k0($){if(typeof $!=="string")throw new Error("hex string expected, got "+typeof $);if(j$)return Uint8Array.fromHex($);const J=$.length,q=J/2;if(J%2)throw new Error("hex string expected, got unpadded hex of length "+J);const Q=new Uint8Array(q);for(let G=0,z=0;G<q;G++,z+=2){const U=z$($.charCodeAt(z)),X=z$($.charCodeAt(z+1));if(U===void 0||X===void 0){const Z=$[z]+$[z+1];throw new Error('hex string expected, got non-hex character "'+Z+'" at index '+z)}Q[G]=U*16+X}return Q}function Z8($){if(typeof $!=="string")throw new Error("string expected");return new Uint8Array((new TextEncoder()).encode($))}function o0($){if(typeof $==="string")$=Z8($);return $0($),$}function o(...$){let J=0;for(let Q=0;Q<$.length;Q++){const G=$[Q];$0(G),J+=G.length}const q=new Uint8Array(J);for(let Q=0,G=0;Q<$.length;Q++){const z=$[Q];q.set(z,G),G+=z.length}return q}function Y$($){const J=(Q)=>$().update(o0(Q)).digest(),q=$();return J.outputLen=q.outputLen,J.blockLen=q.blockLen,J.create=()=>$(),J}function S0($=32){if(A0&&typeof A0.getRandomValues==="function")return A0.getRandomValues(new Uint8Array($));if(A0&&typeof A0.randomBytes==="function")return Uint8Array.from(A0.randomBytes($));throw new Error("crypto.getRandomValues must be defined")}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */var j$=(()=>typeof Uint8Array.from([]).toHex==="function"&&typeof Uint8Array.fromHex==="function")(),OQ=Array.from({length:256},($,J)=>J.toString(16).padStart(2,"0")),X0={_0:48,_9:57,A:65,F:70,a:97,f:102};class r0{}function RQ($,J,q,Q){if(typeof $.setBigUint64==="function")return $.setBigUint64(J,q,Q);const G=BigInt(32),z=BigInt(4294967295),U=Number(q>>G&z),X=Number(q&z),Z=Q?4:0,V=Q?0:4;$.setUint32(J+Z,U,Q),$.setUint32(J+V,X,Q)}function X$($,J,q){return $&J^~$&q}function Z$($,J,q){return $&J^$&q^J&q}class E8 extends r0{constructor($,J,q,Q){super();this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=$,this.outputLen=J,this.padOffset=q,this.isLE=Q,this.buffer=new Uint8Array($),this.view=X8(this.buffer)}update($){b0(this),$=o0($),$0($);const{view:J,buffer:q,blockLen:Q}=this,G=$.length;for(let z=0;z<G;){const U=Math.min(Q-this.pos,G-z);if(U===Q){const X=X8($);for(;Q<=G-z;z+=Q)this.process(X,z);continue}if(q.set($.subarray(z,z+U),this.pos),this.pos+=U,z+=U,this.pos===Q)this.process(J,0),this.pos=0}return this.length+=$.length,this.roundClean(),this}digestInto($){b0(this),U$($,this),this.finished=!0;const{buffer:J,view:q,blockLen:Q,isLE:G}=this;let{pos:z}=this;if(J[z++]=128,I0(this.buffer.subarray(z)),this.padOffset>Q-z)this.process(q,0),z=0;for(let N=z;N<Q;N++)J[N]=0;RQ(q,Q-8,BigInt(this.length*8),G),this.process(q,0);const U=X8($),X=this.outputLen;if(X%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const Z=X/4,V=this.get();if(Z>V.length)throw new Error("_sha2: outputLen bigger than state");for(let N=0;N<Z;N++)U.setUint32(4*N,V[N],G)}digest(){const{buffer:$,outputLen:J}=this;this.digestInto($);const q=$.slice(0,J);return this.destroy(),q}_cloneInto($){$||($=new this.constructor),$.set(...this.get());const{blockLen:J,buffer:q,length:Q,finished:G,destroyed:z,pos:U}=this;if($.destroyed=z,$.finished=G,$.length=Q,$.pos=U,Q%J)$.buffer.set(q);return $}clone(){return this._cloneInto()}}var K0=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]);var LQ=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),B0=new Uint32Array(64);class K$ extends E8{constructor($=32){super(64,$,8,!1);this.A=K0[0]|0,this.B=K0[1]|0,this.C=K0[2]|0,this.D=K0[3]|0,this.E=K0[4]|0,this.F=K0[5]|0,this.G=K0[6]|0,this.H=K0[7]|0}get(){const{A:$,B:J,C:q,D:Q,E:G,F:z,G:U,H:X}=this;return[$,J,q,Q,G,z,U,X]}set($,J,q,Q,G,z,U,X){this.A=$|0,this.B=J|0,this.C=q|0,this.D=Q|0,this.E=G|0,this.F=z|0,this.G=U|0,this.H=X|0}process($,J){for(let N=0;N<16;N++,J+=4)B0[N]=$.getUint32(J,!1);for(let N=16;N<64;N++){const L=B0[N-15],j=B0[N-2],K=Q0(L,7)^Q0(L,18)^L>>>3,H=Q0(j,17)^Q0(j,19)^j>>>10;B0[N]=H+B0[N-7]+K+B0[N-16]|0}let{A:q,B:Q,C:G,D:z,E:U,F:X,G:Z,H:V}=this;for(let N=0;N<64;N++){const L=Q0(U,6)^Q0(U,11)^Q0(U,25),j=V+L+X$(U,X,Z)+LQ[N]+B0[N]|0,H=(Q0(q,2)^Q0(q,13)^Q0(q,22))+Z$(q,Q,G)|0;V=Z,Z=X,X=U,U=z+j|0,z=G,G=Q,Q=q,q=j+H|0}q=q+this.A|0,Q=Q+this.B|0,G=G+this.C|0,z=z+this.D|0,U=U+this.E|0,X=X+this.F|0,Z=Z+this.G|0,V=V+this.H|0,this.set(q,Q,G,z,U,X,Z,V)}roundClean(){I0(B0)}destroy(){this.set(0,0,0,0,0,0,0,0),I0(this.buffer)}}var K8=Y$(()=>new K$);class f8 extends r0{constructor($,J){super();this.finished=!1,this.destroyed=!1,Y8($);const q=o0(J);if(this.iHash=$.create(),typeof this.iHash.update!=="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const Q=this.blockLen,G=new Uint8Array(Q);G.set(q.length>Q?$.create().update(q).digest():q);for(let z=0;z<G.length;z++)G[z]^=54;this.iHash.update(G),this.oHash=$.create();for(let z=0;z<G.length;z++)G[z]^=54^92;this.oHash.update(G),I0(G)}update($){return b0(this),this.iHash.update($),this}digestInto($){b0(this),$0($,this.outputLen),this.finished=!0,this.iHash.digestInto($),this.oHash.update($),this.oHash.digestInto($),this.destroy()}digest(){const $=new Uint8Array(this.oHash.outputLen);return this.digestInto($),$}_cloneInto($){$||($=Object.create(Object.getPrototypeOf(this),{}));const{oHash:J,iHash:q,finished:Q,destroyed:G,blockLen:z,outputLen:U}=this;return $=$,$.finished=Q,$.destroyed=G,$.blockLen=z,$.outputLen=U,$.oHash=J._cloneInto($.oHash),$.iHash=q._cloneInto($.iHash),$}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}var v8=($,J,q)=>new f8($,J).update(q).digest();v8.create=($,J)=>new f8($,J);function p0($,J=""){if(typeof $!=="boolean"){const q=J&&`"${J}"`;throw new Error(q+"expected boolean, got type="+typeof $)}return $}function x0($,J,q=""){const Q=w0($),G=$?.length,z=J!==void 0;if(!Q||z&&G!==J){const U=q&&`"${q}" `,X=z?` of length ${J}`:"",Z=Q?`length=${G}`:`type=${typeof $}`;throw new Error(U+"expected Uint8Array"+X+", got "+Z)}return $}function i0($){const J=$.toString(16);return J.length&1?"0"+J:J}function M$($){if(typeof $!=="string")throw new Error("hex string expected, got "+typeof $);return $===""?g8:BigInt("0x"+$)}function M0($){return M$(Z0($))}function y8($){return $0($),M$(Z0(Uint8Array.from($).reverse()))}function _0($,J){return k0($.toString(16).padStart(J*2,"0"))}function u8($,J){return _0($,J).reverse()}function m($,J,q){let Q;if(typeof J==="string")try{Q=k0(J)}catch(z){throw new Error($+" must be hex string or Uint8Array, cause: "+z)}else if(w0(J))Q=Uint8Array.from(J);else throw new Error($+" must be hex string or Uint8Array");const G=Q.length;if(typeof q==="number"&&G!==q)throw new Error($+" of length "+q+" expected, got "+G);return Q}function a0($,J,q){return b8($)&&b8(J)&&b8(q)&&J<=$&&$<q}function D$($,J,q,Q){if(!a0(J,q,Q))throw new Error("expected valid "+$+": "+q+" <= n < "+Q+", got "+J)}function M8($){let J;for(J=0;$>g8;$>>=_8,J+=1);return J}function W$($,J,q){if(typeof $!=="number"||$<2)throw new Error("hashLen must be a number");if(typeof J!=="number"||J<2)throw new Error("qByteLen must be a number");if(typeof q!=="function")throw new Error("hmacFn must be a function");const Q=(K)=>new Uint8Array(K),G=(K)=>Uint8Array.of(K);let z=Q($),U=Q($),X=0;const Z=()=>{z.fill(1),U.fill(0),X=0},V=(...K)=>q(U,z,...K),N=(K=Q(0))=>{if(U=V(G(0),K),z=V(),K.length===0)return;U=V(G(1),K),z=V()},L=()=>{if(X++>=1000)throw new Error("drbg: tried 1000 values");let K=0;const H=[];while(K<J){z=V();const A=z.slice();H.push(A),K+=z.length}return o(...H)};return(K,H)=>{Z(),N(K);let A=void 0;while(!(A=H(L())))N();return Z(),A}}function n0($,J,q={}){if(!$||typeof $!=="object")throw new Error("expected valid options object");function Q(G,z,U){const X=$[G];if(U&&X===void 0)return;const Z=typeof X;if(Z!==z||X===null)throw new Error(`param "${G}" is invalid: expected ${z}, got ${Z}`)}Object.entries(J).forEach(([G,z])=>Q(G,z,!1)),Object.entries(q).forEach(([G,z])=>Q(G,z,!0))}function m8($){const J=new WeakMap;return(q,...Q)=>{const G=J.get(q);if(G!==void 0)return G;const z=$(q,...Q);return J.set(q,z),z}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var g8=BigInt(0),_8=BigInt(1),b8=($)=>typeof $==="bigint"&&g8<=$,H0=($)=>(_8<<BigInt($))-_8;function p($,J){const q=$%J;return q>=l?q:J+q}function i($,J,q){let Q=$;while(J-- >l)Q*=Q,Q%=q;return Q}function N$($,J){if($===l)throw new Error("invert: expected non-zero number");if(J<=l)throw new Error("invert: expected positive modulus, got "+J);let q=p($,J),Q=J,G=l,z=h,U=h,X=l;while(q!==l){const V=Q/q,N=Q%q,L=G-U*V,j=z-X*V;Q=q,q=N,G=U,z=X,U=L,X=j}if(Q!==h)throw new Error("invert: does not exist");return p(G,J)}var F8=function($,J,q){if(!$.eql($.sqr(J),q))throw new Error("Cannot find square root")},O$=function($,J){const q=($.ORDER+h)/T$,Q=$.pow(J,q);return F8($,Q,J),Q},IQ=function($,J){const q=($.ORDER-B$)/x$,Q=$.mul(J,P0),G=$.pow(Q,q),z=$.mul(J,G),U=$.mul($.mul(z,P0),G),X=$.mul(z,$.sub(U,$.ONE));return F8($,X,J),X},kQ=function($){const J=O0($),q=R$($),Q=q(J,J.neg(J.ONE)),G=q(J,Q),z=q(J,J.neg(Q)),U=($+AQ)/H$;return(X,Z)=>{let V=X.pow(Z,U),N=X.mul(V,Q);const L=X.mul(V,G),j=X.mul(V,z),K=X.eql(X.sqr(N),Z),H=X.eql(X.sqr(L),Z);V=X.cmov(V,N,K),N=X.cmov(j,L,H);const A=X.eql(X.sqr(N),Z),E=X.cmov(V,N,A);return F8(X,E,Z),E}};function R$($){if($<C$)throw new Error("sqrt is not defined for small field");let J=$-h,q=0;while(J%P0===l)J/=P0,q++;let Q=P0;const G=O0($);while(V$(G,Q)===1)if(Q++>1000)throw new Error("Cannot find square root: probably non-prime P");if(q===1)return O$;let z=G.pow(Q,J);const U=(J+h)/P0;return function X(Z,V){if(Z.is0(V))return V;if(V$(Z,V)!==1)throw new Error("Cannot find square root");let N=q,L=Z.mul(Z.ONE,z),j=Z.pow(V,J),K=Z.pow(V,U);while(!Z.eql(j,Z.ONE)){if(Z.is0(j))return Z.ZERO;let H=1,A=Z.sqr(j);while(!Z.eql(A,Z.ONE))if(H++,A=Z.sqr(A),H===N)throw new Error("Cannot find square root");const E=h<<BigInt(N-H-1),v=Z.pow(L,E);N=H,L=Z.sqr(v),j=Z.mul(j,L),K=Z.mul(K,v)}return K}}function SQ($){if($%T$===C$)return O$;if($%x$===B$)return IQ;if($%H$===wQ)return kQ($);return R$($)}function h8($){const J={ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"},q=PQ.reduce((Q,G)=>{return Q[G]="function",Q},J);return n0($,q),$}function EQ($,J,q){if(q<l)throw new Error("invalid exponent, negatives unsupported");if(q===l)return $.ONE;if(q===h)return J;let Q=$.ONE,G=J;while(q>l){if(q&h)Q=$.mul(Q,G);G=$.sqr(G),q>>=h}return Q}function D8($,J,q=!1){const Q=new Array(J.length).fill(q?$.ZERO:void 0),G=J.reduce((U,X,Z)=>{if($.is0(X))return U;return Q[Z]=U,$.mul(U,X)},$.ONE),z=$.inv(G);return J.reduceRight((U,X,Z)=>{if($.is0(X))return U;return Q[Z]=$.mul(U,Q[Z]),$.mul(U,X)},z),Q}function V$($,J){const q=($.ORDER-h)/P0,Q=$.pow(J,q),G=$.eql(Q,$.ONE),z=$.eql(Q,$.ZERO),U=$.eql(Q,$.neg($.ONE));if(!G&&!z&&!U)throw new Error("invalid Legendre symbol result");return G?1:z?0:-1}function W8($,J){if(J!==void 0)d0(J);const q=J!==void 0?J:$.toString(2).length,Q=Math.ceil(q/8);return{nBitLength:q,nByteLength:Q}}function O0($,J,q=!1,Q={}){if($<=l)throw new Error("invalid field: expected ORDER > 0, got "+$);let G=void 0,z=void 0,U=!1,X=void 0;if(typeof J==="object"&&J!=null){if(Q.sqrt||q)throw new Error("cannot specify opts in two arguments");const j=J;if(j.BITS)G=j.BITS;if(j.sqrt)z=j.sqrt;if(typeof j.isLE==="boolean")q=j.isLE;if(typeof j.modFromBytes==="boolean")U=j.modFromBytes;X=j.allowedLengths}else{if(typeof J==="number")G=J;if(Q.sqrt)z=Q.sqrt}const{nBitLength:Z,nByteLength:V}=W8($,G);if(V>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let N;const L=Object.freeze({ORDER:$,isLE:q,BITS:Z,BYTES:V,MASK:H0(Z),ZERO:l,ONE:h,allowedLengths:X,create:(j)=>p(j,$),isValid:(j)=>{if(typeof j!=="bigint")throw new Error("invalid field element: expected bigint, got "+typeof j);return l<=j&&j<$},is0:(j)=>j===l,isValidNot0:(j)=>!L.is0(j)&&L.isValid(j),isOdd:(j)=>(j&h)===h,neg:(j)=>p(-j,$),eql:(j,K)=>j===K,sqr:(j)=>p(j*j,$),add:(j,K)=>p(j+K,$),sub:(j,K)=>p(j-K,$),mul:(j,K)=>p(j*K,$),pow:(j,K)=>EQ(L,j,K),div:(j,K)=>p(j*N$(K,$),$),sqrN:(j)=>j*j,addN:(j,K)=>j+K,subN:(j,K)=>j-K,mulN:(j,K)=>j*K,inv:(j)=>N$(j,$),sqrt:z||((j)=>{if(!N)N=SQ($);return N(L,j)}),toBytes:(j)=>q?u8(j,V):_0(j,V),fromBytes:(j,K=!0)=>{if(X){if(!X.includes(j.length)||j.length>V)throw new Error("Field.fromBytes: expected "+X+" bytes, got "+j.length);const A=new Uint8Array(V);A.set(j,q?0:A.length-j.length),j=A}if(j.length!==V)throw new Error("Field.fromBytes: expected "+V+" bytes, got "+j.length);let H=q?y8(j):M0(j);if(U)H=p(H,$);if(!K){if(!L.isValid(H))throw new Error("invalid field element: outside of range 0..ORDER")}return H},invertBatch:(j)=>D8(L,j),cmov:(j,K,H)=>H?K:j});return Object.freeze(L)}function L$($){if(typeof $!=="bigint")throw new Error("field order must be bigint");const J=$.toString(2).length;return Math.ceil(J/8)}function l8($){const J=L$($);return J+Math.ceil(J/2)}function N8($,J,q=!1){const Q=$.length,G=L$(J),z=l8(J);if(Q<16||Q<z||Q>1024)throw new Error("expected "+z+"-1024 bytes of input, got "+Q);const U=q?y8($):M0($),X=p(U,J-h)+h;return q?u8(X,G):_0(X,G)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var l=BigInt(0),h=BigInt(1),P0=BigInt(2),C$=BigInt(3),T$=BigInt(4),B$=BigInt(5),AQ=BigInt(7),x$=BigInt(8),wQ=BigInt(9),H$=BigInt(16);var PQ=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function s0($,J){const q=J.negate();return $?q:J}function V8($,J){const q=D8($.Fp,J.map((Q)=>Q.Z));return J.map((Q,G)=>$.fromAffine(Q.toAffine(q[G])))}var k$=function($,J){if(!Number.isSafeInteger($)||$<=0||$>J)throw new Error("invalid window size, expected [1.."+J+"], got W="+$)},c8=function($,J){k$($,J);const q=Math.ceil(J/$)+1,Q=2**($-1),G=2**$,z=H0($),U=BigInt($);return{windows:q,windowSize:Q,mask:z,maxNumber:G,shiftBy:U}},A$=function($,J,q){const{windowSize:Q,mask:G,maxNumber:z,shiftBy:U}=q;let X=Number($&G),Z=$>>U;if(X>Q)X-=z,Z+=E0;const V=J*Q,N=V+Math.abs(X)-1,L=X===0,j=X<0,K=J%2!==0;return{nextN:Z,offset:N,isZero:L,isNeg:j,isNegF:K,offsetF:V}},fQ=function($,J){if(!Array.isArray($))throw new Error("array expected");$.forEach((q,Q)=>{if(!(q instanceof J))throw new Error("invalid point at index "+Q)})},vQ=function($,J){if(!Array.isArray($))throw new Error("array of scalars expected");$.forEach((q,Q)=>{if(!J.isValid(q))throw new Error("invalid scalar at index "+Q)})},o8=function($){return S$.get($)||1},w$=function($){if($!==g0)throw new Error("invalid wNAF")};function P$($,J,q,Q){let G=J,z=$.ZERO,U=$.ZERO;while(q>g0||Q>g0){if(q&E0)z=z.add(G);if(Q&E0)U=U.add(G);G=G.double(),q>>=E0,Q>>=E0}return{p1:z,p2:U}}function E$($,J,q,Q){fQ(q,$),vQ(Q,J);const G=q.length,z=Q.length;if(G!==z)throw new Error("arrays of points and scalars must have equal length");const U=$.ZERO,X=M8(BigInt(G));let Z=1;if(X>12)Z=X-3;else if(X>4)Z=X-2;else if(X>0)Z=2;const V=H0(Z),N=new Array(Number(V)+1).fill(U),L=Math.floor((J.BITS-1)/Z)*Z;let j=U;for(let K=L;K>=0;K-=Z){N.fill(U);for(let A=0;A<z;A++){const E=Q[A],v=Number(E>>BigInt(K)&V);N[v]=N[v].add(q[A])}let H=U;for(let A=N.length-1,E=U;A>0;A--)E=E.add(N[A]),H=H.add(E);if(j=j.add(H),K!==0)for(let A=0;A<Z;A++)j=j.double()}return j}var I$=function($,J,q){if(J){if(J.ORDER!==$)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return h8(J),J}else return O0($,{isLE:q})};function f$($,J,q={},Q){if(Q===void 0)Q=$==="edwards";if(!J||typeof J!=="object")throw new Error(`expected valid ${$} CURVE object`);for(let Z of["p","n","h"]){const V=J[Z];if(!(typeof V==="bigint"&&V>g0))throw new Error(`CURVE.${Z} must be positive bigint`)}const G=I$(J.p,q.Fp,Q),z=I$(J.n,q.Fn,Q),X=["Gx","Gy","a",$==="weierstrass"?"b":"d"];for(let Z of X)if(!G.isValid(J[Z]))throw new Error(`CURVE.${Z} must be valid field element of CURVE.Fp`);return J=Object.freeze(Object.assign({},J)),{CURVE:J,Fp:G,Fn:z}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var g0=BigInt(0),E0=BigInt(1),d8=new WeakMap,S$=new WeakMap;class r8{constructor($,J){this.BASE=$.BASE,this.ZERO=$.ZERO,this.Fn=$.Fn,this.bits=J}_unsafeLadder($,J,q=this.ZERO){let Q=$;while(J>g0){if(J&E0)q=q.add(Q);Q=Q.double(),J>>=E0}return q}precomputeWindow($,J){const{windows:q,windowSize:Q}=c8(J,this.bits),G=[];let z=$,U=z;for(let X=0;X<q;X++){U=z,G.push(U);for(let Z=1;Z<Q;Z++)U=U.add(z),G.push(U);z=U.double()}return G}wNAF($,J,q){if(!this.Fn.isValid(q))throw new Error("invalid scalar");let Q=this.ZERO,G=this.BASE;const z=c8($,this.bits);for(let U=0;U<z.windows;U++){const{nextN:X,offset:Z,isZero:V,isNeg:N,isNegF:L,offsetF:j}=A$(q,U,z);if(q=X,V)G=G.add(s0(L,J[j]));else Q=Q.add(s0(N,J[Z]))}return w$(q),{p:Q,f:G}}wNAFUnsafe($,J,q,Q=this.ZERO){const G=c8($,this.bits);for(let z=0;z<G.windows;z++){if(q===g0)break;const{nextN:U,offset:X,isZero:Z,isNeg:V}=A$(q,z,G);if(q=U,Z)continue;else{const N=J[X];Q=Q.add(V?N.negate():N)}}return w$(q),Q}getPrecomputes($,J,q){let Q=d8.get(J);if(!Q){if(Q=this.precomputeWindow(J,$),$!==1){if(typeof q==="function")Q=q(Q);d8.set(J,Q)}}return Q}cached($,J,q){const Q=o8($);return this.wNAF(Q,this.getPrecomputes(Q,$,q),J)}unsafe($,J,q,Q){const G=o8($);if(G===1)return this._unsafeLadder($,J,Q);return this.wNAFUnsafe(G,this.getPrecomputes(G,$,q),J,Q)}createCache($,J){k$(J,this.bits),S$.set($,J),d8.delete($)}hasCache($){return o8($)!==1}}function bQ($,J,q){const[[Q,G],[z,U]]=J,X=v$(U*$,q),Z=v$(-G*$,q);let V=$-X*Q-Z*z,N=-X*G-Z*U;const L=V<W0,j=N<W0;if(L)V=-V;if(j)N=-N;const K=H0(Math.ceil(M8(q)/2))+y0;if(V<W0||V>=K||N<W0||N>=K)throw new Error("splitScalar (endomorphism): failed, k="+$);return{k1neg:L,k1:V,k2neg:j,k2:N}}var i8=function($){if(!["compact","recovered","der"].includes($))throw new Error('Signature format must be "compact", "recovered", or "der"');return $},p8=function($,J){const q={};for(let Q of Object.keys(J))q[Q]=$[Q]===void 0?J[Q]:$[Q];if(p0(q.lowS,"lowS"),p0(q.prehash,"prehash"),q.format!==void 0)i8(q.format);return q};function R0($,J){const{BYTES:q}=$;let Q;if(typeof J==="bigint")Q=J;else{let G=m("private key",J);try{Q=$.fromBytes(G)}catch(z){throw new Error(`invalid private key: expected ui8a of size ${q}, got ${typeof J}`)}}if(!$.isValidNot0(Q))throw new Error("invalid private key: out of range [1..N-1]");return Q}function gQ($,J={}){const q=f$("weierstrass",$,J),{Fp:Q,Fn:G}=q;let z=q.CURVE;const{h:U,n:X}=z;n0(J,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:Z}=J;if(Z){if(!Q.is0(z.a)||typeof Z.beta!=="bigint"||!Array.isArray(Z.basises))throw new Error('invalid endo: expected "beta": bigint and "basises": array')}const V=y$(Q,G);function N(){if(!Q.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function L(W,O,M){const{x:B,y:Y}=O.toAffine(),D=Q.toBytes(B);if(p0(M,"isCompressed"),M){N();const C=!Q.isOdd(Y);return o(g$(C),D)}else return o(Uint8Array.of(4),D,Q.toBytes(Y))}function j(W){x0(W,void 0,"Point");const{publicKey:O,publicKeyUncompressed:M}=V,B=W.length,Y=W[0],D=W.subarray(1);if(B===O&&(Y===2||Y===3)){const C=Q.fromBytes(D);if(!Q.isValid(C))throw new Error("bad point: is not on curve, wrong x");const x=A(C);let T;try{T=Q.sqrt(x)}catch(k){const w=k instanceof Error?": "+k.message:"";throw new Error("bad point: is not on curve, sqrt error"+w)}N();const R=Q.isOdd(T);if((Y&1)===1!==R)T=Q.neg(T);return{x:C,y:T}}else if(B===M&&Y===4){const C=Q.BYTES,x=Q.fromBytes(D.subarray(0,C)),T=Q.fromBytes(D.subarray(C,C*2));if(!E(x,T))throw new Error("bad point: is not on curve");return{x,y:T}}else throw new Error(`bad point: got length ${B}, expected compressed=${O} or uncompressed=${M}`)}const K=J.toBytes||L,H=J.fromBytes||j;function A(W){const O=Q.sqr(W),M=Q.mul(O,W);return Q.add(Q.add(M,Q.mul(W,z.a)),z.b)}function E(W,O){const M=Q.sqr(O),B=A(W);return Q.eql(M,B)}if(!E(z.Gx,z.Gy))throw new Error("bad curve params: generator point");const v=Q.mul(Q.pow(z.a,C8),_Q),q0=Q.mul(Q.sqr(z.b),BigInt(27));if(Q.is0(Q.add(v,q0)))throw new Error("bad curve params: a or b");function _(W,O,M=!1){if(!Q.isValid(O)||M&&Q.is0(O))throw new Error(`bad point coordinate ${W}`);return O}function n(W){if(!(W instanceof I))throw new Error("ProjectivePoint expected")}function c(W){if(!Z||!Z.basises)throw new Error("no endo");return bQ(W,Z.basises,G.ORDER)}const s=m8((W,O)=>{const{X:M,Y:B,Z:Y}=W;if(Q.eql(Y,Q.ONE))return{x:M,y:B};const D=W.is0();if(O==null)O=D?Q.ONE:Q.inv(Y);const C=Q.mul(M,O),x=Q.mul(B,O),T=Q.mul(Y,O);if(D)return{x:Q.ZERO,y:Q.ZERO};if(!Q.eql(T,Q.ONE))throw new Error("invZ was invalid");return{x:C,y:x}}),C0=m8((W)=>{if(W.is0()){if(J.allowInfinityPoint&&!Q.is0(W.Y))return;throw new Error("bad point: ZERO")}const{x:O,y:M}=W.toAffine();if(!Q.isValid(O)||!Q.isValid(M))throw new Error("bad point: x or y not field elements");if(!E(O,M))throw new Error("bad point: equation left != right");if(!W.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function G0(W,O,M,B,Y){return M=new I(Q.mul(M.X,W),M.Y,M.Z),O=s0(B,O),M=s0(Y,M),O.add(M)}class I{constructor(W,O,M){this.X=_("x",W),this.Y=_("y",O,!0),this.Z=_("z",M),Object.freeze(this)}static CURVE(){return z}static fromAffine(W){const{x:O,y:M}=W||{};if(!W||!Q.isValid(O)||!Q.isValid(M))throw new Error("invalid affine point");if(W instanceof I)throw new Error("projective point not allowed");if(Q.is0(O)&&Q.is0(M))return I.ZERO;return new I(O,M,Q.ONE)}static fromBytes(W){const O=I.fromAffine(H(x0(W,void 0,"point")));return O.assertValidity(),O}static fromHex(W){return I.fromBytes(m("pointHex",W))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(W=8,O=!0){if(S.createCache(this,W),!O)this.multiply(C8);return this}assertValidity(){C0(this)}hasEvenY(){const{y:W}=this.toAffine();if(!Q.isOdd)throw new Error("Field doesn't support isOdd");return!Q.isOdd(W)}equals(W){n(W);const{X:O,Y:M,Z:B}=this,{X:Y,Y:D,Z:C}=W,x=Q.eql(Q.mul(O,C),Q.mul(Y,B)),T=Q.eql(Q.mul(M,C),Q.mul(D,B));return x&&T}negate(){return new I(this.X,Q.neg(this.Y),this.Z)}double(){const{a:W,b:O}=z,M=Q.mul(O,C8),{X:B,Y,Z:D}=this;let{ZERO:C,ZERO:x,ZERO:T}=Q,R=Q.mul(B,B),g=Q.mul(Y,Y),k=Q.mul(D,D),w=Q.mul(B,Y);return w=Q.add(w,w),T=Q.mul(B,D),T=Q.add(T,T),C=Q.mul(W,T),x=Q.mul(M,k),x=Q.add(C,x),C=Q.sub(g,x),x=Q.add(g,x),x=Q.mul(C,x),C=Q.mul(w,C),T=Q.mul(M,T),k=Q.mul(W,k),w=Q.sub(R,k),w=Q.mul(W,w),w=Q.add(w,T),T=Q.add(R,R),R=Q.add(T,R),R=Q.add(R,k),R=Q.mul(R,w),x=Q.add(x,R),k=Q.mul(Y,D),k=Q.add(k,k),R=Q.mul(k,w),C=Q.sub(C,R),T=Q.mul(k,g),T=Q.add(T,T),T=Q.add(T,T),new I(C,x,T)}add(W){n(W);const{X:O,Y:M,Z:B}=this,{X:Y,Y:D,Z:C}=W;let{ZERO:x,ZERO:T,ZERO:R}=Q;const g=z.a,k=Q.mul(z.b,C8);let w=Q.mul(O,Y),P=Q.mul(M,D),f=Q.mul(B,C),b=Q.add(O,M),y=Q.add(Y,D);b=Q.mul(b,y),y=Q.add(w,P),b=Q.sub(b,y),y=Q.add(O,B);let u=Q.add(Y,C);return y=Q.mul(y,u),u=Q.add(w,f),y=Q.sub(y,u),u=Q.add(M,B),x=Q.add(D,C),u=Q.mul(u,x),x=Q.add(P,f),u=Q.sub(u,x),R=Q.mul(g,y),x=Q.mul(k,f),R=Q.add(x,R),x=Q.sub(P,R),R=Q.add(P,R),T=Q.mul(x,R),P=Q.add(w,w),P=Q.add(P,w),f=Q.mul(g,f),y=Q.mul(k,y),P=Q.add(P,f),f=Q.sub(w,f),f=Q.mul(g,f),y=Q.add(y,f),w=Q.mul(P,y),T=Q.add(T,w),w=Q.mul(u,y),x=Q.mul(b,x),x=Q.sub(x,w),w=Q.mul(b,P),R=Q.mul(u,R),R=Q.add(R,w),new I(x,T,R)}subtract(W){return this.add(W.negate())}is0(){return this.equals(I.ZERO)}multiply(W){const{endo:O}=J;if(!G.isValidNot0(W))throw new Error("invalid scalar: out of range");let M,B;const Y=(D)=>S.cached(this,D,(C)=>V8(I,C));if(O){const{k1neg:D,k1:C,k2neg:x,k2:T}=c(W),{p:R,f:g}=Y(C),{p:k,f:w}=Y(T);B=g.add(w),M=G0(O.beta,R,k,D,x)}else{const{p:D,f:C}=Y(W);M=D,B=C}return V8(I,[M,B])[0]}multiplyUnsafe(W){const{endo:O}=J,M=this;if(!G.isValid(W))throw new Error("invalid scalar: out of range");if(W===W0||M.is0())return I.ZERO;if(W===y0)return M;if(S.hasCache(this))return this.multiply(W);if(O){const{k1neg:B,k1:Y,k2neg:D,k2:C}=c(W),{p1:x,p2:T}=P$(I,M,Y,C);return G0(O.beta,x,T,B,D)}else return S.unsafe(M,W)}multiplyAndAddUnsafe(W,O,M){const B=this.multiplyUnsafe(O).add(W.multiplyUnsafe(M));return B.is0()?void 0:B}toAffine(W){return s(this,W)}isTorsionFree(){const{isTorsionFree:W}=J;if(U===y0)return!0;if(W)return W(I,this);return S.unsafe(this,X).is0()}clearCofactor(){const{clearCofactor:W}=J;if(U===y0)return this;if(W)return W(I,this);return this.multiplyUnsafe(U)}isSmallOrder(){return this.multiplyUnsafe(U).is0()}toBytes(W=!0){return p0(W,"isCompressed"),this.assertValidity(),K(I,this,W)}toHex(W=!0){return Z0(this.toBytes(W))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(W=!0){return this.toBytes(W)}_setWindowSize(W){this.precompute(W)}static normalizeZ(W){return V8(I,W)}static msm(W,O){return E$(I,G,W,O)}static fromPrivateKey(W){return I.BASE.multiply(R0(G,W))}}I.BASE=new I(z.Gx,z.Gy,Q.ONE),I.ZERO=new I(Q.ZERO,Q.ONE,Q.ZERO),I.Fp=Q,I.Fn=G;const Y0=G.BITS,S=new r8(I,J.endo?Math.ceil(Y0/2):Y0);return I.BASE.precompute(8),I}var g$=function($){return Uint8Array.of($?2:3)};var y$=function($,J){return{secretKey:J.BYTES,publicKey:1+$.BYTES,publicKeyUncompressed:1+2*$.BYTES,publicKeyHasPrefix:!0,signature:2*J.BYTES}};function yQ($,J={}){const{Fn:q}=$,Q=J.randomBytes||S0,G=Object.assign(y$($.Fp,q),{seed:l8(q.ORDER)});function z(K){try{return!!R0(q,K)}catch(H){return!1}}function U(K,H){const{publicKey:A,publicKeyUncompressed:E}=G;try{const v=K.length;if(H===!0&&v!==A)return!1;if(H===!1&&v!==E)return!1;return!!$.fromBytes(K)}catch(v){return!1}}function X(K=Q(G.seed)){return N8(x0(K,G.seed,"seed"),q.ORDER)}function Z(K,H=!0){return $.BASE.multiply(R0(q,K)).toBytes(H)}function V(K){const H=X(K);return{secretKey:H,publicKey:Z(H)}}function N(K){if(typeof K==="bigint")return!1;if(K instanceof $)return!0;const{secretKey:H,publicKey:A,publicKeyUncompressed:E}=G;if(q.allowedLengths||H===A)return;const v=m("key",K).length;return v===A||v===E}function L(K,H,A=!0){if(N(K)===!0)throw new Error("first arg must be private key");if(N(H)===!1)throw new Error("second arg must be public key");const E=R0(q,K);return $.fromHex(H).multiply(E).toBytes(A)}return Object.freeze({getPublicKey:Z,getSharedSecret:L,keygen:V,Point:$,utils:{isValidSecretKey:z,isValidPublicKey:U,randomSecretKey:X,isValidPrivateKey:z,randomPrivateKey:X,normPrivateKeyToScalar:(K)=>R0(q,K),precompute(K=8,H=$.BASE){return H.precompute(K,!1)}},lengths:G})}function uQ($,J,q={}){Y8(J),n0(q,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const Q=q.randomBytes||S0,G=q.hmac||((M,...B)=>v8(J,M,o(...B))),{Fp:z,Fn:U}=$,{ORDER:X,BITS:Z}=U,{keygen:V,getPublicKey:N,getSharedSecret:L,utils:j,lengths:K}=yQ($,q),H={prehash:!1,lowS:typeof q.lowS==="boolean"?q.lowS:!1,format:void 0,extraEntropy:!1},A="compact";function E(M){const B=X>>y0;return M>B}function v(M,B){if(!U.isValidNot0(B))throw new Error(`invalid signature ${M}: out of range 1..Point.Fn.ORDER`);return B}function q0(M,B){i8(B);const Y=K.signature,D=B==="compact"?Y:B==="recovered"?Y+1:void 0;return x0(M,D,`${B} signature`)}class _{constructor(M,B,Y){if(this.r=v("r",M),this.s=v("s",B),Y!=null)this.recovery=Y;Object.freeze(this)}static fromBytes(M,B=A){q0(M,B);let Y;if(B==="der"){const{r:T,s:R}=D0.toSig(x0(M));return new _(T,R)}if(B==="recovered")Y=M[0],B="compact",M=M.subarray(1);const D=U.BYTES,C=M.subarray(0,D),x=M.subarray(D,D*2);return new _(U.fromBytes(C),U.fromBytes(x),Y)}static fromHex(M,B){return this.fromBytes(k0(M),B)}addRecoveryBit(M){return new _(this.r,this.s,M)}recoverPublicKey(M){const B=z.ORDER,{r:Y,s:D,recovery:C}=this;if(C==null||![0,1,2,3].includes(C))throw new Error("recovery id invalid");if(X*_$<B&&C>1)throw new Error("recovery id is ambiguous for h>1 curve");const T=C===2||C===3?Y+X:Y;if(!z.isValid(T))throw new Error("recovery id 2 or 3 invalid");const R=z.toBytes(T),g=$.fromBytes(o(g$((C&1)===0),R)),k=U.inv(T),w=c(m("msgHash",M)),P=U.create(-w*k),f=U.create(D*k),b=$.BASE.multiplyUnsafe(P).add(g.multiplyUnsafe(f));if(b.is0())throw new Error("point at infinify");return b.assertValidity(),b}hasHighS(){return E(this.s)}toBytes(M=A){if(i8(M),M==="der")return k0(D0.hexFromSig(this));const B=U.toBytes(this.r),Y=U.toBytes(this.s);if(M==="recovered"){if(this.recovery==null)throw new Error("recovery bit must be present");return o(Uint8Array.of(this.recovery),B,Y)}return o(B,Y)}toHex(M){return Z0(this.toBytes(M))}assertValidity(){}static fromCompact(M){return _.fromBytes(m("sig",M),"compact")}static fromDER(M){return _.fromBytes(m("sig",M),"der")}normalizeS(){return this.hasHighS()?new _(this.r,U.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return Z0(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return Z0(this.toBytes("compact"))}}const n=q.bits2int||function M(B){if(B.length>8192)throw new Error("input is too large");const Y=M0(B),D=B.length*8-Z;return D>0?Y>>BigInt(D):Y},c=q.bits2int_modN||function M(B){return U.create(n(B))},s=H0(Z);function C0(M){return D$("num < 2^"+Z,M,W0,s),U.toBytes(M)}function G0(M,B){return x0(M,void 0,"message"),B?x0(J(M),void 0,"prehashed message"):M}function I(M,B,Y){if(["recovered","canonical"].some((f)=>(f in Y)))throw new Error("sign() legacy options not supported");const{lowS:D,prehash:C,extraEntropy:x}=p8(Y,H);M=G0(M,C);const T=c(M),R=R0(U,B),g=[C0(R),C0(T)];if(x!=null&&x!==!1){const f=x===!0?Q(K.secretKey):x;g.push(m("extraEntropy",f))}const k=o(...g),w=T;function P(f){const b=n(f);if(!U.isValidNot0(b))return;const y=U.inv(b),u=$.BASE.multiply(b).toAffine(),F=U.create(u.x);if(F===W0)return;const t=U.create(y*U.create(w+F*R));if(t===W0)return;let z0=(u.x===F?0:2)|Number(u.y&y0),r=t;if(D&&E(t))r=U.neg(t),z0^=1;return new _(F,r,z0)}return{seed:k,k2sig:P}}function Y0(M,B,Y={}){M=m("message",M);const{seed:D,k2sig:C}=I(M,B,Y);return W$(J.outputLen,U.BYTES,G)(D,C)}function S(M){let B=void 0;const Y=typeof M==="string"||w0(M),D=!Y&&M!==null&&typeof M==="object"&&typeof M.r==="bigint"&&typeof M.s==="bigint";if(!Y&&!D)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(D)B=new _(M.r,M.s);else if(Y){try{B=_.fromBytes(m("sig",M),"der")}catch(C){if(!(C instanceof D0.Err))throw C}if(!B)try{B=_.fromBytes(m("sig",M),"compact")}catch(C){return!1}}if(!B)return!1;return B}function W(M,B,Y,D={}){const{lowS:C,prehash:x,format:T}=p8(D,H);if(Y=m("publicKey",Y),B=G0(m("message",B),x),("strict"in D))throw new Error("options.strict was renamed to lowS");const R=T===void 0?S(M):_.fromBytes(m("sig",M),T);if(R===!1)return!1;try{const g=$.fromBytes(Y);if(C&&R.hasHighS())return!1;const{r:k,s:w}=R,P=c(B),f=U.inv(w),b=U.create(P*f),y=U.create(k*f),u=$.BASE.multiplyUnsafe(b).add(g.multiplyUnsafe(y));if(u.is0())return!1;return U.create(u.x)===k}catch(g){return!1}}function O(M,B,Y={}){const{prehash:D}=p8(Y,H);return B=G0(B,D),_.fromBytes(M,"recovered").recoverPublicKey(B).toBytes()}return Object.freeze({keygen:V,getPublicKey:N,getSharedSecret:L,utils:j,lengths:K,Point:$,sign:Y0,verify:W,recoverPublicKey:O,Signature:_,hash:J})}var mQ=function($){const J={a:$.a,b:$.b,p:$.Fp.ORDER,n:$.n,h:$.h,Gx:$.Gx,Gy:$.Gy},q=$.Fp;let Q=$.allowedPrivateKeyLengths?Array.from(new Set($.allowedPrivateKeyLengths.map((U)=>Math.ceil(U/2)))):void 0;const G=O0(J.n,{BITS:$.nBitLength,allowedLengths:Q,modFromBytes:$.wrapPrivateKey}),z={Fp:q,Fn:G,allowInfinityPoint:$.allowInfinityPoint,endo:$.endo,isTorsionFree:$.isTorsionFree,clearCofactor:$.clearCofactor,fromBytes:$.fromBytes,toBytes:$.toBytes};return{CURVE:J,curveOpts:z}},FQ=function($){const{CURVE:J,curveOpts:q}=mQ($),Q={hmac:$.hmac,randomBytes:$.randomBytes,lowS:$.lowS,bits2int:$.bits2int,bits2int_modN:$.bits2int_modN};return{CURVE:J,curveOpts:q,hash:$.hash,ecdsaOpts:Q}};var hQ=function($,J){const q=J.Point;return Object.assign({},J,{ProjectivePoint:q,CURVE:Object.assign({},$,W8(q.Fn.ORDER,q.Fn.BITS))})};function u$($){const{CURVE:J,curveOpts:q,hash:Q,ecdsaOpts:G}=FQ($),z=gQ(J,q),U=uQ(z,Q,G);return hQ($,U)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var v$=($,J)=>($+($>=0?J:-J)/_$)/J;class b$ extends Error{constructor($=""){super($)}}var D0={Err:b$,_tlv:{encode:($,J)=>{const{Err:q}=D0;if($<0||$>256)throw new q("tlv.encode: wrong tag");if(J.length&1)throw new q("tlv.encode: unpadded data");const Q=J.length/2,G=i0(Q);if(G.length/2&128)throw new q("tlv.encode: long form length too big");const z=Q>127?i0(G.length/2|128):"";return i0($)+z+G+J},decode($,J){const{Err:q}=D0;let Q=0;if($<0||$>256)throw new q("tlv.encode: wrong tag");if(J.length<2||J[Q++]!==$)throw new q("tlv.decode: wrong tlv");const G=J[Q++],z=!!(G&128);let U=0;if(!z)U=G;else{const Z=G&127;if(!Z)throw new q("tlv.decode(long): indefinite length not supported");if(Z>4)throw new q("tlv.decode(long): byte length is too big");const V=J.subarray(Q,Q+Z);if(V.length!==Z)throw new q("tlv.decode: length bytes not complete");if(V[0]===0)throw new q("tlv.decode(long): zero leftmost byte");for(let N of V)U=U<<8|N;if(Q+=Z,U<128)throw new q("tlv.decode(long): not minimal encoding")}const X=J.subarray(Q,Q+U);if(X.length!==U)throw new q("tlv.decode: wrong value length");return{v:X,l:J.subarray(Q+U)}}},_int:{encode($){const{Err:J}=D0;if($<W0)throw new J("integer: negative integers are not allowed");let q=i0($);if(Number.parseInt(q[0],16)&8)q="00"+q;if(q.length&1)throw new J("unexpected DER parsing assertion: unpadded hex");return q},decode($){const{Err:J}=D0;if($[0]&128)throw new J("invalid signature integer: negative");if($[0]===0&&!($[1]&128))throw new J("invalid signature integer: unnecessary leading zero");return M0($)}},toSig($){const{Err:J,_int:q,_tlv:Q}=D0,G=m("signature",$),{v:z,l:U}=Q.decode(48,G);if(U.length)throw new J("invalid signature: left bytes after parsing");const{v:X,l:Z}=Q.decode(2,z),{v:V,l:N}=Q.decode(2,Z);if(N.length)throw new J("invalid signature: left bytes after parsing");return{r:q.decode(X),s:q.decode(V)}},hexFromSig($){const{_tlv:J,_int:q}=D0,Q=J.encode(2,q.encode($.r)),G=J.encode(2,q.encode($.s)),z=Q+G;return J.encode(48,z)}},W0=BigInt(0),y0=BigInt(1),_$=BigInt(2),C8=BigInt(3),_Q=BigInt(4);function m$($,J){const q=(Q)=>u$({...$,hash:Q});return{...q(J),create:q}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var dQ=function($){const J=u0.p,q=BigInt(3),Q=BigInt(6),G=BigInt(11),z=BigInt(22),U=BigInt(23),X=BigInt(44),Z=BigInt(88),V=$*$*$%J,N=V*V*$%J,L=i(N,q,J)*N%J,j=i(L,q,J)*N%J,K=i(j,a8,J)*V%J,H=i(K,G,J)*K%J,A=i(H,z,J)*H%J,E=i(A,X,J)*A%J,v=i(E,Z,J)*E%J,q0=i(v,X,J)*A%J,_=i(q0,q,J)*N%J,n=i(_,U,J)*H%J,c=i(n,Q,J)*V%J,s=i(c,a8,J);if(!T8.eql(T8.sqr(s),$))throw new Error("Cannot find square root");return s},B8=function($,...J){let q=h$[$];if(q===void 0){const Q=K8(Z8($));q=o(Q,Q),h$[$]=q}return K8(o(q,...J))},n8=function($){const{Fn:J,BASE:q}=m0,Q=R0(J,$),G=q.multiply(Q);return{scalar:t8(G.y)?Q:J.neg(Q),bytes:s8(G)}},d$=function($){const J=T8;if(!J.isValidNot0($))throw new Error("invalid x: Fail if x \u2265 p");const q=J.create($*$),Q=J.create(q*$+BigInt(7));let G=J.sqrt(Q);if(!t8(G))G=J.neg(G);const z=m0.fromAffine({x:$,y:G});return z.assertValidity(),z},o$=function(...$){return m0.Fn.create(t0(B8("BIP0340/challenge",...$)))},l$=function($){return n8($).bytes},oQ=function($,J,q=S0(32)){const{Fn:Q}=m0,G=m("message",$),{bytes:z,scalar:U}=n8(J),X=m("auxRand",q,32),Z=Q.toBytes(U^t0(B8("BIP0340/aux",X))),V=B8("BIP0340/nonce",Z,z,G),{bytes:N,scalar:L}=n8(V),j=o$(N,z,G),K=new Uint8Array(64);if(K.set(N,0),K.set(Q.toBytes(Q.create(L+j*U)),32),!r$(K,G,z))throw new Error("sign: Invalid signature produced");return K},r$=function($,J,q){const{Fn:Q,BASE:G}=m0,z=m("signature",$,64),U=m("message",J),X=m("publicKey",q,32);try{const Z=d$(t0(X)),V=t0(z.subarray(0,32));if(!a0(V,F$,u0.p))return!1;const N=t0(z.subarray(32,64));if(!a0(N,F$,u0.n))return!1;const L=o$(Q.toBytes(V),s8(Z),U),j=G.multiplyUnsafe(N).add(Z.multiplyUnsafe(Q.neg(L))),{x:K,y:H}=j.toAffine();if(j.is0()||!t8(H)||K!==V)return!1;return!0}catch(Z){return!1}};/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var u0={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},lQ={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},cQ=BigInt(0),F$=BigInt(1),a8=BigInt(2),T8=O0(u0.p,{sqrt:dQ}),c$=m$({...u0,Fp:T8,lowS:!0,endo:lQ},K8),h$={},s8=($)=>$.toBytes(!0).slice(1),m0=(()=>c$.Point)(),t8=($)=>$%a8===cQ,t0=M0,x8=(()=>{const q=(G=S0(48))=>{return N8(G,u0.n)};c$.utils.randomSecretKey;function Q(G){const z=q(G);return{secretKey:z,publicKey:l$(z)}}return{keygen:Q,getPublicKey:l$,sign:oQ,verify:r$,Point:m0,utils:{randomSecretKey:q,randomPrivateKey:q,taggedHash:B8,lift_x:d$,pointToBytes:s8,numberToBytesBE:_0,bytesToNumberBE:M0,mod:p},lengths:{secretKey:32,publicKey:32,publicKeyHasPrefix:!1,signature:64,seed:48}}})();var rQ=new TextEncoder,pQ=new TextDecoder,j0=($)=>rQ.encode($),f0=($)=>pQ.decode($),H8=($)=>Array.from($,(J)=>J.toString(16).padStart(2,"0")).join(""),e=JSON.stringify,v0=JSON.parse,O8=($,J=Number.MAX_SAFE_INTEGER)=>$.split("").reduce((q,Q)=>q+Q.charCodeAt(0),0)%J;var e8="AES-GCM",iQ={},p$="$",i$=",",aQ=($)=>{const J=new Uint8Array($);let Q="";for(let G=0;G<J.length;G+=32768)Q+=String.fromCharCode(...J.subarray(G,G+32768));return btoa(Q)},nQ=($)=>Uint8Array.from(atob($),(J)=>J.charCodeAt(0)).buffer,e0=($)=>iQ[$]??=crypto.subtle.digest("SHA-1",j0($)).then((J)=>{const q=new Uint8Array(J);let Q="";for(let G of q)Q+=G.toString(36);return Q}),a$=async($,J,q)=>{const Q=await crypto.subtle.digest("SHA-256",j0(`${$}:${J}:${q}`));return crypto.subtle.importKey("raw",Q,{name:e8},!1,["encrypt","decrypt"])},n$=async($,J)=>{const q=crypto.getRandomValues(new Uint8Array(12)),Q=await $,G=await crypto.subtle.encrypt({name:e8,iv:q},Q,j0(J));return`${q.join(i$)}${p$}${aQ(G)}`},s$=async($,J)=>{const[q,Q]=J.split(p$);if(!q||!Q)throw new Error("Invalid encrypted payload format");const G=Uint8Array.from(q.split(i$),Number),z=await $,U=await crypto.subtle.decrypt({name:e8,iv:G},z,nQ(Q));return f0(U)};var a="GenosRTC",F0=($,J)=>Array.from({length:$},J);var $8=($)=>Array.from(crypto.getRandomValues(new Uint8Array($)),(J)=>"0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz"[J%"0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz".length]).join(""),N0=$8(20),V0=Promise.all.bind(Promise),t$=typeof window!=="undefined",{entries:e$,fromEntries:R8,keys:J1}=Object,$Q=()=>{},J0=($)=>new Error(`GenosRTC: ${$}`),Q8=(...$)=>$.join("@"),QQ=($,J)=>{const q=[...$];let Q=q.length;const G=()=>{const z=Math.sin(J++)*1e4;return z-Math.floor(z)};while(Q){const z=Math.floor(G()*Q--);[q[Q],q[z]]=[q[z],q[Q]]}return q};var sQ=5000,JQ="icegatheringstatechange",qQ="offer",tQ="answer",eQ=[...F0(3,($,J)=>`stun:stun${J||""}.l.google.com:19302`),"stun:stun.cloudflare.com:3478"].map(($)=>({urls:$})),L8=($,{rtcConfig:J,rtcPolyfill:q,turnConfig:Q})=>{const G=new(q||RTCPeerConnection)({iceServers:[...eQ,...Q||[]],...J}),z={};let U=!1,X=!1,Z;const V=(j)=>Object.assign(j,{binaryType:"arraybuffer",bufferedAmountLowThreshold:65535,onmessage:(K)=>z.data?.(K.data),onopen:()=>z.connect?.(),onclose:()=>z.close?.(),onerror:(K)=>!K?.error?.message?.includes("User-Initiated Abort")&&z.error?.(K)}),N=()=>Promise.race([new Promise((j)=>{const K=()=>{if(G.iceGatheringState==="complete")G.removeEventListener(JQ,K),j()};G.addEventListener(JQ,K),K()}),new Promise((j)=>setTimeout(j,sQ))]).then(()=>({type:G.localDescription.type,sdp:G.localDescription.sdp.replace(/a=ice-options:trickle\s\n/g,"")}));if($?V(Z=G.createDataChannel("data")):G.ondatachannel=({channel:j})=>V(Z=j),G.onnegotiationneeded=async()=>{try{U=!0,await G.setLocalDescription(),z.signal?.(await N())}catch(j){z.error?.(j)}finally{U=!1}},G.onconnectionstatechange=()=>{if(["disconnected","failed","closed"].includes(G.connectionState))z.close?.()},G.ontrack=(j)=>{z.track?.(j.track,j.streams[0]),z.stream?.(j.streams[0])},G.onremovestream=(j)=>z.stream?.(j.stream),$&&!G.canTrickleIceCandidates)G.onnegotiationneeded();const L=()=>G.getSenders();return{created:Date.now(),connection:G,get channel(){return Z},get isDead(){return G.connectionState==="closed"},async signal(j){if(Z?.readyState==="open"&&!j.sdp?.includes("a=rtpmap"))return;try{if(j.type===qQ){if(U||G.signalingState!=="stable"&&!X){if($)return;await V0([G.setLocalDescription({type:"rollback"}),G.setRemoteDescription(j)])}else await G.setRemoteDescription(j);await G.setLocalDescription();const K=await N();return z.signal?.(K),K}if(j.type===tQ){X=!0;try{await G.setRemoteDescription(j)}finally{X=!1}}}catch(K){z.error?.(K)}},sendData:(j)=>Z.send(j),destroy:()=>{Z?.close(),G.close(),U=X=!1},setHandlers:(j)=>Object.assign(z,j),offerPromise:$?new Promise((j)=>z.signal=(K)=>K.type===qQ&&j(K)):Promise.resolve(),addStream:(j)=>j.getTracks().forEach((K)=>G.addTrack(K,j)),removeStream:(j)=>L().filter((K)=>j.getTracks().includes(K.track)).forEach((K)=>G.removeTrack(K)),addTrack:(j,K)=>G.addTrack(j,K),removeTrack:(j)=>{const K=L().find((H)=>H.track===j);if(K)G.removeTrack(K)},replaceTrack:(j,K)=>L().find((H)=>H.track===j)?.replaceTrack(K)}};var $J=Object.getPrototypeOf(Uint8Array),w8=12,GQ=0,I8=GQ+w8,k8=I8+1,q8=k8+1,G8=q8+1,J8=16384-G8,A8=255,$$="bufferedamountlow",h0=($)=>`@_${$}`,Q$=100,QJ=3,JJ=200,zQ=($,J,q)=>{const Q=new Map,G=new Map,z=new Map,U={},X={},Z={},V={},N=new Map,L=(Y,D)=>{if(!N.has(Y))N.set(Y,new Set);N.get(Y).add(D)},j=(Y,D)=>N.get(Y)?.delete(D),K=(Y,...D)=>N.get(Y)?.forEach((C)=>C(...D)),H=(Y,D)=>{const C=Y?Array.isArray(Y)?Y:[Y]:Q.keys();return Array.from(C,(x)=>{const T=Q.get(x);if(!T)return console.warn(`${a}: no peer with id ${x}`),null;return D(x,T)}).filter(Boolean)},A=(Y)=>{if(!Q.has(Y))return;Q.delete(Y),delete U[Y],delete X[Y],delete Z[Y],delete V[Y],K("peer:leave",Y),J(Y)},E=(Y)=>new Promise((D,C)=>{let x=setTimeout(()=>{Y.removeEventListener($$,T),C(new Error(`${a}: bufferLow timeout`))},5000);function T(){clearTimeout(x),Y.removeEventListener($$,T),D()}Y.addEventListener($$,T)}),v=(Y)=>{if(z.has(Y))return z.get(Y);if(!Y)throw J0("action type is required");const D=j0(Y);if(D.byteLength>w8)throw J0(`\u274C "${Y}" exceeds ${w8} bytes. Use a shorter name.`);const C=new Uint8Array(w8).map((P,f)=>D[f]||0);let x=0;const T=new Map([["message",new Set],["progress",new Set]]),R=(P,f)=>T.get(P)?.add(f),g=(P,f)=>T.get(P)?.delete(f),k=async(P,f,b,y)=>{if(b&&typeof b!=="object")throw J0("meta must be object");if(P===void 0)throw J0("data cannot be undefined");const u=P instanceof Blob,F=u||P instanceof ArrayBuffer||P instanceof $J,t=typeof P!=="string";if(b&&!F)throw J0("meta only allowed with binary");const z0=F?new Uint8Array(u?await P.arrayBuffer():P):j0(t?e(P):P),r=b?j0(e(b)):null,d=Math.ceil(z0.byteLength/J8)+(b?1:0)||1;if(d>Q$)throw J0(`Message too large, exceeds max chunks ${Q$}`);const G$=F0(d,(U8,U0)=>{const c0=U0===d-1,L0=b&&U0===0,j8=L0?r:z0.subarray(b?(U0-1)*J8:U0*J8,b?U0*J8:(U0+1)*J8),T0=new Uint8Array(G8+j8.byteLength);return T0.set(C),T0.set([x],I8),T0.set([c0|L0<<1|F<<2|t<<3],k8),T0.set([Math.round((U0+1)/d*A8)],q8),T0.set(j8,G8),T0});return x=x+1&A8,V0(H(f,async(U8,U0)=>{const{channel:c0}=U0;for(let L0=0;L0<d;L0++){let j8=0;while(c0.bufferedAmount>c0.bufferedAmountLowThreshold){if(j8++>QJ)throw J0(`${a}: send buffer full, max retries reached for peer ${U8}`);try{await E(c0)}catch(T0){console.warn(T0.message),await new Promise((HQ)=>setTimeout(HQ,JJ))}}if(!Q.has(U8))break;U0.sendData(G$[L0]),y?.(G$[L0][q8]/A8,U8,b)}}))};G.set(Y,{listeners:T,send:k});const w={send:k,on:R,off:g};return z.set(Y,w),w},q0=(Y,D)=>{try{const C=new Uint8Array(D),x=f0(C.subarray(GQ,I8)).replace(/ /g,"");if(!G.has(x))return console.warn(`${a}: unregistered type (${x})`);const[T]=C.subarray(I8,k8),[R]=C.subarray(k8,q8),[g]=C.subarray(q8,G8),k=C.subarray(G8),w=Boolean(R&1),P=Boolean(R&2),f=Boolean(R&4),b=Boolean(R&8),y=G.get(x),u=(U[Y]||={})[x]||={};if(u[T]?.chunks?.length>Q$){console.warn(`${a}: peer ${Y} sent too many chunks for nonce ${T}, ignoring.`);return}const F=u[T]||={chunks:[]};if(P)try{F.meta=v0(f0(k))}catch{console.warn(`${a}: failed to parse meta from peer ${Y} for type ${x}`);return}else F.chunks.push(k);if(y.listeners.get("progress").forEach((r)=>{try{r(g/A8,Y,F.meta)}catch(d){console.error(d)}}),!w)return;const t=new Uint8Array(F.chunks.reduce((r,d)=>r+d.byteLength,0));F.chunks.reduce((r,d)=>(t.set(d,r),r+d.byteLength),0),delete u[T];let z0;if(f)z0=t;else if(b)try{z0=v0(f0(t))}catch{console.warn(`${a}: failed to parse JSON message data from peer ${Y} for type ${x}`);return}else z0=f0(t);y.listeners.get("message").forEach((r)=>{try{r(z0,Y,F.meta)}catch(d){console.error(d)}})}catch(C){console.error(`${a}: error handling data from peer ${Y}:`,C)}},_=async()=>{try{await M(""),await new Promise((Y)=>setTimeout(Y,99))}catch(Y){console.warn(`${a}: error sending leave`,Y)}for(let[Y,D]of Q){try{D.destroy()}catch{}Q.delete(Y)}q()},{send:n,on:c}=v(h0("ping")),{send:s,on:C0}=v(h0("pong")),{send:G0,on:I}=v(h0("signal")),{send:Y0,on:S}=v(h0("stream")),{send:W,on:O}=v(h0("track")),{send:M,on:B}=v(h0("leave"));if($((Y,D)=>{if(Q.has(D))return;Q.set(D,Y),Y.setHandlers({data:(C)=>q0(D,C),stream:(C)=>{K("stream:add",C,D,Z[D]),delete Z[D]},track:(C,x)=>{K("track:add",C,x,D,V[D]),delete V[D]},signal:(C)=>G0(C,D),close:()=>A(D),error:(C)=>{console.error(`${a}: peer error for ${D}`,C),A(D)}}),K("peer:join",D)}),c("message",(Y,D)=>s("",D)),C0("message",(Y,D)=>{X[D]?.(),delete X[D]}),I("message",(Y,D)=>Q.get(D)?.signal(Y)),S("message",(Y,D)=>Z[D]=Y),O("message",(Y,D)=>V[D]=Y),B("message",(Y,D)=>A(D)),t$)addEventListener("beforeunload",_);return{on:L,off:j,channel:v,leave:_,ping:async(Y)=>{if(!Y)throw J0("ping() requires target peer ID");const D=Date.now();return n("",Y),await new Promise((C)=>X[Y]=C),Date.now()-D},getPeers:()=>R8(Array.from(Q,([Y,D])=>[Y,D.connection])),addStream:(Y,D,C)=>H(D,async(x,T)=>{if(C)await Y0(C,x);T.addStream(Y)}),removeStream:(Y,D)=>H(D,(C,x)=>x.removeStream(Y)),addTrack:(Y,D,C,x)=>H(C,async(T,R)=>{if(x)await W(x,T);R.addTrack(Y,D)}),removeTrack:(Y,D)=>H(D,(C,x)=>x.removeTrack(Y)),replaceTrack:(Y,D,C,x)=>H(C,async(T,R)=>{if(x)await W(x,T);R.replaceTrack(Y,D)})}};var qJ=20,GJ=5333,UQ=57333,jQ=({init:$,subscribe:J,announce:q})=>{const Q={};let G=!1,z,U;return(X,Z,V)=>{const{appId:N}=X;if(Q[N]?.[Z])return Q[N][Z];if(!X||!Z||!N&&!X.firebaseApp)throw J0(!X?"config required":!Z?"roomId required":"appId missing");let L=$Q;if(!G){const S=$(X);U=F0(qJ,()=>L8(!0,X)),z=Array.isArray(S)?S:[S];const W=setInterval(()=>{U=U.filter((O)=>{const M=Date.now()-O.created<UQ;if(!M)O.destroy();return M})},UQ);Q.offerCleanupTimer||=W,G=!0}const j={},K={},H=Q8(a,N,Z),A=e0(H),E=e0(Q8(H,N0)),v=a$(X.password||"",N,Z),q0=(S)=>async(W)=>({type:W.type,sdp:await S(v,W.sdp)}),_=q0(s$),n=q0(n$),c=(S,W)=>{if(K[W]===S)return;K[W]?.destroy(),K[W]=S,L(S,W),j[W]?.forEach((O)=>O!==S&&O.destroy()),delete j[W]},s=(S,W)=>{if(K[W]===S)delete K[W]},C0=(S)=>async(W,O,M)=>{const[B,Y]=await V0([A,E]);if(W!==B&&W!==Y)return;const{peerId:D,offer:C,answer:x}=typeof O==="string"?v0(O):O;if(D===N0||K[D])return;if(C){if(j[D]?.[S]&&N0>D)return;const T=L8(!1,X);T.setHandlers({connect:()=>c(T,D),close:()=>s(T,D)});try{const R=await _(C);if(T.isDead)return;const[g,k]=await V0([e0(Q8(H,D)),T.signal(R).then(n)]);M(g,e({peerId:N0,answer:k}))}catch{V?.({error:"decryption failed (offer)",appId:N,peerId:D,roomId:Z})}}else if(x){const T=j[D]?.[S];if(!T||T.isDead)return;T.setHandlers({connect:()=>c(T,D),close:()=>s(T,D)});try{T.signal(await _(x))}catch{V?.({error:"decryption failed (answer)",appId:N,peerId:D,roomId:Z})}}else{if(j[D]?.[S])return;const T=U.pop()||L8(!0,X),[R,{offer:g}]=await V0([e0(Q8(H,D)),T.offerPromise.then(n).then((k)=>({offer:k}))]);j[D]||=[],j[D][S]=T,T.setHandlers({connect:()=>c(T,D),close:()=>s(T,D)}),M(R,e({peerId:N0,offer:g,peer:T}))}},G0=V0(z.map(async(S,W)=>J(await S,await A,await E,C0(W)))),I=[];G0.then((S)=>{z.forEach((W,O)=>{const M=async()=>{const B=await q(await W,await A,await E);I[O]=setTimeout(M,typeof B==="number"?B:GJ)};M()}),Q[N][Z].onCleanup=()=>{if(delete Q[N][Z],I.forEach(clearTimeout),S.forEach((W)=>W()),Object.keys(Q).length===0)clearInterval(Q.offerCleanupTimer),delete Q.offerCleanupTimer}}),Q[N]||={};const Y0=zQ((S)=>L=S,(S)=>delete K[S],()=>Y0.onCleanup?.());return Q[N][Z]=Y0}};var YQ=3333,S8={},XQ={},ZQ=($,J)=>{const q={};let Q=null;const G=()=>{if(Q)clearTimeout(Q),Q=null;const z=new WebSocket($);z.onclose=()=>{S8[$]??=YQ,Q=setTimeout(G,S8[$]),S8[$]*=2},z.onmessage=(U)=>J(U.data),q.socket=z,q.url=z.url,q.ready=new Promise((U)=>{z.onopen=()=>{S8[$]=YQ,U(q)}}),q.send=(U)=>{if(z.readyState===1)z.send(U)}};return q.forceReconnect=G,G(),XQ[$]=q,q};if(typeof window!=="undefined"){const $=()=>{console.info("\u26A1 [GenosRTC] Network event detected. Forcing reconnection\u2026"),Object.values(XQ).forEach((J)=>{if(J.socket&&J.socket.readyState!==WebSocket.OPEN&&J.socket.readyState!==WebSocket.CONNECTING)J.forceReconnect()})};window.addEventListener("online",()=>{console.info("\u2705 Reconnected to the network."),$()}),window.addEventListener("offline",async()=>{console.info("\u274C Disconnected from the network.")}),document.addEventListener("visibilitychange",()=>{if(document.visibilityState==="visible")$()})}var KQ=($)=>()=>R8(e$($).map(([J,q])=>[J,q.socket])),MQ=($,J,q,Q)=>($.relayUrls??(Q?QQ(J,O8($.appId)):J)).slice(0,$.relayUrls?.length??$.relayRedundancy??q);var l0={},zJ=5,VQ="x",CQ="EVENT",UJ=/pow:\s*(\d+)\s*bits needed\.?/i,J$=new Set,TQ=x8.utils.randomSecretKey(),jJ=H8(x8.getPublicKey(TQ)),q$={},z8={},YJ={},BQ=()=>Math.floor(Date.now()/1000),xQ=($)=>YJ[$]??=O8($,1e4)+20000,P8=($)=>$.replace(/\/$/,""),XJ=["wss://black.nostrcity.club","wss://eu.purplerelay.com","wss://ftp.halifax.rwth-aachen.de/nostr","wss://nostr.cool110.xyz","wss://nostr.data.haus","wss://nostr.mom","wss://nostr.oxtr.dev","wss://nostr.sathoarder.com","wss://nostr.vulpem.com","wss://relay.agorist.space","wss://relay.binaryrobot.com","wss://relay.fountain.fm","wss://relay.mostro.network","wss://relay.nostraddress.com","wss://relay.nostrdice.com","wss://relay.nostromo.social","wss://relay.oldenburg.cool","wss://relay.snort.social","wss://relay.verified-nostr.com","wss://sendit.nosflare.com","wss://yabu.me/v2","wss://relay.damus.io"],ZJ=($,J)=>{const[q,Q,G,z]=v0(J);if(q===CQ)return z8[Q]?.(q$[Q],G.content);if(q==="NOTICE"||q==="OK"&&!G){if(+((q==="NOTICE"?Q:z).match(UJ)?.[1]??0)>0){const X=P8($);J$.add(X),l0[X]?.close?.(),delete l0[X]}}},KJ=($)=>{const J=P8($);if(l0[J])return l0[J];const q=ZQ(J,(Q)=>ZJ(J,Q));return l0[J]=q},DQ=async($,J)=>{const q={kind:xQ($),content:J,pubkey:jJ,created_at:BQ(),tags:[[VQ,$]]},Q=j0(e([0,q.pubkey,q.created_at,q.kind,q.tags,q.content])),G=new Uint8Array(await crypto.subtle.digest("SHA-256",Q)),z=x8.sign(G,TQ);return e([CQ,{...q,id:H8(G),sig:H8(z)}])},WQ=($,J)=>{return q$[$]=J,e(["REQ",$,{kinds:[xQ(J)],since:BQ(),["#"+VQ]:[J]}])},NQ=($)=>{return delete q$[$],e(["CLOSE",$])},MJ=jQ({init:($)=>{const q=($?.relayUrls?.length?$.relayUrls:null)??XJ;return MQ($,q,zJ,!0).map(KJ).map((G)=>G.ready.then(()=>G).catch(()=>null))},subscribe:($,J,q,Q)=>{const G=$8(64),z=$8(64);return z8[G]=z8[z]=(U,X)=>Q(U,X,async(Z,V)=>{if(J$.has(P8($.url)))return;$.send(await DQ(Z,V))}),$.send(WQ(G,J)),$.send(WQ(z,q)),()=>{$.send(NQ(G)),$.send(NQ(z)),delete z8[G],delete z8[z]}},announce:async($,J)=>{if(J$.has(P8($.url)))return;$.send(await DQ(J,e({peerId:N0})))}}),DJ=KQ(l0);export{N0 as selfId,MJ as join,DJ as getRelaySockets};
