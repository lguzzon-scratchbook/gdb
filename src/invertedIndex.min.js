function O(H){const C={},Q=H.worker,T=H.indexFileName||"inverted_index.msgpack",U=H.encode,X=H.decode,V=H.pako,Y=((L,q)=>{let J;return(...R)=>{clearTimeout(J),J=setTimeout(()=>L.apply(null,R),q)}})(()=>_(),200);async function Z(){try{const L=await new Promise((q,J)=>{const R=(K)=>{if(K.data.type==="loaded"&&K.data.name===T)Q.removeEventListener("message",R),q(new Uint8Array(K.data.data));else if(K.data.type==="error")Q.removeEventListener("message",R),J(new Error(K.data.message))};Q.addEventListener("message",R),Q.postMessage({type:"load",name:T})});if(L.byteLength>0){if(!X||!V)throw new Error("InvertedIndexer: decode y pako deben estar en options");const q=V.inflate(L),J=X(q);return Object.assign(C,J),!0}}catch{}return!1}async function _(){try{if(!U||!V)throw new Error("InvertedIndexer: encode y pako deben estar en options");const L=U(C),q=V.deflate(L);await new Promise((J,R)=>{const K=(E)=>{if(E.data.type==="saved"&&E.data.name===T)Q.removeEventListener("message",K),J();else if(E.data.type==="error")Q.removeEventListener("message",K),R(new Error(E.data.message))};Q.addEventListener("message",K),Q.postMessage({type:"save",name:T,content:q})})}catch{}}async function $(){(typeof H.graph?.getAllNodes==="function"?await H.graph.getAllNodes():Object.values(H.graph.nodes)).forEach((q)=>W(q.id,q.value,"insert",!1)),Y()}function z(){H.map({realtime:!0},(L)=>{if(L.action==="added"||L.action==="updated")W(L.id,L.value,"insert",!0);else if(L.action==="removed")W(L.id,L.value,"remove",!0)})}function W(L,q,J="insert",R=!0){const K=A(q);if(J==="insert")K.forEach((E)=>{if(!C[E])C[E]=[];if(!C[E].includes(L))C[E].push(L)});else if(J==="remove")K.forEach((E)=>{if(C[E]){if(C[E]=C[E].filter((G)=>G!==L),C[E].length===0)delete C[E]}});if(R)Y()}function A(L){if(typeof L==="string")return Array.from({length:L.length},(q,J)=>L.substring(0,J+1));if(typeof L==="number")return[String(L)];if(typeof L==="object"&&L!==null)return Object.keys(L);return[]}function B(L){return Object.keys(C).filter((q)=>q.startsWith(L)).flatMap((q)=>C[q])}return{ready:Z().then((L)=>{if(!L)$();z()}),updateIndex:W,searchAllByPrefix:B}}var D=(H)=>{console.log("\uD83C\uDF33 InvertedIndexer module loaded.");const C=O(H);return H.searchByPrefix=async(Q)=>{return await C.ready,C.searchAllByPrefix(Q).map((U)=>H.graph.get(U))},H};export{D as init,O as InvertedIndexer};
