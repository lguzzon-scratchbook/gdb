function InvertedIndexer(options) {
  const invertedIndex = {}
  const worker = options.worker
  const indexFileName = options.indexFileName || 'inverted_index.msgpack'
  const encode = options.encode
  const decode = options.decode
  const pako = options.pako
  const debouncedSaveIndex = ((saveFunction, delay) => {
    let timeoutId
    return (...args) => {
      clearTimeout(timeoutId)
      timeoutId = setTimeout(() => saveFunction.apply(null, args), delay)
    }
  })(() => saveIndex(), 200)
  async function loadIndex() {
    try {
      const indexData = await new Promise((resolve, reject) => {
        const messageHandler = (event) => {
          if (
            event.data.type === 'loaded' &&
            event.data.name === indexFileName
          ) {
            worker.removeEventListener('message', messageHandler)
            resolve(new Uint8Array(event.data.data))
          } else if (event.data.type === 'error') {
            worker.removeEventListener('message', messageHandler)
            reject(new Error(event.data.message))
          }
        }
        worker.addEventListener('message', messageHandler)
        worker.postMessage({
          type: 'load',
          name: indexFileName
        })
      })
      if (indexData.byteLength > 0) {
        if (!decode || !pako) {
          throw new Error(
            'InvertedIndexer: decode y pako deben estar en options'
          )
        }
        const inflatedData = pako.inflate(indexData)
        const parsedIndex = decode(inflatedData)
        Object.assign(invertedIndex, parsedIndex)
        return true
      }
    } catch {}
    return false
  }
  async function saveIndex() {
    try {
      if (!encode || !pako) {
        throw new Error('InvertedIndexer: encode y pako deben estar en options')
      }
      const serializedIndex = encode(invertedIndex)
      const compressedIndex = pako.deflate(serializedIndex)
      await new Promise((resolve, reject) => {
        const messageHandler = (event) => {
          if (
            event.data.type === 'saved' &&
            event.data.name === indexFileName
          ) {
            worker.removeEventListener('message', messageHandler)
            resolve()
          } else if (event.data.type === 'error') {
            worker.removeEventListener('message', messageHandler)
            reject(new Error(event.data.message))
          }
        }
        worker.addEventListener('message', messageHandler)
        worker.postMessage({
          type: 'save',
          name: indexFileName,
          content: compressedIndex
        })
      })
    } catch {}
  }
  async function initializeIndex() {
    ;(typeof options.graph?.getAllNodes === 'function'
      ? await options.graph.getAllNodes()
      : Object.values(options.graph.nodes)
    ).forEach((node) => updateIndex(node.id, node.value, 'insert', false))
    debouncedSaveIndex()
  }
  function setupRealtimeUpdates() {
    options.map(
      {
        realtime: true
      },
      (graphEvent) => {
        if (graphEvent.action === 'added' || graphEvent.action === 'updated') {
          updateIndex(graphEvent.id, graphEvent.value, 'insert', true)
        } else if (graphEvent.action === 'removed') {
          updateIndex(graphEvent.id, graphEvent.value, 'remove', true)
        }
      }
    )
  }
  function updateIndex(
    nodeId,
    nodeValue,
    action = 'insert',
    shouldSave = true
  ) {
    const tokens = extractTokens(nodeValue)
    if (action === 'insert') {
      tokens.forEach((token) => {
        if (!invertedIndex[token]) {
          invertedIndex[token] = []
        }
        if (!invertedIndex[token].includes(nodeId)) {
          invertedIndex[token].push(nodeId)
        }
      })
    } else if (action === 'remove') {
      tokens.forEach((token) => {
        if (invertedIndex[token]) {
          invertedIndex[token] = invertedIndex[token].filter(
            (id) => id !== nodeId
          )
          if (invertedIndex[token].length === 0) {
            delete invertedIndex[token]
          }
        }
      })
    }
    if (shouldSave) {
      debouncedSaveIndex()
    }
  }
  function extractTokens(value) {
    if (typeof value === 'string') {
      return Array.from(
        {
          length: value.length
        },
        (_unused, index) => value.substring(0, index + 1)
      )
    }
    if (typeof value === 'number') {
      return [String(value)]
    }
    if (typeof value === 'object' && value !== null) {
      return Object.keys(value)
    }
    return []
  }
  function searchByPrefix(prefix) {
    return Object.keys(invertedIndex)
      .filter((token) => token.startsWith(prefix))
      .flatMap((token) => invertedIndex[token])
  }
  return {
    ready: loadIndex().then((loadedSuccessfully) => {
      if (!loadedSuccessfully) {
        initializeIndex()
      }
      setupRealtimeUpdates()
    }),
    updateIndex: updateIndex,
    searchAllByPrefix: searchByPrefix
  }
}
var init = (options) => {
  console.log('ðŸŒ³ InvertedIndexer module loaded.')
  const indexer = InvertedIndexer(options)
  options.searchByPrefix = async (prefix) => {
    await indexer.ready
    return indexer
      .searchAllByPrefix(prefix)
      .map((nodeId) => options.graph.get(nodeId))
  }
  return options
}
export { init, InvertedIndexer }
