var w0 =
  typeof globalThis === 'object' && 'crypto' in globalThis
    ? globalThis.crypto
    : undefined
function I0($) {
  return (
    $ instanceof Uint8Array ||
    (ArrayBuffer.isView($) && $.constructor.name === 'Uint8Array')
  )
}
function o0($) {
  if (!Number.isSafeInteger($) || $ < 0) {
    throw new Error(`positive integer expected, got ${$}`)
  }
}
function $0($, ...J) {
  if (!I0($)) {
    throw new Error('Uint8Array expected')
  }
  if (J.length > 0 && !J.includes($.length)) {
    throw new Error(
      `Uint8Array expected of length ${J}, got length=${$.length}`
    )
  }
}
function Y8($) {
  if (typeof $ !== 'function' || typeof $.create !== 'function') {
    throw new Error('Hash should be wrapped by utils.createHasher')
  }
  o0($.outputLen)
  o0($.blockLen)
}
function _0($, J = true) {
  if ($.destroyed) {
    throw new Error('Hash instance has been destroyed')
  }
  if (J && $.finished) {
    throw new Error('Hash#digest() has already been called')
  }
}
function Y$($, J) {
  $0($)
  const q = J.outputLen
  if ($.length < q) {
    throw new Error(
      `digestInto() expects output buffer of length at least ${q}`
    )
  }
}
function k0(...$) {
  for (let J = 0; J < $.length; J++) {
    $[J].fill(0)
  }
}
function Z8($) {
  return new DataView($.buffer, $.byteOffset, $.byteLength)
}
function Q0($, J) {
  return ($ << (32 - J)) | ($ >>> J)
}
function Z0($) {
  $0($)
  if (Z$) {
    return $.toHex()
  }
  let J = ''
  for (let q = 0; q < $.length; q++) {
    J += wQ[$[q]]
  }
  return J
}
function X$($) {
  if ($ >= Y0._0 && $ <= Y0._9) {
    return $ - Y0._0
  }
  if ($ >= Y0.A && $ <= Y0.F) {
    return $ - (Y0.A - 10)
  }
  if ($ >= Y0.a && $ <= Y0.f) {
    return $ - (Y0.a - 10)
  }
  return
}
function S0($) {
  if (typeof $ !== 'string') {
    throw new Error(`hex string expected, got ${typeof $}`)
  }
  if (Z$) {
    return Uint8Array.fromHex($)
  }
  const J = $.length
  const q = J / 2
  if (J % 2) {
    throw new Error(`hex string expected, got unpadded hex of length ${J}`)
  }
  const Q = new Uint8Array(q)
  for (let G = 0, z = 0; G < q; G++, z += 2) {
    const U = X$($.charCodeAt(z))
    const Y = X$($.charCodeAt(z + 1))
    if (U === undefined || Y === undefined) {
      const X = $[z] + $[z + 1]
      throw new Error(
        `hex string expected, got non-hex character "${X}" at index ${z}`
      )
    }
    Q[G] = U * 16 + Y
  }
  return Q
}
function K8($) {
  if (typeof $ !== 'string') {
    throw new Error('string expected')
  }
  return new Uint8Array(new TextEncoder().encode($))
}
function r0($) {
  if (typeof $ === 'string') {
    $ = K8($)
  }
  $0($)
  return $
}
function o(...$) {
  let J = 0
  for (let Q = 0; Q < $.length; Q++) {
    const G = $[Q]
    $0(G)
    J += G.length
  }
  const q = new Uint8Array(J)
  for (let Q = 0, G = 0; Q < $.length; Q++) {
    const z = $[Q]
    q.set(z, G)
    G += z.length
  }
  return q
}
function K$($) {
  const J = (Q) => $().update(r0(Q)).digest()
  const q = $()
  J.outputLen = q.outputLen
  J.blockLen = q.blockLen
  J.create = () => $()
  return J
}
function P0($ = 32) {
  if (w0 && typeof w0.getRandomValues === 'function') {
    return w0.getRandomValues(new Uint8Array($))
  }
  if (w0 && typeof w0.randomBytes === 'function') {
    return Uint8Array.from(w0.randomBytes($))
  }
  throw new Error('crypto.getRandomValues must be defined')
} /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var Z$ = (() =>
  typeof Uint8Array.from([]).toHex === 'function' &&
  typeof Uint8Array.fromHex === 'function')()
var wQ = Array.from(
  {
    length: 256
  },
  (_$, J) => J.toString(16).padStart(2, '0')
)
var Y0 = {
  _0: 48,
  _9: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
}
class p0 {}
function IQ($, J, q, Q) {
  if (typeof $.setBigUint64 === 'function') {
    return $.setBigUint64(J, q, Q)
  }
  const G = BigInt(32)
  const z = BigInt(4294967295)
  const U = Number((q >> G) & z)
  const Y = Number(q & z)
  const X = Q ? 4 : 0
  const V = Q ? 0 : 4
  $.setUint32(J + X, U, Q)
  $.setUint32(J + V, Y, Q)
}
function M$($, J, q) {
  return ($ & J) ^ (~$ & q)
}
function D$($, J, q) {
  return ($ & J) ^ ($ & q) ^ (J & q)
}
class f8 extends p0 {
  constructor($, J, q, Q) {
    super()
    this.finished = false
    this.length = 0
    this.pos = 0
    this.destroyed = false
    this.blockLen = $
    this.outputLen = J
    this.padOffset = q
    this.isLE = Q
    this.buffer = new Uint8Array($)
    this.view = Z8(this.buffer)
  }
  update($) {
    _0(this)
    $ = r0($)
    $0($)
    const { view: J, buffer: q, blockLen: Q } = this
    const G = $.length
    for (let z = 0; z < G; ) {
      const U = Math.min(Q - this.pos, G - z)
      if (U === Q) {
        const Y = Z8($)
        for (; Q <= G - z; z += Q) {
          this.process(Y, z)
        }
        continue
      }
      q.set($.subarray(z, z + U), this.pos)
      this.pos += U
      z += U
      if (this.pos === Q) {
        this.process(J, 0)
        this.pos = 0
      }
    }
    this.length += $.length
    this.roundClean()
    return this
  }
  digestInto($) {
    _0(this)
    Y$($, this)
    this.finished = true
    const { buffer: J, view: q, blockLen: Q, isLE: G } = this
    let { pos: z } = this
    J[z++] = 128
    k0(this.buffer.subarray(z))
    if (this.padOffset > Q - z) {
      this.process(q, 0)
      z = 0
    }
    for (let N = z; N < Q; N++) {
      J[N] = 0
    }
    IQ(q, Q - 8, BigInt(this.length * 8), G)
    this.process(q, 0)
    const U = Z8($)
    const Y = this.outputLen
    if (Y % 4) {
      throw new Error('_sha2: outputLen should be aligned to 32bit')
    }
    const X = Y / 4
    const V = this.get()
    if (X > V.length) {
      throw new Error('_sha2: outputLen bigger than state')
    }
    for (let N = 0; N < X; N++) {
      U.setUint32(N * 4, V[N], G)
    }
  }
  digest() {
    const { buffer: $, outputLen: J } = this
    this.digestInto($)
    const q = $.slice(0, J)
    this.destroy()
    return q
  }
  _cloneInto($) {
    $ ||= new this.constructor()
    $.set(...this.get())
    const {
      blockLen: J,
      buffer: q,
      length: Q,
      finished: G,
      destroyed: z,
      pos: U
    } = this
    $.destroyed = z
    $.finished = G
    $.length = Q
    $.pos = U
    if (Q % J) {
      $.buffer.set(q)
    }
    return $
  }
  clone() {
    return this._cloneInto()
  }
}
var K0 = Uint32Array.from([
  1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924,
  528734635, 1541459225
])
var kQ = Uint32Array.from([
  1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
  2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
  1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774,
  264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
  2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711,
  113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
  1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
  3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
  430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063,
  1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474,
  2756734187, 3204031479, 3329325298
])
var H0 = new Uint32Array(64)
class W$ extends f8 {
  constructor($ = 32) {
    super(64, $, 8, false)
    this.A = K0[0] | 0
    this.B = K0[1] | 0
    this.C = K0[2] | 0
    this.D = K0[3] | 0
    this.E = K0[4] | 0
    this.F = K0[5] | 0
    this.G = K0[6] | 0
    this.H = K0[7] | 0
  }
  get() {
    const { A: $, B: J, C: q, D: Q, E: G, F: z, G: U, H: Y } = this
    return [$, J, q, Q, G, z, U, Y]
  }
  set($, J, q, Q, G, z, U, Y) {
    this.A = $ | 0
    this.B = J | 0
    this.C = q | 0
    this.D = Q | 0
    this.E = G | 0
    this.F = z | 0
    this.G = U | 0
    this.H = Y | 0
  }
  process($, J) {
    for (let N = 0; N < 16; N++, J += 4) {
      H0[N] = $.getUint32(J, false)
    }
    for (let N = 16; N < 64; N++) {
      const L = H0[N - 15]
      const j = H0[N - 2]
      const K = Q0(L, 7) ^ Q0(L, 18) ^ (L >>> 3)
      const x = Q0(j, 17) ^ Q0(j, 19) ^ (j >>> 10)
      H0[N] = (x + H0[N - 7] + K + H0[N - 16]) | 0
    }
    let { A: q, B: Q, C: G, D: z, E: U, F: Y, G: X, H: V } = this
    for (let N = 0; N < 64; N++) {
      const L = Q0(U, 6) ^ Q0(U, 11) ^ Q0(U, 25)
      const j = (V + L + M$(U, Y, X) + kQ[N] + H0[N]) | 0
      const x = ((Q0(q, 2) ^ Q0(q, 13) ^ Q0(q, 22)) + D$(q, Q, G)) | 0
      V = X
      X = Y
      Y = U
      U = (z + j) | 0
      z = G
      G = Q
      Q = q
      q = (j + x) | 0
    }
    q = (q + this.A) | 0
    Q = (Q + this.B) | 0
    G = (G + this.C) | 0
    z = (z + this.D) | 0
    U = (U + this.E) | 0
    Y = (Y + this.F) | 0
    X = (X + this.G) | 0
    V = (V + this.H) | 0
    this.set(q, Q, G, z, U, Y, X, V)
  }
  roundClean() {
    k0(H0)
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0)
    k0(this.buffer)
  }
}
var M8 = K$(() => new W$())
class _8 extends p0 {
  constructor($, J) {
    super()
    this.finished = false
    this.destroyed = false
    Y8($)
    const q = r0(J)
    this.iHash = $.create()
    if (typeof this.iHash.update !== 'function') {
      throw new Error('Expected instance of class which extends utils.Hash')
    }
    this.blockLen = this.iHash.blockLen
    this.outputLen = this.iHash.outputLen
    const Q = this.blockLen
    const G = new Uint8Array(Q)
    G.set(q.length > Q ? $.create().update(q).digest() : q)
    for (let z = 0; z < G.length; z++) {
      G[z] ^= 54
    }
    this.iHash.update(G)
    this.oHash = $.create()
    for (let z = 0; z < G.length; z++) {
      G[z] ^= 106
    }
    this.oHash.update(G)
    k0(G)
  }
  update($) {
    _0(this)
    this.iHash.update($)
    return this
  }
  digestInto($) {
    _0(this)
    $0($, this.outputLen)
    this.finished = true
    this.iHash.digestInto($)
    this.oHash.update($)
    this.oHash.digestInto($)
    this.destroy()
  }
  digest() {
    const $ = new Uint8Array(this.oHash.outputLen)
    this.digestInto($)
    return $
  }
  _cloneInto($) {
    $ ||= Object.create(Object.getPrototypeOf(this), {})
    const {
      oHash: J,
      iHash: q,
      finished: Q,
      destroyed: G,
      blockLen: z,
      outputLen: U
    } = this
    $ = $
    $.finished = Q
    $.destroyed = G
    $.blockLen = z
    $.outputLen = U
    $.oHash = J._cloneInto($.oHash)
    $.iHash = q._cloneInto($.iHash)
    return $
  }
  clone() {
    return this._cloneInto()
  }
  destroy() {
    this.destroyed = true
    this.oHash.destroy()
    this.iHash.destroy()
  }
}
var b8 = ($, J, q) => new _8($, J).update(q).digest()
b8.create = ($, J) => new _8($, J)
function i0($, J = '') {
  if (typeof $ !== 'boolean') {
    const q = J && `"${J}"`
    throw new Error(`${q}expected boolean, got type=${typeof $}`)
  }
  return $
}
function O0($, J, q = '') {
  const Q = I0($)
  const G = $?.length
  const z = J !== undefined
  if (!Q || (z && G !== J)) {
    const U = q && `"${q}" `
    const Y = z ? ` of length ${J}` : ''
    const X = Q ? `length=${G}` : `type=${typeof $}`
    throw new Error(`${U}expected Uint8Array${Y}, got ${X}`)
  }
  return $
}
function a0($) {
  const J = $.toString(16)
  if (J.length & 1) {
    return `0${J}`
  } else {
    return J
  }
}
function N$($) {
  if (typeof $ !== 'string') {
    throw new Error(`hex string expected, got ${typeof $}`)
  }
  if ($ === '') {
    return u8
  } else {
    return BigInt(`0x${$}`)
  }
}
function M0($) {
  return N$(Z0($))
}
function m8($) {
  $0($)
  return N$(Z0(Uint8Array.from($).reverse()))
}
function b0($, J) {
  return S0($.toString(16).padStart(J * 2, '0'))
}
function F8($, J) {
  return b0($, J).reverse()
}
function m($, J, q) {
  let Q
  if (typeof J === 'string') {
    try {
      Q = S0(J)
    } catch (z) {
      throw new Error(`${$} must be hex string or Uint8Array, cause: ${z}`)
    }
  } else if (I0(J)) {
    Q = Uint8Array.from(J)
  } else {
    throw new Error(`${$} must be hex string or Uint8Array`)
  }
  const G = Q.length
  if (typeof q === 'number' && G !== q) {
    throw new Error(`${$} of length ${q} expected, got ${G}`)
  }
  return Q
}
function n0($, J, q) {
  return g8($) && g8(J) && g8(q) && J <= $ && $ < q
}
function V$($, J, q, Q) {
  if (!n0(J, q, Q)) {
    throw new Error(`expected valid ${$}: ${q} <= n < ${Q}, got ${J}`)
  }
}
function D8($) {
  let J
  for (J = 0; $ > u8; J += 1) {
    $ >>= y8
  }
  return J
}
function C$($, J, q) {
  if (typeof $ !== 'number' || $ < 2) {
    throw new Error('hashLen must be a number')
  }
  if (typeof J !== 'number' || J < 2) {
    throw new Error('qByteLen must be a number')
  }
  if (typeof q !== 'function') {
    throw new Error('hmacFn must be a function')
  }
  const Q = (K) => new Uint8Array(K)
  const G = (K) => Uint8Array.of(K)
  let z = Q($)
  let U = Q($)
  let Y = 0
  const X = () => {
    z.fill(1)
    U.fill(0)
    Y = 0
  }
  const V = (...K) => q(U, z, ...K)
  const N = (K = Q(0)) => {
    U = V(G(0), K)
    z = V()
    if (K.length === 0) {
      return
    }
    U = V(G(1), K)
    z = V()
  }
  const L = () => {
    if (Y++ >= 1000) {
      throw new Error('drbg: tried 1000 values')
    }
    let K = 0
    const x = []
    while (K < J) {
      z = V()
      const A = z.slice()
      x.push(A)
      K += z.length
    }
    return o(...x)
  }
  return (K, x) => {
    X()
    N(K)
    let A
    while (!(A = x(L()))) {
      N()
    }
    X()
    return A
  }
}
function s0($, J, q = {}) {
  if (!$ || typeof $ !== 'object') {
    throw new Error('expected valid options object')
  }
  function Q(G, z, U) {
    const Y = $[G]
    if (U && Y === undefined) {
      return
    }
    const X = typeof Y
    if (X !== z || Y === null) {
      throw new Error(`param "${G}" is invalid: expected ${z}, got ${X}`)
    }
  }
  Object.entries(J).forEach(([G, z]) => Q(G, z, false))
  Object.entries(q).forEach(([G, z]) => Q(G, z, true))
}
function h8($) {
  const J = new WeakMap()
  return (q, ...Q) => {
    const G = J.get(q)
    if (G !== undefined) {
      return G
    }
    const z = $(q, ...Q)
    J.set(q, z)
    return z
  }
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var u8 = BigInt(0)
var y8 = BigInt(1)
var g8 = ($) => typeof $ === 'bigint' && u8 <= $
var x0 = ($) => (y8 << BigInt($)) - y8
function i($, J) {
  const q = $ % J
  if (q >= l) {
    return q
  } else {
    return J + q
  }
}
function a($, J, q) {
  let Q = $
  while (J-- > l) {
    Q *= Q
    Q %= q
  }
  return Q
}
function B$($, J) {
  if ($ === l) {
    throw new Error('invert: expected non-zero number')
  }
  if (J <= l) {
    throw new Error(`invert: expected positive modulus, got ${J}`)
  }
  let q = i($, J)
  let Q = J
  let G = l
  let z = h
  let U = h
  let Y = l
  while (q !== l) {
    const V = Q / q
    const N = Q % q
    const L = G - U * V
    const j = z - Y * V
    Q = q
    q = N
    G = U
    z = Y
    U = L
    Y = j
  }
  if (Q !== h) {
    throw new Error('invert: does not exist')
  }
  return i(G, J)
}
function l8($, J, q) {
  if (!$.eql($.sqr(J), q)) {
    throw new Error('Cannot find square root')
  }
}
function A$($, J) {
  const q = ($.ORDER + h) / x$
  const Q = $.pow(J, q)
  l8($, Q, J)
  return Q
}
function EQ($, J) {
  const q = ($.ORDER - T$) / L$
  const Q = $.mul(J, E0)
  const G = $.pow(Q, q)
  const z = $.mul(J, G)
  const U = $.mul($.mul(z, E0), G)
  const Y = $.mul(z, $.sub(U, $.ONE))
  l8($, Y, J)
  return Y
}
function vQ($) {
  const J = T0($)
  const q = w$($)
  const Q = q(J, J.neg(J.ONE))
  const G = q(J, Q)
  const z = q(J, J.neg(Q))
  const U = ($ + SQ) / R$
  return (Y, X) => {
    let V = Y.pow(X, U)
    let N = Y.mul(V, Q)
    const L = Y.mul(V, G)
    const j = Y.mul(V, z)
    const K = Y.eql(Y.sqr(N), X)
    const x = Y.eql(Y.sqr(L), X)
    V = Y.cmov(V, N, K)
    N = Y.cmov(j, L, x)
    const A = Y.eql(Y.sqr(N), X)
    const E = Y.cmov(V, N, A)
    l8(Y, E, X)
    return E
  }
}
function w$($) {
  if ($ < O$) {
    throw new Error('sqrt is not defined for small field')
  }
  let J = $ - h
  let q = 0
  while (J % E0 === l) {
    J /= E0
    q++
  }
  let Q = E0
  const G = T0($)
  while (H$(G, Q) === 1) {
    if (Q++ > 1000) {
      throw new Error('Cannot find square root: probably non-prime P')
    }
  }
  if (q === 1) {
    return A$
  }
  const z = G.pow(Q, J)
  const U = (J + h) / E0
  return function Y(X, V) {
    if (X.is0(V)) {
      return V
    }
    if (H$(X, V) !== 1) {
      throw new Error('Cannot find square root')
    }
    let N = q
    let L = X.mul(X.ONE, z)
    let j = X.pow(V, J)
    let K = X.pow(V, U)
    while (!X.eql(j, X.ONE)) {
      if (X.is0(j)) {
        return X.ZERO
      }
      let x = 1
      let A = X.sqr(j)
      while (!X.eql(A, X.ONE)) {
        x++
        A = X.sqr(A)
        if (x === N) {
          throw new Error('Cannot find square root')
        }
      }
      const E = h << BigInt(N - x - 1)
      const f = X.pow(L, E)
      N = x
      L = X.sqr(f)
      j = X.mul(j, L)
      K = X.mul(K, f)
    }
    return K
  }
}
function fQ($) {
  if ($ % x$ === O$) {
    return A$
  }
  if ($ % L$ === T$) {
    return EQ
  }
  if ($ % R$ === PQ) {
    return vQ($)
  }
  return w$($)
}
function c8($) {
  const J = {
    ORDER: 'bigint',
    MASK: 'bigint',
    BYTES: 'number',
    BITS: 'number'
  }
  const q = _Q.reduce((Q, G) => {
    Q[G] = 'function'
    return Q
  }, J)
  s0($, q)
  return $
}
function bQ($, J, q) {
  if (q < l) {
    throw new Error('invalid exponent, negatives unsupported')
  }
  if (q === l) {
    return $.ONE
  }
  if (q === h) {
    return J
  }
  let Q = $.ONE
  let G = J
  while (q > l) {
    if (q & h) {
      Q = $.mul(Q, G)
    }
    G = $.sqr(G)
    q >>= h
  }
  return Q
}
function W8($, J, q = false) {
  const Q = new Array(J.length).fill(q ? $.ZERO : undefined)
  const G = J.reduce((U, Y, X) => {
    if ($.is0(Y)) {
      return U
    }
    Q[X] = U
    return $.mul(U, Y)
  }, $.ONE)
  const z = $.inv(G)
  J.reduceRight((U, Y, X) => {
    if ($.is0(Y)) {
      return U
    }
    Q[X] = $.mul(U, Q[X])
    return $.mul(U, Y)
  }, z)
  return Q
}
function H$($, J) {
  const q = ($.ORDER - h) / E0
  const Q = $.pow(J, q)
  const G = $.eql(Q, $.ONE)
  const z = $.eql(Q, $.ZERO)
  const U = $.eql(Q, $.neg($.ONE))
  if (!G && !z && !U) {
    throw new Error('invalid Legendre symbol result')
  }
  if (G) {
    return 1
  } else if (z) {
    return 0
  } else {
    return -1
  }
}
function N8($, J) {
  if (J !== undefined) {
    o0(J)
  }
  const q = J !== undefined ? J : $.toString(2).length
  const Q = Math.ceil(q / 8)
  return {
    nBitLength: q,
    nByteLength: Q
  }
}
function T0($, J, q = false, Q = {}) {
  if ($ <= l) {
    throw new Error(`invalid field: expected ORDER > 0, got ${$}`)
  }
  let G
  let z
  let U = false
  let Y
  if (typeof J === 'object' && J != null) {
    if (Q.sqrt || q) {
      throw new Error('cannot specify opts in two arguments')
    }
    const j = J
    if (j.BITS) {
      G = j.BITS
    }
    if (j.sqrt) {
      z = j.sqrt
    }
    if (typeof j.isLE === 'boolean') {
      q = j.isLE
    }
    if (typeof j.modFromBytes === 'boolean') {
      U = j.modFromBytes
    }
    Y = j.allowedLengths
  } else {
    if (typeof J === 'number') {
      G = J
    }
    if (Q.sqrt) {
      z = Q.sqrt
    }
  }
  const { nBitLength: X, nByteLength: V } = N8($, G)
  if (V > 2048) {
    throw new Error('invalid field: expected ORDER of <= 2048 bytes')
  }
  let N
  const L = Object.freeze({
    ORDER: $,
    isLE: q,
    BITS: X,
    BYTES: V,
    MASK: x0(X),
    ZERO: l,
    ONE: h,
    allowedLengths: Y,
    create: (j) => i(j, $),
    isValid: (j) => {
      if (typeof j !== 'bigint') {
        throw new Error(
          `invalid field element: expected bigint, got ${typeof j}`
        )
      }
      return l <= j && j < $
    },
    is0: (j) => j === l,
    isValidNot0: (j) => !L.is0(j) && L.isValid(j),
    isOdd: (j) => (j & h) === h,
    neg: (j) => i(-j, $),
    eql: (j, K) => j === K,
    sqr: (j) => i(j * j, $),
    add: (j, K) => i(j + K, $),
    sub: (j, K) => i(j - K, $),
    mul: (j, K) => i(j * K, $),
    pow: (j, K) => bQ(L, j, K),
    div: (j, K) => i(j * B$(K, $), $),
    sqrN: (j) => j * j,
    addN: (j, K) => j + K,
    subN: (j, K) => j - K,
    mulN: (j, K) => j * K,
    inv: (j) => B$(j, $),
    sqrt:
      z ||
      ((j) => {
        if (!N) {
          N = fQ($)
        }
        return N(L, j)
      }),
    toBytes: (j) => (q ? F8(j, V) : b0(j, V)),
    fromBytes: (j, K = true) => {
      if (Y) {
        if (!Y.includes(j.length) || j.length > V) {
          throw new Error(
            `Field.fromBytes: expected ${Y} bytes, got ${j.length}`
          )
        }
        const A = new Uint8Array(V)
        A.set(j, q ? 0 : A.length - j.length)
        j = A
      }
      if (j.length !== V) {
        throw new Error(`Field.fromBytes: expected ${V} bytes, got ${j.length}`)
      }
      let x = q ? m8(j) : M0(j)
      if (U) {
        x = i(x, $)
      }
      if (!K) {
        if (!L.isValid(x)) {
          throw new Error('invalid field element: outside of range 0..ORDER')
        }
      }
      return x
    },
    invertBatch: (j) => W8(L, j),
    cmov: (j, K, x) => (x ? K : j)
  })
  return Object.freeze(L)
}
function I$($) {
  if (typeof $ !== 'bigint') {
    throw new Error('field order must be bigint')
  }
  const J = $.toString(2).length
  return Math.ceil(J / 8)
}
function d8($) {
  const J = I$($)
  return J + Math.ceil(J / 2)
}
function V8($, J, q = false) {
  const Q = $.length
  const G = I$(J)
  const z = d8(J)
  if (Q < 16 || Q < z || Q > 1024) {
    throw new Error(`expected ${z}-1024 bytes of input, got ${Q}`)
  }
  const U = q ? m8($) : M0($)
  const Y = i(U, J - h) + h
  if (q) {
    return F8(Y, G)
  } else {
    return b0(Y, G)
  }
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var l = BigInt(0)
var h = BigInt(1)
var E0 = BigInt(2)
var O$ = BigInt(3)
var x$ = BigInt(4)
var T$ = BigInt(5)
var SQ = BigInt(7)
var L$ = BigInt(8)
var PQ = BigInt(9)
var R$ = BigInt(16)
var _Q = [
  'create',
  'isValid',
  'is0',
  'neg',
  'inv',
  'sqrt',
  'sqr',
  'eql',
  'add',
  'sub',
  'mul',
  'pow',
  'div',
  'addN',
  'subN',
  'mulN',
  'sqrN'
]
function t0($, J) {
  const q = J.negate()
  if ($) {
    return q
  } else {
    return J
  }
}
function C8($, J) {
  const q = W8(
    $.Fp,
    J.map((Q) => Q.Z)
  )
  return J.map((Q, G) => $.fromAffine(Q.toAffine(q[G])))
}
function E$($, J) {
  if (!Number.isSafeInteger($) || $ <= 0 || $ > J) {
    throw new Error(`invalid window size, expected [1..${J}], got W=${$}`)
  }
}
function o8($, J) {
  E$($, J)
  const q = Math.ceil(J / $) + 1
  const Q = 2 ** ($ - 1)
  const G = 2 ** $
  const z = x0($)
  const U = BigInt($)
  return {
    windows: q,
    windowSize: Q,
    mask: z,
    maxNumber: G,
    shiftBy: U
  }
}
function k$($, J, q) {
  const { windowSize: Q, mask: G, maxNumber: z, shiftBy: U } = q
  let Y = Number($ & G)
  let X = $ >> U
  if (Y > Q) {
    Y -= z
    X += v0
  }
  const V = J * Q
  const N = V + Math.abs(Y) - 1
  const L = Y === 0
  const j = Y < 0
  const K = J % 2 !== 0
  return {
    nextN: X,
    offset: N,
    isZero: L,
    isNeg: j,
    isNegF: K,
    offsetF: V
  }
}
function gQ($, J) {
  if (!Array.isArray($)) {
    throw new Error('array expected')
  }
  $.forEach((q, Q) => {
    if (!(q instanceof J)) {
      throw new Error(`invalid point at index ${Q}`)
    }
  })
}
function yQ($, J) {
  if (!Array.isArray($)) {
    throw new Error('array of scalars expected')
  }
  $.forEach((q, Q) => {
    if (!J.isValid(q)) {
      throw new Error(`invalid scalar at index ${Q}`)
    }
  })
}
function p8($) {
  return v$.get($) || 1
}
function S$($) {
  if ($ !== g0) {
    throw new Error('invalid wNAF')
  }
}
function f$($, J, q, Q) {
  let G = J
  let z = $.ZERO
  let U = $.ZERO
  while (q > g0 || Q > g0) {
    if (q & v0) {
      z = z.add(G)
    }
    if (Q & v0) {
      U = U.add(G)
    }
    G = G.double()
    q >>= v0
    Q >>= v0
  }
  return {
    p1: z,
    p2: U
  }
}
function _$($, J, q, Q) {
  gQ(q, $)
  yQ(Q, J)
  const G = q.length
  const z = Q.length
  if (G !== z) {
    throw new Error('arrays of points and scalars must have equal length')
  }
  const U = $.ZERO
  const Y = D8(BigInt(G))
  let X = 1
  if (Y > 12) {
    X = Y - 3
  } else if (Y > 4) {
    X = Y - 2
  } else if (Y > 0) {
    X = 2
  }
  const V = x0(X)
  const N = new Array(Number(V) + 1).fill(U)
  const L = Math.floor((J.BITS - 1) / X) * X
  let j = U
  for (let K = L; K >= 0; K -= X) {
    N.fill(U)
    for (let A = 0; A < z; A++) {
      const E = Q[A]
      const f = Number((E >> BigInt(K)) & V)
      N[f] = N[f].add(q[A])
    }
    let x = U
    for (let A = N.length - 1, E = U; A > 0; A--) {
      E = E.add(N[A])
      x = x.add(E)
    }
    j = j.add(x)
    if (K !== 0) {
      for (let A = 0; A < X; A++) {
        j = j.double()
      }
    }
  }
  return j
}
function P$($, J, q) {
  if (J) {
    if (J.ORDER !== $) {
      throw new Error('Field.ORDER must match order: Fp == p, Fn == n')
    }
    c8(J)
    return J
  } else {
    return T0($, {
      isLE: q
    })
  }
}
function b$($, J, q = {}, Q = $ === 'edwards') {
  if (!J || typeof J !== 'object') {
    throw new Error(`expected valid ${$} CURVE object`)
  }
  for (const X of ['p', 'n', 'h']) {
    const V = J[X]
    if (typeof V !== 'bigint' || !(V > g0)) {
      throw new Error(`CURVE.${X} must be positive bigint`)
    }
  }
  const G = P$(J.p, q.Fp, Q)
  const z = P$(J.n, q.Fn, Q)
  const Y = ['Gx', 'Gy', 'a', $ === 'weierstrass' ? 'b' : 'd']
  for (const X of Y) {
    if (!G.isValid(J[X])) {
      throw new Error(`CURVE.${X} must be valid field element of CURVE.Fp`)
    }
  }
  J = Object.freeze(Object.assign({}, J))
  return {
    CURVE: J,
    Fp: G,
    Fn: z
  }
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var g0 = BigInt(0)
var v0 = BigInt(1)
var r8 = new WeakMap()
var v$ = new WeakMap()
class i8 {
  constructor($, J) {
    this.BASE = $.BASE
    this.ZERO = $.ZERO
    this.Fn = $.Fn
    this.bits = J
  }
  _unsafeLadder($, J, q = this.ZERO) {
    let Q = $
    while (J > g0) {
      if (J & v0) {
        q = q.add(Q)
      }
      Q = Q.double()
      J >>= v0
    }
    return q
  }
  precomputeWindow($, J) {
    const { windows: q, windowSize: Q } = o8(J, this.bits)
    const G = []
    let z = $
    let U = z
    for (let Y = 0; Y < q; Y++) {
      U = z
      G.push(U)
      for (let X = 1; X < Q; X++) {
        U = U.add(z)
        G.push(U)
      }
      z = U.double()
    }
    return G
  }
  wNAF($, J, q) {
    if (!this.Fn.isValid(q)) {
      throw new Error('invalid scalar')
    }
    let Q = this.ZERO
    let G = this.BASE
    const z = o8($, this.bits)
    for (let U = 0; U < z.windows; U++) {
      const {
        nextN: Y,
        offset: X,
        isZero: V,
        isNeg: N,
        isNegF: L,
        offsetF: j
      } = k$(q, U, z)
      q = Y
      if (V) {
        G = G.add(t0(L, J[j]))
      } else {
        Q = Q.add(t0(N, J[X]))
      }
    }
    S$(q)
    return {
      p: Q,
      f: G
    }
  }
  wNAFUnsafe($, J, q, Q = this.ZERO) {
    const G = o8($, this.bits)
    for (let z = 0; z < G.windows; z++) {
      if (q === g0) {
        break
      }
      const { nextN: U, offset: Y, isZero: X, isNeg: V } = k$(q, z, G)
      q = U
      if (X) {
      } else {
        const N = J[Y]
        Q = Q.add(V ? N.negate() : N)
      }
    }
    S$(q)
    return Q
  }
  getPrecomputes($, J, q) {
    let Q = r8.get(J)
    if (!Q) {
      Q = this.precomputeWindow(J, $)
      if ($ !== 1) {
        if (typeof q === 'function') {
          Q = q(Q)
        }
        r8.set(J, Q)
      }
    }
    return Q
  }
  cached($, J, q) {
    const Q = p8($)
    return this.wNAF(Q, this.getPrecomputes(Q, $, q), J)
  }
  unsafe($, J, q, Q) {
    const G = p8($)
    if (G === 1) {
      return this._unsafeLadder($, J, Q)
    }
    return this.wNAFUnsafe(G, this.getPrecomputes(G, $, q), J, Q)
  }
  createCache($, J) {
    E$(J, this.bits)
    v$.set($, J)
    r8.delete($)
  }
  hasCache($) {
    return p8($) !== 1
  }
}
function uQ($, J, q) {
  const [[Q, G], [z, U]] = J
  const Y = g$(U * $, q)
  const X = g$(-G * $, q)
  let V = $ - Y * Q - X * z
  let N = -Y * G - X * U
  const L = V < W0
  const j = N < W0
  if (L) {
    V = -V
  }
  if (j) {
    N = -N
  }
  const K = x0(Math.ceil(D8(q) / 2)) + y0
  if (V < W0 || V >= K || N < W0 || N >= K) {
    throw new Error(`splitScalar (endomorphism): failed, k=${$}`)
  }
  return {
    k1neg: L,
    k1: V,
    k2neg: j,
    k2: N
  }
}
function n8($) {
  if (!['compact', 'recovered', 'der'].includes($)) {
    throw new Error('Signature format must be "compact", "recovered", or "der"')
  }
  return $
}
function a8($, J) {
  const q = {}
  for (const Q of Object.keys(J)) {
    q[Q] = $[Q] === undefined ? J[Q] : $[Q]
  }
  i0(q.lowS, 'lowS')
  i0(q.prehash, 'prehash')
  if (q.format !== undefined) {
    n8(q.format)
  }
  return q
}
function L0($, J) {
  const { BYTES: q } = $
  let Q
  if (typeof J === 'bigint') {
    Q = J
  } else {
    const G = m('private key', J)
    try {
      Q = $.fromBytes(G)
    } catch (_z) {
      throw new Error(
        `invalid private key: expected ui8a of size ${q}, got ${typeof J}`
      )
    }
  }
  if (!$.isValidNot0(Q)) {
    throw new Error('invalid private key: out of range [1..N-1]')
  }
  return Q
}
function FQ($, J = {}) {
  const q = b$('weierstrass', $, J)
  const { Fp: Q, Fn: G } = q
  const z = q.CURVE
  const { h: U, n: Y } = z
  s0(
    J,
    {},
    {
      allowInfinityPoint: 'boolean',
      clearCofactor: 'function',
      isTorsionFree: 'function',
      fromBytes: 'function',
      toBytes: 'function',
      endo: 'object',
      wrapPrivateKey: 'boolean'
    }
  )
  const { endo: X } = J
  if (X) {
    if (
      !Q.is0(z.a) ||
      typeof X.beta !== 'bigint' ||
      !Array.isArray(X.basises)
    ) {
      throw new Error(
        'invalid endo: expected "beta": bigint and "basises": array'
      )
    }
  }
  const V = F$(Q, G)
  function N() {
    if (!Q.isOdd) {
      throw new Error(
        'compression is not supported: Field does not have .isOdd()'
      )
    }
  }
  function L(_W, T, M) {
    const { x: H, y: Z } = T.toAffine()
    const D = Q.toBytes(H)
    i0(M, 'isCompressed')
    if (M) {
      N()
      const C = !Q.isOdd(Z)
      return o(m$(C), D)
    } else {
      return o(Uint8Array.of(4), D, Q.toBytes(Z))
    }
  }
  function j(W) {
    O0(W, undefined, 'Point')
    const { publicKey: T, publicKeyUncompressed: M } = V
    const H = W.length
    const Z = W[0]
    const D = W.subarray(1)
    if (H === T && (Z === 2 || Z === 3)) {
      const C = Q.fromBytes(D)
      if (!Q.isValid(C)) {
        throw new Error('bad point: is not on curve, wrong x')
      }
      const O = A(C)
      let B
      try {
        B = Q.sqrt(O)
      } catch (k) {
        const w = k instanceof Error ? `: ${k.message}` : ''
        throw new Error(`bad point: is not on curve, sqrt error${w}`)
      }
      N()
      const R = Q.isOdd(B)
      if (((Z & 1) === 1) !== R) {
        B = Q.neg(B)
      }
      return {
        x: C,
        y: B
      }
    } else if (H === M && Z === 4) {
      const C = Q.BYTES
      const O = Q.fromBytes(D.subarray(0, C))
      const B = Q.fromBytes(D.subarray(C, C * 2))
      if (!E(O, B)) {
        throw new Error('bad point: is not on curve')
      }
      return {
        x: O,
        y: B
      }
    } else {
      throw new Error(
        `bad point: got length ${H}, expected compressed=${T} or uncompressed=${M}`
      )
    }
  }
  const K = J.toBytes || L
  const x = J.fromBytes || j
  function A(W) {
    const T = Q.sqr(W)
    const M = Q.mul(T, W)
    return Q.add(Q.add(M, Q.mul(W, z.a)), z.b)
  }
  function E(W, T) {
    const M = Q.sqr(T)
    const H = A(W)
    return Q.eql(M, H)
  }
  if (!E(z.Gx, z.Gy)) {
    throw new Error('bad curve params: generator point')
  }
  const f = Q.mul(Q.pow(z.a, B8), mQ)
  const q0 = Q.mul(Q.sqr(z.b), BigInt(27))
  if (Q.is0(Q.add(f, q0))) {
    throw new Error('bad curve params: a or b')
  }
  function b(W, T, M = false) {
    if (!Q.isValid(T) || (M && Q.is0(T))) {
      throw new Error(`bad point coordinate ${W}`)
    }
    return T
  }
  function n(W) {
    if (!(W instanceof I)) {
      throw new Error('ProjectivePoint expected')
    }
  }
  function c(W) {
    if (!X || !X.basises) {
      throw new Error('no endo')
    }
    return uQ(W, X.basises, G.ORDER)
  }
  const s = h8((W, T) => {
    const { X: M, Y: H, Z } = W
    if (Q.eql(Z, Q.ONE)) {
      return {
        x: M,
        y: H
      }
    }
    const D = W.is0()
    if (T == null) {
      T = D ? Q.ONE : Q.inv(Z)
    }
    const C = Q.mul(M, T)
    const O = Q.mul(H, T)
    const B = Q.mul(Z, T)
    if (D) {
      return {
        x: Q.ZERO,
        y: Q.ZERO
      }
    }
    if (!Q.eql(B, Q.ONE)) {
      throw new Error('invZ was invalid')
    }
    return {
      x: C,
      y: O
    }
  })
  const C0 = h8((W) => {
    if (W.is0()) {
      if (J.allowInfinityPoint && !Q.is0(W.Y)) {
        return
      }
      throw new Error('bad point: ZERO')
    }
    const { x: T, y: M } = W.toAffine()
    if (!Q.isValid(T) || !Q.isValid(M)) {
      throw new Error('bad point: x or y not field elements')
    }
    if (!E(T, M)) {
      throw new Error('bad point: equation left != right')
    }
    if (!W.isTorsionFree()) {
      throw new Error('bad point: not in prime-order subgroup')
    }
    return true
  })
  function G0(W, T, M, H, Z) {
    M = new I(Q.mul(M.X, W), M.Y, M.Z)
    T = t0(H, T)
    M = t0(Z, M)
    return T.add(M)
  }
  class I {
    constructor(W, T, M) {
      this.X = b('x', W)
      this.Y = b('y', T, true)
      this.Z = b('z', M)
      Object.freeze(this)
    }
    static CURVE() {
      return z
    }
    static fromAffine(W) {
      const { x: T, y: M } = W || {}
      if (!W || !Q.isValid(T) || !Q.isValid(M)) {
        throw new Error('invalid affine point')
      }
      if (W instanceof I) {
        throw new Error('projective point not allowed')
      }
      if (Q.is0(T) && Q.is0(M)) {
        return I.ZERO
      }
      return new I(T, M, Q.ONE)
    }
    static fromBytes(W) {
      const T = I.fromAffine(x(O0(W, undefined, 'point')))
      T.assertValidity()
      return T
    }
    static fromHex(W) {
      return I.fromBytes(m('pointHex', W))
    }
    get x() {
      return this.toAffine().x
    }
    get y() {
      return this.toAffine().y
    }
    precompute(W = 8, T = true) {
      S.createCache(this, W)
      if (!T) {
        this.multiply(B8)
      }
      return this
    }
    assertValidity() {
      C0(this)
    }
    hasEvenY() {
      const { y: W } = this.toAffine()
      if (!Q.isOdd) {
        throw new Error("Field doesn't support isOdd")
      }
      return !Q.isOdd(W)
    }
    equals(W) {
      n(W)
      const { X: T, Y: M, Z: H } = this
      const { X: Z, Y: D, Z: C } = W
      const O = Q.eql(Q.mul(T, C), Q.mul(Z, H))
      const B = Q.eql(Q.mul(M, C), Q.mul(D, H))
      return O && B
    }
    negate() {
      return new I(this.X, Q.neg(this.Y), this.Z)
    }
    double() {
      const { a: W, b: T } = z
      const M = Q.mul(T, B8)
      const { X: H, Y: Z, Z: D } = this
      let { ZERO: C, ZERO: O, ZERO: B } = Q
      let R = Q.mul(H, H)
      const g = Q.mul(Z, Z)
      let k = Q.mul(D, D)
      let w = Q.mul(H, Z)
      w = Q.add(w, w)
      B = Q.mul(H, D)
      B = Q.add(B, B)
      C = Q.mul(W, B)
      O = Q.mul(M, k)
      O = Q.add(C, O)
      C = Q.sub(g, O)
      O = Q.add(g, O)
      O = Q.mul(C, O)
      C = Q.mul(w, C)
      B = Q.mul(M, B)
      k = Q.mul(W, k)
      w = Q.sub(R, k)
      w = Q.mul(W, w)
      w = Q.add(w, B)
      B = Q.add(R, R)
      R = Q.add(B, R)
      R = Q.add(R, k)
      R = Q.mul(R, w)
      O = Q.add(O, R)
      k = Q.mul(Z, D)
      k = Q.add(k, k)
      R = Q.mul(k, w)
      C = Q.sub(C, R)
      B = Q.mul(k, g)
      B = Q.add(B, B)
      B = Q.add(B, B)
      return new I(C, O, B)
    }
    add(W) {
      n(W)
      const { X: T, Y: M, Z: H } = this
      const { X: Z, Y: D, Z: C } = W
      let { ZERO: O, ZERO: B, ZERO: R } = Q
      const g = z.a
      const k = Q.mul(z.b, B8)
      let w = Q.mul(T, Z)
      let P = Q.mul(M, D)
      let v = Q.mul(H, C)
      let _ = Q.add(T, M)
      let y = Q.add(Z, D)
      _ = Q.mul(_, y)
      y = Q.add(w, P)
      _ = Q.sub(_, y)
      y = Q.add(T, H)
      let u = Q.add(Z, C)
      y = Q.mul(y, u)
      u = Q.add(w, v)
      y = Q.sub(y, u)
      u = Q.add(M, H)
      O = Q.add(D, C)
      u = Q.mul(u, O)
      O = Q.add(P, v)
      u = Q.sub(u, O)
      R = Q.mul(g, y)
      O = Q.mul(k, v)
      R = Q.add(O, R)
      O = Q.sub(P, R)
      R = Q.add(P, R)
      B = Q.mul(O, R)
      P = Q.add(w, w)
      P = Q.add(P, w)
      v = Q.mul(g, v)
      y = Q.mul(k, y)
      P = Q.add(P, v)
      v = Q.sub(w, v)
      v = Q.mul(g, v)
      y = Q.add(y, v)
      w = Q.mul(P, y)
      B = Q.add(B, w)
      w = Q.mul(u, y)
      O = Q.mul(_, O)
      O = Q.sub(O, w)
      w = Q.mul(_, P)
      R = Q.mul(u, R)
      R = Q.add(R, w)
      return new I(O, B, R)
    }
    subtract(W) {
      return this.add(W.negate())
    }
    is0() {
      return this.equals(I.ZERO)
    }
    multiply(W) {
      const { endo: T } = J
      if (!G.isValidNot0(W)) {
        throw new Error('invalid scalar: out of range')
      }
      let M
      let H
      const Z = (D) => S.cached(this, D, (C) => C8(I, C))
      if (T) {
        const { k1neg: D, k1: C, k2neg: O, k2: B } = c(W)
        const { p: R, f: g } = Z(C)
        const { p: k, f: w } = Z(B)
        H = g.add(w)
        M = G0(T.beta, R, k, D, O)
      } else {
        const { p: D, f: C } = Z(W)
        M = D
        H = C
      }
      return C8(I, [M, H])[0]
    }
    multiplyUnsafe(W) {
      const { endo: T } = J
      if (!G.isValid(W)) {
        throw new Error('invalid scalar: out of range')
      }
      if (W === W0 || this.is0()) {
        return I.ZERO
      }
      if (W === y0) {
        return this
      }
      if (S.hasCache(this)) {
        return this.multiply(W)
      }
      if (T) {
        const { k1neg: H, k1: Z, k2neg: D, k2: C } = c(W)
        const { p1: O, p2: B } = f$(I, this, Z, C)
        return G0(T.beta, O, B, H, D)
      } else {
        return S.unsafe(this, W)
      }
    }
    multiplyAndAddUnsafe(W, T, M) {
      const H = this.multiplyUnsafe(T).add(W.multiplyUnsafe(M))
      if (H.is0()) {
        return undefined
      } else {
        return H
      }
    }
    toAffine(W) {
      return s(this, W)
    }
    isTorsionFree() {
      const { isTorsionFree: W } = J
      if (U === y0) {
        return true
      }
      if (W) {
        return W(I, this)
      }
      return S.unsafe(this, Y).is0()
    }
    clearCofactor() {
      const { clearCofactor: W } = J
      if (U === y0) {
        return this
      }
      if (W) {
        return W(I, this)
      }
      return this.multiplyUnsafe(U)
    }
    isSmallOrder() {
      return this.multiplyUnsafe(U).is0()
    }
    toBytes(W = true) {
      i0(W, 'isCompressed')
      this.assertValidity()
      return K(I, this, W)
    }
    toHex(W = true) {
      return Z0(this.toBytes(W))
    }
    toString() {
      return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`
    }
    get px() {
      return this.X
    }
    get py() {
      return this.X
    }
    get pz() {
      return this.Z
    }
    toRawBytes(W = true) {
      return this.toBytes(W)
    }
    _setWindowSize(W) {
      this.precompute(W)
    }
    static normalizeZ(W) {
      return C8(I, W)
    }
    static msm(W, T) {
      return _$(I, G, W, T)
    }
    static fromPrivateKey(W) {
      return I.BASE.multiply(L0(G, W))
    }
  }
  I.BASE = new I(z.Gx, z.Gy, Q.ONE)
  I.ZERO = new I(Q.ZERO, Q.ONE, Q.ZERO)
  I.Fp = Q
  I.Fn = G
  const X0 = G.BITS
  const S = new i8(I, J.endo ? Math.ceil(X0 / 2) : X0)
  I.BASE.precompute(8)
  return I
}
function m$($) {
  return Uint8Array.of($ ? 2 : 3)
}
function F$($, J) {
  return {
    secretKey: J.BYTES,
    publicKey: 1 + $.BYTES,
    publicKeyUncompressed: 1 + $.BYTES * 2,
    publicKeyHasPrefix: true,
    signature: J.BYTES * 2
  }
}
function hQ($, J = {}) {
  const { Fn: q } = $
  const Q = J.randomBytes || P0
  const G = Object.assign(F$($.Fp, q), {
    seed: d8(q.ORDER)
  })
  function z(K) {
    try {
      return !!L0(q, K)
    } catch (_x) {
      return false
    }
  }
  function U(K, x) {
    const { publicKey: A, publicKeyUncompressed: E } = G
    try {
      const f = K.length
      if (x === true && f !== A) {
        return false
      }
      if (x === false && f !== E) {
        return false
      }
      return !!$.fromBytes(K)
    } catch (_f) {
      return false
    }
  }
  function Y(K = Q(G.seed)) {
    return V8(O0(K, G.seed, 'seed'), q.ORDER)
  }
  function X(K, x = true) {
    return $.BASE.multiply(L0(q, K)).toBytes(x)
  }
  function V(K) {
    const x = Y(K)
    return {
      secretKey: x,
      publicKey: X(x)
    }
  }
  function N(K) {
    if (typeof K === 'bigint') {
      return false
    }
    if (K instanceof $) {
      return true
    }
    const { secretKey: x, publicKey: A, publicKeyUncompressed: E } = G
    if (q.allowedLengths || x === A) {
      return
    }
    const f = m('key', K).length
    return f === A || f === E
  }
  function L(K, x, A = true) {
    if (N(K) === true) {
      throw new Error('first arg must be private key')
    }
    if (N(x) === false) {
      throw new Error('second arg must be public key')
    }
    const E = L0(q, K)
    return $.fromHex(x).multiply(E).toBytes(A)
  }
  return Object.freeze({
    getPublicKey: X,
    getSharedSecret: L,
    keygen: V,
    Point: $,
    utils: {
      isValidSecretKey: z,
      isValidPublicKey: U,
      randomSecretKey: Y,
      isValidPrivateKey: z,
      randomPrivateKey: Y,
      normPrivateKeyToScalar: (K) => L0(q, K),
      precompute(K = 8, x = $.BASE) {
        return x.precompute(K, false)
      }
    },
    lengths: G
  })
}
function lQ($, J, q = {}) {
  Y8(J)
  s0(
    q,
    {},
    {
      hmac: 'function',
      lowS: 'boolean',
      randomBytes: 'function',
      bits2int: 'function',
      bits2int_modN: 'function'
    }
  )
  const Q = q.randomBytes || P0
  const G = q.hmac || ((M, ...H) => b8(J, M, o(...H)))
  const { Fp: z, Fn: U } = $
  const { ORDER: Y, BITS: X } = U
  const {
    keygen: V,
    getPublicKey: N,
    getSharedSecret: L,
    utils: j,
    lengths: K
  } = hQ($, q)
  const x = {
    prehash: false,
    lowS: typeof q.lowS === 'boolean' ? q.lowS : false,
    format: undefined,
    extraEntropy: false
  }
  const A = 'compact'
  function E(M) {
    const H = Y >> y0
    return M > H
  }
  function f(M, H) {
    if (!U.isValidNot0(H)) {
      throw new Error(`invalid signature ${M}: out of range 1..Point.Fn.ORDER`)
    }
    return H
  }
  function q0(M, H) {
    n8(H)
    const Z = K.signature
    const D = H === 'compact' ? Z : H === 'recovered' ? Z + 1 : undefined
    return O0(M, D, `${H} signature`)
  }
  class b {
    constructor(M, H, Z) {
      this.r = f('r', M)
      this.s = f('s', H)
      if (Z != null) {
        this.recovery = Z
      }
      Object.freeze(this)
    }
    static fromBytes(M, H = A) {
      q0(M, H)
      let Z
      if (H === 'der') {
        const { r: B, s: R } = D0.toSig(O0(M))
        return new b(B, R)
      }
      if (H === 'recovered') {
        Z = M[0]
        H = 'compact'
        M = M.subarray(1)
      }
      const D = U.BYTES
      const C = M.subarray(0, D)
      const O = M.subarray(D, D * 2)
      return new b(U.fromBytes(C), U.fromBytes(O), Z)
    }
    static fromHex(M, H) {
      return b.fromBytes(S0(M), H)
    }
    addRecoveryBit(M) {
      return new b(this.r, this.s, M)
    }
    recoverPublicKey(M) {
      const H = z.ORDER
      const { r: Z, s: D, recovery: C } = this
      if (C == null || ![0, 1, 2, 3].includes(C)) {
        throw new Error('recovery id invalid')
      }
      if (Y * u$ < H && C > 1) {
        throw new Error('recovery id is ambiguous for h>1 curve')
      }
      const B = C === 2 || C === 3 ? Z + Y : Z
      if (!z.isValid(B)) {
        throw new Error('recovery id 2 or 3 invalid')
      }
      const R = z.toBytes(B)
      const g = $.fromBytes(o(m$((C & 1) === 0), R))
      const k = U.inv(B)
      const w = c(m('msgHash', M))
      const P = U.create(-w * k)
      const v = U.create(D * k)
      const _ = $.BASE.multiplyUnsafe(P).add(g.multiplyUnsafe(v))
      if (_.is0()) {
        throw new Error('point at infinify')
      }
      _.assertValidity()
      return _
    }
    hasHighS() {
      return E(this.s)
    }
    toBytes(M = A) {
      n8(M)
      if (M === 'der') {
        return S0(D0.hexFromSig(this))
      }
      const H = U.toBytes(this.r)
      const Z = U.toBytes(this.s)
      if (M === 'recovered') {
        if (this.recovery == null) {
          throw new Error('recovery bit must be present')
        }
        return o(Uint8Array.of(this.recovery), H, Z)
      }
      return o(H, Z)
    }
    toHex(M) {
      return Z0(this.toBytes(M))
    }
    assertValidity() {}
    static fromCompact(M) {
      return b.fromBytes(m('sig', M), 'compact')
    }
    static fromDER(M) {
      return b.fromBytes(m('sig', M), 'der')
    }
    normalizeS() {
      if (this.hasHighS()) {
        return new b(this.r, U.neg(this.s), this.recovery)
      } else {
        return this
      }
    }
    toDERRawBytes() {
      return this.toBytes('der')
    }
    toDERHex() {
      return Z0(this.toBytes('der'))
    }
    toCompactRawBytes() {
      return this.toBytes('compact')
    }
    toCompactHex() {
      return Z0(this.toBytes('compact'))
    }
  }
  const n =
    q.bits2int ||
    function M(H) {
      if (H.length > 8192) {
        throw new Error('input is too large')
      }
      const Z = M0(H)
      const D = H.length * 8 - X
      if (D > 0) {
        return Z >> BigInt(D)
      } else {
        return Z
      }
    }
  const c =
    q.bits2int_modN ||
    function M(H) {
      return U.create(n(H))
    }
  const s = x0(X)
  function C0(M) {
    V$(`num < 2^${X}`, M, W0, s)
    return U.toBytes(M)
  }
  function G0(M, H) {
    O0(M, undefined, 'message')
    if (H) {
      return O0(J(M), undefined, 'prehashed message')
    } else {
      return M
    }
  }
  function I(M, H, Z) {
    if (['recovered', 'canonical'].some((v) => v in Z)) {
      throw new Error('sign() legacy options not supported')
    }
    const { lowS: D, prehash: C, extraEntropy: O } = a8(Z, x)
    M = G0(M, C)
    const B = c(M)
    const R = L0(U, H)
    const g = [C0(R), C0(B)]
    if (O != null && O !== false) {
      const v = O === true ? Q(K.secretKey) : O
      g.push(m('extraEntropy', v))
    }
    const k = o(...g)
    const w = B
    function P(v) {
      const _ = n(v)
      if (!U.isValidNot0(_)) {
        return
      }
      const y = U.inv(_)
      const u = $.BASE.multiply(_).toAffine()
      const F = U.create(u.x)
      if (F === W0) {
        return
      }
      const t = U.create(y * U.create(w + F * R))
      if (t === W0) {
        return
      }
      let z0 = (u.x === F ? 0 : 2) | Number(u.y & y0)
      let p = t
      if (D && E(t)) {
        p = U.neg(t)
        z0 ^= 1
      }
      return new b(F, p, z0)
    }
    return {
      seed: k,
      k2sig: P
    }
  }
  function X0(M, H, Z = {}) {
    M = m('message', M)
    const { seed: D, k2sig: C } = I(M, H, Z)
    return C$(J.outputLen, U.BYTES, G)(D, C)
  }
  function S(M) {
    let H
    const Z = typeof M === 'string' || I0(M)
    const D =
      !Z &&
      M !== null &&
      typeof M === 'object' &&
      typeof M.r === 'bigint' &&
      typeof M.s === 'bigint'
    if (!Z && !D) {
      throw new Error(
        'invalid signature, expected Uint8Array, hex string or Signature instance'
      )
    }
    if (D) {
      H = new b(M.r, M.s)
    } else if (Z) {
      try {
        H = b.fromBytes(m('sig', M), 'der')
      } catch (C) {
        if (!(C instanceof D0.Err)) {
          throw C
        }
      }
      if (!H) {
        try {
          H = b.fromBytes(m('sig', M), 'compact')
        } catch (_C) {
          return false
        }
      }
    }
    if (!H) {
      return false
    }
    return H
  }
  function W(M, H, Z, D = {}) {
    const { lowS: C, prehash: O, format: B } = a8(D, x)
    Z = m('publicKey', Z)
    H = G0(m('message', H), O)
    if ('strict' in D) {
      throw new Error('options.strict was renamed to lowS')
    }
    const R = B === undefined ? S(M) : b.fromBytes(m('sig', M), B)
    if (R === false) {
      return false
    }
    try {
      const g = $.fromBytes(Z)
      if (C && R.hasHighS()) {
        return false
      }
      const { r: k, s: w } = R
      const P = c(H)
      const v = U.inv(w)
      const _ = U.create(P * v)
      const y = U.create(k * v)
      const u = $.BASE.multiplyUnsafe(_).add(g.multiplyUnsafe(y))
      if (u.is0()) {
        return false
      }
      return U.create(u.x) === k
    } catch (_g) {
      return false
    }
  }
  function T(M, H, Z = {}) {
    const { prehash: D } = a8(Z, x)
    H = G0(H, D)
    return b.fromBytes(M, 'recovered').recoverPublicKey(H).toBytes()
  }
  return Object.freeze({
    keygen: V,
    getPublicKey: N,
    getSharedSecret: L,
    utils: j,
    lengths: K,
    Point: $,
    sign: X0,
    verify: W,
    recoverPublicKey: T,
    Signature: b,
    hash: J
  })
}
function cQ($) {
  const J = {
    a: $.a,
    b: $.b,
    p: $.Fp.ORDER,
    n: $.n,
    h: $.h,
    Gx: $.Gx,
    Gy: $.Gy
  }
  const q = $.Fp
  const Q = $.allowedPrivateKeyLengths
    ? Array.from(
        new Set($.allowedPrivateKeyLengths.map((U) => Math.ceil(U / 2)))
      )
    : undefined
  const G = T0(J.n, {
    BITS: $.nBitLength,
    allowedLengths: Q,
    modFromBytes: $.wrapPrivateKey
  })
  const z = {
    Fp: q,
    Fn: G,
    allowInfinityPoint: $.allowInfinityPoint,
    endo: $.endo,
    isTorsionFree: $.isTorsionFree,
    clearCofactor: $.clearCofactor,
    fromBytes: $.fromBytes,
    toBytes: $.toBytes
  }
  return {
    CURVE: J,
    curveOpts: z
  }
}
function dQ($) {
  const { CURVE: J, curveOpts: q } = cQ($)
  const Q = {
    hmac: $.hmac,
    randomBytes: $.randomBytes,
    lowS: $.lowS,
    bits2int: $.bits2int,
    bits2int_modN: $.bits2int_modN
  }
  return {
    CURVE: J,
    curveOpts: q,
    hash: $.hash,
    ecdsaOpts: Q
  }
}
function oQ($, J) {
  const q = J.Point
  return Object.assign({}, J, {
    ProjectivePoint: q,
    CURVE: Object.assign({}, $, N8(q.Fn.ORDER, q.Fn.BITS))
  })
}
function h$($) {
  const { CURVE: J, curveOpts: q, hash: Q, ecdsaOpts: G } = dQ($)
  const z = FQ(J, q)
  const U = lQ(z, Q, G)
  return oQ($, U)
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var g$ = ($, J) => ($ + ($ >= 0 ? J : -J) / u$) / J
class y$ extends Error {
  constructor($ = '') {
    super($)
  }
}
var D0 = {
  Err: y$,
  _tlv: {
    encode: ($, J) => {
      const { Err: q } = D0
      if ($ < 0 || $ > 256) {
        throw new q('tlv.encode: wrong tag')
      }
      if (J.length & 1) {
        throw new q('tlv.encode: unpadded data')
      }
      const Q = J.length / 2
      const G = a0(Q)
      if ((G.length / 2) & 128) {
        throw new q('tlv.encode: long form length too big')
      }
      const z = Q > 127 ? a0((G.length / 2) | 128) : ''
      return a0($) + z + G + J
    },
    decode($, J) {
      const { Err: q } = D0
      let Q = 0
      if ($ < 0 || $ > 256) {
        throw new q('tlv.encode: wrong tag')
      }
      if (J.length < 2 || J[Q++] !== $) {
        throw new q('tlv.decode: wrong tlv')
      }
      const G = J[Q++]
      const z = !!(G & 128)
      let U = 0
      if (!z) {
        U = G
      } else {
        const X = G & 127
        if (!X) {
          throw new q('tlv.decode(long): indefinite length not supported')
        }
        if (X > 4) {
          throw new q('tlv.decode(long): byte length is too big')
        }
        const V = J.subarray(Q, Q + X)
        if (V.length !== X) {
          throw new q('tlv.decode: length bytes not complete')
        }
        if (V[0] === 0) {
          throw new q('tlv.decode(long): zero leftmost byte')
        }
        for (const N of V) {
          U = (U << 8) | N
        }
        Q += X
        if (U < 128) {
          throw new q('tlv.decode(long): not minimal encoding')
        }
      }
      const Y = J.subarray(Q, Q + U)
      if (Y.length !== U) {
        throw new q('tlv.decode: wrong value length')
      }
      return {
        v: Y,
        l: J.subarray(Q + U)
      }
    }
  },
  _int: {
    encode($) {
      const { Err: J } = D0
      if ($ < W0) {
        throw new J('integer: negative integers are not allowed')
      }
      let q = a0($)
      if (Number.parseInt(q[0], 16) & 8) {
        q = `00${q}`
      }
      if (q.length & 1) {
        throw new J('unexpected DER parsing assertion: unpadded hex')
      }
      return q
    },
    decode($) {
      const { Err: J } = D0
      if ($[0] & 128) {
        throw new J('invalid signature integer: negative')
      }
      if ($[0] === 0 && !($[1] & 128)) {
        throw new J('invalid signature integer: unnecessary leading zero')
      }
      return M0($)
    }
  },
  toSig($) {
    const { Err: J, _int: q, _tlv: Q } = D0
    const G = m('signature', $)
    const { v: z, l: U } = Q.decode(48, G)
    if (U.length) {
      throw new J('invalid signature: left bytes after parsing')
    }
    const { v: Y, l: X } = Q.decode(2, z)
    const { v: V, l: N } = Q.decode(2, X)
    if (N.length) {
      throw new J('invalid signature: left bytes after parsing')
    }
    return {
      r: q.decode(Y),
      s: q.decode(V)
    }
  },
  hexFromSig($) {
    const { _tlv: J, _int: q } = D0
    const Q = J.encode(2, q.encode($.r))
    const G = J.encode(2, q.encode($.s))
    const z = Q + G
    return J.encode(48, z)
  }
}
var W0 = BigInt(0)
var y0 = BigInt(1)
var u$ = BigInt(2)
var B8 = BigInt(3)
var mQ = BigInt(4)
function l$($, J) {
  const q = (Q) =>
    h$({
      ...$,
      hash: Q
    })
  return {
    ...q(J),
    create: q
  }
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function iQ($) {
  const J = u0.p
  const q = BigInt(3)
  const Q = BigInt(6)
  const G = BigInt(11)
  const z = BigInt(22)
  const U = BigInt(23)
  const Y = BigInt(44)
  const X = BigInt(88)
  const V = ($ * $ * $) % J
  const N = (V * V * $) % J
  const L = (a(N, q, J) * N) % J
  const j = (a(L, q, J) * N) % J
  const K = (a(j, s8, J) * V) % J
  const x = (a(K, G, J) * K) % J
  const A = (a(x, z, J) * x) % J
  const E = (a(A, Y, J) * A) % J
  const f = (a(E, X, J) * E) % J
  const q0 = (a(f, Y, J) * A) % J
  const b = (a(q0, q, J) * N) % J
  const n = (a(b, U, J) * x) % J
  const c = (a(n, Q, J) * V) % J
  const s = a(c, s8, J)
  if (!H8.eql(H8.sqr(s), $)) {
    throw new Error('Cannot find square root')
  }
  return s
}
function O8($, ...J) {
  let q = d$[$]
  if (q === undefined) {
    const Q = M8(K8($))
    q = o(Q, Q)
    d$[$] = q
  }
  return M8(o(q, ...J))
}
function t8($) {
  const { Fn: J, BASE: q } = m0
  const Q = L0(J, $)
  const G = q.multiply(Q)
  return {
    scalar: $$(G.y) ? Q : J.neg(Q),
    bytes: e8(G)
  }
}
function p$($) {
  const J = H8
  if (!J.isValidNot0($)) {
    throw new Error('invalid x: Fail if x ≥ p')
  }
  const q = J.create($ * $)
  const Q = J.create(q * $ + BigInt(7))
  let G = J.sqrt(Q)
  if (!$$(G)) {
    G = J.neg(G)
  }
  const z = m0.fromAffine({
    x: $,
    y: G
  })
  z.assertValidity()
  return z
}
function i$(...$) {
  return m0.Fn.create(e0(O8('BIP0340/challenge', ...$)))
}
function o$($) {
  return t8($).bytes
}
function aQ($, J, q = P0(32)) {
  const { Fn: Q } = m0
  const G = m('message', $)
  const { bytes: z, scalar: U } = t8(J)
  const Y = m('auxRand', q, 32)
  const X = Q.toBytes(U ^ e0(O8('BIP0340/aux', Y)))
  const V = O8('BIP0340/nonce', X, z, G)
  const { bytes: N, scalar: L } = t8(V)
  const j = i$(N, z, G)
  const K = new Uint8Array(64)
  K.set(N, 0)
  K.set(Q.toBytes(Q.create(L + j * U)), 32)
  if (!a$(K, G, z)) {
    throw new Error('sign: Invalid signature produced')
  }
  return K
}
function a$($, J, q) {
  const { Fn: Q, BASE: G } = m0
  const z = m('signature', $, 64)
  const U = m('message', J)
  const Y = m('publicKey', q, 32)
  try {
    const X = p$(e0(Y))
    const V = e0(z.subarray(0, 32))
    if (!n0(V, c$, u0.p)) {
      return false
    }
    const N = e0(z.subarray(32, 64))
    if (!n0(N, c$, u0.n)) {
      return false
    }
    const L = i$(Q.toBytes(V), e8(X), U)
    const j = G.multiplyUnsafe(N).add(X.multiplyUnsafe(Q.neg(L)))
    const { x: K, y: x } = j.toAffine()
    if (j.is0() || !$$(x) || K !== V) {
      return false
    }
    return true
  } catch (_X) {
    return false
  }
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var u0 = {
  p: BigInt(
    '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'
  ),
  n: BigInt(
    '0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'
  ),
  h: BigInt(1),
  a: BigInt(0),
  b: BigInt(7),
  Gx: BigInt(
    '0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'
  ),
  Gy: BigInt(
    '0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8'
  )
}
var rQ = {
  beta: BigInt(
    '0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'
  ),
  basises: [
    [
      BigInt('0x3086d221a7d46bcde86c90e49284eb15'),
      -BigInt('0xe4437ed6010e88286f547fa90abfe4c3')
    ],
    [
      BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8'),
      BigInt('0x3086d221a7d46bcde86c90e49284eb15')
    ]
  ]
}
var pQ = BigInt(0)
var c$ = BigInt(1)
var s8 = BigInt(2)
var H8 = T0(u0.p, {
  sqrt: iQ
})
var r$ = l$(
  {
    ...u0,
    Fp: H8,
    lowS: true,
    endo: rQ
  },
  M8
)
var d$ = {}
var e8 = ($) => $.toBytes(true).slice(1)
var m0 = (() => r$.Point)()
var $$ = ($) => $ % s8 === pQ
var e0 = M0
var x8 = (() => {
  const q = (G = P0(48)) => {
    return V8(G, u0.n)
  }
  r$.utils.randomSecretKey
  function Q(G) {
    const z = q(G)
    return {
      secretKey: z,
      publicKey: o$(z)
    }
  }
  return {
    keygen: Q,
    getPublicKey: o$,
    sign: aQ,
    verify: a$,
    Point: m0,
    utils: {
      randomSecretKey: q,
      randomPrivateKey: q,
      taggedHash: O8,
      lift_x: p$,
      pointToBytes: e8,
      numberToBytesBE: b0,
      bytesToNumberBE: M0,
      mod: i
    },
    lengths: {
      secretKey: 32,
      publicKey: 32,
      publicKeyHasPrefix: false,
      signature: 64,
      seed: 48
    }
  }
})()
var nQ = new TextEncoder()
var sQ = new TextDecoder()
var j0 = ($) => nQ.encode($)
var f0 = ($) => sQ.decode($)
var T8 = ($) => Array.from($, (J) => J.toString(16).padStart(2, '0')).join('')
var e = JSON.stringify
var R0 = JSON.parse
var L8 = ($, J = Number.MAX_SAFE_INTEGER) =>
  $.split('').reduce((q, Q) => q + Q.charCodeAt(0), 0) % J
var Q$ = 'AES-GCM'
var tQ = {}
var n$ = '$'
var s$ = ','
var eQ = ($) => {
  const J = new Uint8Array($)
  let Q = ''
  for (let G = 0; G < J.length; G += 32768) {
    Q += String.fromCharCode(...J.subarray(G, G + 32768))
  }
  return btoa(Q)
}
var $J = ($) => Uint8Array.from(atob($), (J) => J.charCodeAt(0)).buffer
var $8 = ($) =>
  (tQ[$] ??= crypto.subtle.digest('SHA-1', j0($)).then((J) => {
    const q = new Uint8Array(J)
    let Q = ''
    for (const G of q) {
      Q += G.toString(36)
    }
    return Q
  }))
var t$ = async ($, J, q) => {
  const Q = await crypto.subtle.digest('SHA-256', j0(`${$}:${J}:${q}`))
  return crypto.subtle.importKey(
    'raw',
    Q,
    {
      name: Q$
    },
    false,
    ['encrypt', 'decrypt']
  )
}
var e$ = async ($, J) => {
  const q = crypto.getRandomValues(new Uint8Array(12))
  const Q = await $
  const G = await crypto.subtle.encrypt(
    {
      name: Q$,
      iv: q
    },
    Q,
    j0(J)
  )
  return `${q.join(s$)}${n$}${eQ(G)}`
}
var $Q = async ($, J) => {
  const [q, Q] = J.split(n$)
  if (!q || !Q) {
    throw new Error('Invalid encrypted payload format')
  }
  const G = Uint8Array.from(q.split(s$), Number)
  const z = await $
  const U = await crypto.subtle.decrypt(
    {
      name: Q$,
      iv: G
    },
    z,
    $J(Q)
  )
  return f0(U)
}
var r = 'GenosRTC'
var F0 = ($, J) =>
  Array.from(
    {
      length: $
    },
    J
  )
var Q8 = ($) =>
  Array.from(
    crypto.getRandomValues(new Uint8Array($)),
    (J) =>
      '0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz'[
        J %
          '0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz'
            .length
      ]
  ).join('')
var N0 = Q8(20)
var V0 = Promise.all.bind(Promise)
var QQ = typeof window !== 'undefined'
var { entries: JQ, fromEntries: R8, keys: J1 } = Object
var qQ = () => {}
var J0 = ($) => new Error(`GenosRTC: ${$}`)
var J8 = (...$) => $.join('@')
var GQ = ($, J) => {
  const q = [...$]
  let Q = q.length
  const G = () => {
    const z = Math.sin(J++) * 10000
    return z - Math.floor(z)
  }
  while (Q) {
    const z = Math.floor(G() * Q--)
    ;[q[Q], q[z]] = [q[z], q[Q]]
  }
  return q
}
var QJ = 5000
var zQ = 'icegatheringstatechange'
var UQ = 'offer'
var JJ = 'answer'
var qJ = [
  ...F0(3, (_$, J) => `stun:stun${J || ''}.l.google.com:19302`),
  'stun:stun.cloudflare.com:3478'
].map(($) => ({
  urls: $
}))
var A8 = ($, { rtcConfig: J, rtcPolyfill: q, turnConfig: Q }) => {
  const G = new (q || RTCPeerConnection)({
    iceServers: [...qJ, ...(Q || [])],
    ...J
  })
  const z = {}
  let U = false
  let Y = false
  let X
  const V = (j) =>
    Object.assign(j, {
      binaryType: 'arraybuffer',
      bufferedAmountLowThreshold: 65535,
      onmessage: (K) => z.data?.(K.data),
      onopen: () => z.connect?.(),
      onclose: () => z.close?.(),
      onerror: (K) =>
        !K?.error?.message?.includes('User-Initiated Abort') && z.error?.(K)
    })
  const N = () =>
    Promise.race([
      new Promise((j) => {
        const K = () => {
          if (G.iceGatheringState === 'complete') {
            G.removeEventListener(zQ, K)
            j()
          }
        }
        G.addEventListener(zQ, K)
        K()
      }),
      new Promise((j) => setTimeout(j, QJ))
    ]).then(() => ({
      type: G.localDescription.type,
      sdp: G.localDescription.sdp.replace(/a=ice-options:trickle\s\n/g, '')
    }))
  if ($) {
    V((X = G.createDataChannel('data')))
  } else {
    G.ondatachannel = ({ channel: j }) => V((X = j))
  }
  G.onnegotiationneeded = async () => {
    try {
      U = true
      await G.setLocalDescription()
      z.signal?.(await N())
    } catch (j) {
      z.error?.(j)
    } finally {
      U = false
    }
  }
  G.onconnectionstatechange = () => {
    if (['disconnected', 'failed', 'closed'].includes(G.connectionState)) {
      z.close?.()
    }
  }
  G.ontrack = (j) => {
    z.track?.(j.track, j.streams[0])
    z.stream?.(j.streams[0])
  }
  G.onremovestream = (j) => z.stream?.(j.stream)
  if ($ && !G.canTrickleIceCandidates) {
    G.onnegotiationneeded()
  }
  const L = () => G.getSenders()
  return {
    created: Date.now(),
    connection: G,
    get channel() {
      return X
    },
    get isDead() {
      return G.connectionState === 'closed'
    },
    async signal(j) {
      if (X?.readyState === 'open' && !j.sdp?.includes('a=rtpmap')) {
        return
      }
      try {
        if (j.type === UQ) {
          if (U || (G.signalingState !== 'stable' && !Y)) {
            if ($) {
              return
            }
            await V0([
              G.setLocalDescription({
                type: 'rollback'
              }),
              G.setRemoteDescription(j)
            ])
          } else {
            await G.setRemoteDescription(j)
          }
          await G.setLocalDescription()
          const K = await N()
          z.signal?.(K)
          return K
        }
        if (j.type === JJ) {
          Y = true
          try {
            await G.setRemoteDescription(j)
          } finally {
            Y = false
          }
        }
      } catch (K) {
        z.error?.(K)
      }
    },
    sendData: (j) => X.send(j),
    destroy: () => {
      X?.close()
      G.close()
      U = Y = false
    },
    setHandlers: (j) => Object.assign(z, j),
    offerPromise: $
      ? new Promise((j) => (z.signal = (K) => K.type === UQ && j(K)))
      : Promise.resolve(),
    addStream: (j) => j.getTracks().forEach((K) => G.addTrack(K, j)),
    removeStream: (j) =>
      L()
        .filter((K) => j.getTracks().includes(K.track))
        .forEach((K) => G.removeTrack(K)),
    addTrack: (j, K) => G.addTrack(j, K),
    removeTrack: (j) => {
      const K = L().find((x) => x.track === j)
      if (K) {
        G.removeTrack(K)
      }
    },
    replaceTrack: (j, K) =>
      L()
        .find((x) => x.track === j)
        ?.replaceTrack(K)
  }
}
var GJ = Object.getPrototypeOf(Uint8Array)
var I8 = 12
var jQ = 0
var k8 = jQ + I8
var S8 = k8 + 1
var G8 = S8 + 1
var z8 = G8 + 1
var q8 = 16384 - z8
var w8 = 255
var J$ = 'bufferedamountlow'
var h0 = ($) => `@_${$}`
var q$ = 100
var zJ = 3
var UJ = 200
var XQ = ($, J, q) => {
  const Q = new Map()
  const G = new Map()
  const z = new Map()
  const U = {}
  const Y = {}
  const X = {}
  const V = {}
  const N = new Map()
  const L = (Z, D) => {
    if (!N.has(Z)) {
      N.set(Z, new Set())
    }
    N.get(Z).add(D)
  }
  const j = (Z, D) => N.get(Z)?.delete(D)
  const K = (Z, ...D) => N.get(Z)?.forEach((C) => C(...D))
  const x = (Z, D) => {
    const C = Z ? (Array.isArray(Z) ? Z : [Z]) : Q.keys()
    return Array.from(C, (O) => {
      const B = Q.get(O)
      if (!B) {
        console.warn(`${r}: no peer with id ${O}`)
        return null
      }
      return D(O, B)
    }).filter(Boolean)
  }
  const A = (Z) => {
    if (!Q.has(Z)) {
      return
    }
    Q.delete(Z)
    delete U[Z]
    delete Y[Z]
    delete X[Z]
    delete V[Z]
    K('peer:leave', Z)
    J(Z)
  }
  const E = (Z) =>
    new Promise((D, C) => {
      const O = setTimeout(() => {
        Z.removeEventListener(J$, B)
        C(new Error(`${r}: bufferLow timeout`))
      }, 5000)
      function B() {
        clearTimeout(O)
        Z.removeEventListener(J$, B)
        D()
      }
      Z.addEventListener(J$, B)
    })
  const f = (Z) => {
    if (z.has(Z)) {
      return z.get(Z)
    }
    if (!Z) {
      throw J0('action type is required')
    }
    const D = j0(Z)
    if (D.byteLength > I8) {
      throw J0(`\u274C "${Z}" exceeds ${I8} bytes. Use a shorter name.`)
    }
    const C = new Uint8Array(I8).map((_P, v) => D[v] || 0)
    let O = 0
    const B = new Map([
      ['message', new Set()],
      ['progress', new Set()]
    ])
    const R = (P, v) => B.get(P)?.add(v)
    const g = (P, v) => B.get(P)?.delete(v)
    const k = async (P, v, _, y) => {
      if (_ && typeof _ !== 'object') {
        throw J0('meta must be object')
      }
      if (P === undefined) {
        throw J0('data cannot be undefined')
      }
      const u = P instanceof Blob
      const F = u || P instanceof ArrayBuffer || P instanceof GJ
      const t = typeof P !== 'string'
      if (_ && !F) {
        throw J0('meta only allowed with binary')
      }
      const z0 = F
        ? new Uint8Array(u ? await P.arrayBuffer() : P)
        : j0(t ? e(P) : P)
      const p = _ ? j0(e(_)) : null
      const d = Math.ceil(z0.byteLength / q8) + (_ ? 1 : 0) || 1
      if (d > q$) {
        throw J0(`Message too large, exceeds max chunks ${q$}`)
      }
      const j$ = F0(d, (_j8, U0) => {
        const d0 = U0 === d - 1
        const A0 = _ && U0 === 0
        const X8 = A0
          ? p
          : z0.subarray(
              _ ? (U0 - 1) * q8 : U0 * q8,
              _ ? U0 * q8 : (U0 + 1) * q8
            )
        const B0 = new Uint8Array(z8 + X8.byteLength)
        B0.set(C)
        B0.set([O], k8)
        B0.set([d0 | (A0 << 1) | (F << 2) | (t << 3)], S8)
        B0.set([Math.round(((U0 + 1) / d) * w8)], G8)
        B0.set(X8, z8)
        return B0
      })
      O = (O + 1) & w8
      return V0(
        x(v, async (j8, U0) => {
          const { channel: d0 } = U0
          for (let A0 = 0; A0 < d; A0++) {
            let X8 = 0
            while (d0.bufferedAmount > d0.bufferedAmountLowThreshold) {
              if (X8++ > zJ) {
                throw J0(
                  `${r}: send buffer full, max retries reached for peer ${j8}`
                )
              }
              try {
                await E(d0)
              } catch (B0) {
                console.warn(B0.message)
                await new Promise((AQ) => setTimeout(AQ, UJ))
              }
            }
            if (!Q.has(j8)) {
              break
            }
            U0.sendData(j$[A0])
            y?.(j$[A0][G8] / w8, j8, _)
          }
        })
      )
    }
    G.set(Z, {
      listeners: B,
      send: k
    })
    const w = {
      send: k,
      on: R,
      off: g
    }
    z.set(Z, w)
    return w
  }
  const q0 = (Z, D) => {
    try {
      const C = new Uint8Array(D)
      const O = f0(C.subarray(jQ, k8)).replace(/ /g, '')
      if (!G.has(O)) {
        return console.warn(`${r}: unregistered type (${O})`)
      }
      const [B] = C.subarray(k8, S8)
      const [R] = C.subarray(S8, G8)
      const [g] = C.subarray(G8, z8)
      const k = C.subarray(z8)
      const w = Boolean(R & 1)
      const P = Boolean(R & 2)
      const v = Boolean(R & 4)
      const _ = Boolean(R & 8)
      const y = G.get(O)
      const u = ((U[Z] ||= {})[O] ||= {})
      if (u[B]?.chunks?.length > q$) {
        console.warn(
          `${r}: peer ${Z} sent too many chunks for nonce ${B}, ignoring.`
        )
        return
      }
      const F = (u[B] ||= {
        chunks: []
      })
      if (P) {
        try {
          F.meta = R0(f0(k))
        } catch {
          console.warn(
            `${r}: failed to parse meta from peer ${Z} for type ${O}`
          )
          return
        }
      } else {
        F.chunks.push(k)
      }
      y.listeners.get('progress').forEach((p) => {
        try {
          p(g / w8, Z, F.meta)
        } catch (d) {
          console.error(d)
        }
      })
      if (!w) {
        return
      }
      const t = new Uint8Array(F.chunks.reduce((p, d) => p + d.byteLength, 0))
      F.chunks.reduce((p, d) => {
        t.set(d, p)
        return p + d.byteLength
      }, 0)
      delete u[B]
      let z0
      if (v) {
        z0 = t
      } else if (_) {
        try {
          z0 = R0(f0(t))
        } catch {
          console.warn(
            `${r}: failed to parse JSON message data from peer ${Z} for type ${O}`
          )
          return
        }
      } else {
        z0 = f0(t)
      }
      y.listeners.get('message').forEach((p) => {
        try {
          p(z0, Z, F.meta)
        } catch (d) {
          console.error(d)
        }
      })
    } catch (C) {
      console.error(`${r}: error handling data from peer ${Z}:`, C)
    }
  }
  const b = async () => {
    try {
      await M('')
      await new Promise((Z) => setTimeout(Z, 99))
    } catch (Z) {
      console.warn(`${r}: error sending leave`, Z)
    }
    for (const [Z, D] of Q) {
      try {
        D.destroy()
      } catch {}
      Q.delete(Z)
    }
    q()
  }
  const { send: n, on: c } = f(h0('ping'))
  const { send: s, on: C0 } = f(h0('pong'))
  const { send: G0, on: I } = f(h0('signal'))
  const { send: X0, on: S } = f(h0('stream'))
  const { send: W, on: T } = f(h0('track'))
  const { send: M, on: H } = f(h0('leave'))
  $((Z, D) => {
    if (Q.has(D)) {
      return
    }
    Q.set(D, Z)
    Z.setHandlers({
      data: (C) => q0(D, C),
      stream: (C) => {
        K('stream:add', C, D, X[D])
        delete X[D]
      },
      track: (C, O) => {
        K('track:add', C, O, D, V[D])
        delete V[D]
      },
      signal: (C) => G0(C, D),
      close: () => A(D),
      error: (C) => {
        console.error(`${r}: peer error for ${D}`, C)
        A(D)
      }
    })
    K('peer:join', D)
  })
  c('message', (_Z, D) => s('', D))
  C0('message', (_Z, D) => {
    Y[D]?.()
    delete Y[D]
  })
  I('message', (Z, D) => Q.get(D)?.signal(Z))
  S('message', (Z, D) => (X[D] = Z))
  T('message', (Z, D) => (V[D] = Z))
  H('message', (_Z, D) => A(D))
  if (QQ) {
    addEventListener('beforeunload', b)
  }
  return {
    on: L,
    off: j,
    channel: f,
    leave: b,
    ping: async (Z) => {
      if (!Z) {
        throw J0('ping() requires target peer ID')
      }
      const D = Date.now()
      n('', Z)
      await new Promise((C) => (Y[Z] = C))
      return Date.now() - D
    },
    getPeers: () => R8(Array.from(Q, ([Z, D]) => [Z, D.connection])),
    addStream: (Z, D, C) =>
      x(D, async (O, B) => {
        if (C) {
          await X0(C, O)
        }
        B.addStream(Z)
      }),
    removeStream: (Z, D) => x(D, (_C, O) => O.removeStream(Z)),
    addTrack: (Z, D, C, O) =>
      x(C, async (B, R) => {
        if (O) {
          await W(O, B)
        }
        R.addTrack(Z, D)
      }),
    removeTrack: (Z, D) => x(D, (_C, O) => O.removeTrack(Z)),
    replaceTrack: (Z, D, C, O) =>
      x(C, async (B, R) => {
        if (O) {
          await W(O, B)
        }
        R.replaceTrack(Z, D)
      })
  }
}
var jJ = 20
var XJ = 5333
var YQ = 57333
var ZQ = ({ init: $, subscribe: J, announce: q }) => {
  const Q = {}
  let G = false
  let z
  let U
  return (Y, X, V) => {
    const { appId: N } = Y
    if (Q[N]?.[X]) {
      return Q[N][X]
    }
    if (!Y || !X || (!N && !Y.firebaseApp)) {
      throw J0(
        !Y ? 'config required' : !X ? 'roomId required' : 'appId missing'
      )
    }
    let L = qQ
    if (!G) {
      const S = $(Y)
      U = F0(jJ, () => A8(true, Y))
      z = Array.isArray(S) ? S : [S]
      const W = setInterval(() => {
        U = U.filter((T) => {
          const M = Date.now() - T.created < YQ
          if (!M) {
            T.destroy()
          }
          return M
        })
      }, YQ)
      Q.offerCleanupTimer ||= W
      G = true
    }
    const j = {}
    const K = {}
    const x = J8(r, N, X)
    const A = $8(x)
    const E = $8(J8(x, N0))
    const f = t$(Y.password || '', N, X)
    const q0 = (S) => async (W) => ({
      type: W.type,
      sdp: await S(f, W.sdp)
    })
    const b = q0($Q)
    const n = q0(e$)
    const c = (S, W) => {
      if (K[W] === S) {
        return
      }
      K[W]?.destroy()
      K[W] = S
      L(S, W)
      j[W]?.forEach((T) => T !== S && T.destroy())
      delete j[W]
    }
    const s = (S, W) => {
      if (K[W] === S) {
        delete K[W]
      }
    }
    const C0 = (S) => async (W, T, M) => {
      const [H, Z] = await V0([A, E])
      if (W !== H && W !== Z) {
        return
      }
      const {
        peerId: D,
        offer: C,
        answer: O
      } = typeof T === 'string' ? R0(T) : T
      if (D === N0 || K[D]) {
        return
      }
      if (C) {
        if (j[D]?.[S] && N0 > D) {
          return
        }
        const B = A8(false, Y)
        B.setHandlers({
          connect: () => c(B, D),
          close: () => s(B, D)
        })
        try {
          const R = await b(C)
          if (B.isDead) {
            return
          }
          const [g, k] = await V0([$8(J8(x, D)), B.signal(R).then(n)])
          M(
            g,
            e({
              peerId: N0,
              answer: k
            })
          )
        } catch {
          V?.({
            error: 'decryption failed (offer)',
            appId: N,
            peerId: D,
            roomId: X
          })
        }
      } else if (O) {
        const B = j[D]?.[S]
        if (!B || B.isDead) {
          return
        }
        B.setHandlers({
          connect: () => c(B, D),
          close: () => s(B, D)
        })
        try {
          B.signal(await b(O))
        } catch {
          V?.({
            error: 'decryption failed (answer)',
            appId: N,
            peerId: D,
            roomId: X
          })
        }
      } else {
        if (j[D]?.[S]) {
          return
        }
        const B = U.pop() || A8(true, Y)
        const [R, { offer: g }] = await V0([
          $8(J8(x, D)),
          B.offerPromise.then(n).then((k) => ({
            offer: k
          }))
        ])
        j[D] ||= []
        j[D][S] = B
        B.setHandlers({
          connect: () => c(B, D),
          close: () => s(B, D)
        })
        M(
          R,
          e({
            peerId: N0,
            offer: g,
            peer: B
          })
        )
      }
    }
    const G0 = V0(z.map(async (S, W) => J(await S, await A, await E, C0(W))))
    const I = []
    G0.then((S) => {
      z.forEach((W, T) => {
        const M = async () => {
          const H = await q(await W, await A, await E)
          I[T] = setTimeout(M, typeof H === 'number' ? H : XJ)
        }
        M()
      })
      Q[N][X].onCleanup = () => {
        delete Q[N][X]
        I.forEach(clearTimeout)
        S.forEach((W) => W())
        if (Object.keys(Q).length === 0) {
          clearInterval(Q.offerCleanupTimer)
          delete Q.offerCleanupTimer
        }
      }
    })
    Q[N] ||= {}
    const X0 = XQ(
      (S) => (L = S),
      (S) => delete K[S],
      () => X0.onCleanup?.()
    )
    return (Q[N][X] = X0)
  }
}
var KQ = 3333
var P8 = {}
var MQ = {}
var G$ = ($, J) => {
  const q = {}
  let Q = null
  const G = () => {
    if (Q) {
      clearTimeout(Q)
      Q = null
    }
    const z = new WebSocket($)
    z.onclose = () => {
      P8[$] ??= KQ
      Q = setTimeout(G, P8[$])
      P8[$] *= 2
    }
    z.onmessage = (U) => J(U.data)
    q.socket = z
    q.url = z.url
    q.ready = new Promise((U) => {
      z.onopen = () => {
        P8[$] = KQ
        U(q)
      }
    })
    q.send = (U) => {
      if (z.readyState === 1) {
        z.send(U)
      }
    }
  }
  q.forceReconnect = G
  G()
  MQ[$] = q
  return q
}
if (typeof window !== 'undefined') {
  const $ = () => {
    console.info('⚡ [GenosRTC] Network event detected. Forcing reconnection…')
    Object.values(MQ).forEach((J) => {
      if (
        J.socket &&
        J.socket.readyState !== WebSocket.OPEN &&
        J.socket.readyState !== WebSocket.CONNECTING
      ) {
        J.forceReconnect()
      }
    })
  }
  window.addEventListener('online', () => {
    console.info('✅ Reconnected to the network.')
    $()
  })
  window.addEventListener('offline', async () => {
    console.info('❌ Disconnected from the network.')
  })
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible') {
      $()
    }
  })
}
var DQ = ($) => () => R8(JQ($).map(([J, q]) => [J, q.socket]))
var z$ = ($, J, q, Q) =>
  ($.relayUrls ?? (Q ? GQ(J, L8($.appId)) : J)).slice(
    0,
    $.relayUrls?.length ?? $.relayRedundancy ?? q
  )
async function RQ() {
  try {
    const $ = JSON.parse(localStorage.getItem(U8) ?? '[]')
    const J = await fetch('https://api.nostr.watch/v1/online')
      .then((q) => (q.ok ? q.json() : null))
      .catch(() => null)
    if (J?.length) {
      localStorage.setItem(U8, JSON.stringify([...new Set([...$, ...J])]))
    }
  } catch {}
}
var c0 = {}
var CQ = 5
var BQ = 'x'
var U$ = 'EVENT'
var HQ = /pow: (\d+) bits needed\.?/
var E8 = new Set()
var OQ = x8.utils.randomSecretKey()
var YJ = T8(x8.getPublicKey(OQ))
var v8 = {}
var l0 = {}
var ZJ = {}
var xQ = () => Math.floor(Date.now() / 1000)
var TQ = ($) => (ZJ[$] ??= L8($, 10000) + 20000)
var LQ = [
  'wss://black.nostrcity.club',
  'wss://eu.purplerelay.com',
  'wss://ftp.halifax.rwth-aachen.de/nostr',
  'wss://nostr.cool110.xyz',
  'wss://nostr.data.haus',
  'wss://nostr.mom',
  'wss://nostr.oxtr.dev',
  'wss://nostr.sathoarder.com',
  'wss://nostr.vulpem.com',
  'wss://relay.agorist.space',
  'wss://relay.binaryrobot.com',
  'wss://relay.fountain.fm',
  'wss://relay.mostro.network',
  'wss://relay.nostraddress.com',
  'wss://relay.nostrdice.com',
  'wss://relay.nostromo.social',
  'wss://relay.oldenburg.cool',
  'wss://relay.snort.social',
  'wss://relay.verified-nostr.com',
  'wss://sendit.nosflare.com',
  'wss://yabu.me/v2',
  'wss://relay.damus.io'
]
var U8 = 'genosrtc_fallback_relays'
if (!localStorage.getItem(U8)) {
  localStorage.setItem(U8, JSON.stringify(LQ))
}
RQ()
setInterval(RQ, 7200000)
var KJ = ($, J, q) => {
  const Q = Math.min(3000, Math.max(500, 3000 - q * 200))
  setTimeout(() => {
    z$($, J, CQ, true).forEach((G) => {
      if (c0[G]) {
        return
      }
      const z = G$(G, (U) => {
        const [Y, X, V, N] = R0(U)
        if (Y !== U$) {
          if (Y === 'NOTICE' || (Y === 'OK' && !V)) {
            if ((Y === 'NOTICE' ? X : N).match(HQ)?.[1] > 0) {
              E8.add(G.replace(/\/$/, ''))
              z.close?.()
              delete c0[G]
            }
          }
          return
        }
        l0[X]?.(v8[X], V.content)
      })
      c0[G] = z
    })
  }, Q)
}
var WQ = async ($, J) => {
  const q = {
    kind: TQ($),
    content: J,
    pubkey: YJ,
    created_at: xQ(),
    tags: [[BQ, $]]
  }
  const Q = new Uint8Array(
    await crypto.subtle.digest(
      'SHA-256',
      j0(e([0, q.pubkey, q.created_at, q.kind, q.tags, q.content]))
    )
  )
  const G = x8.sign(Q, OQ)
  return e([
    U$,
    {
      ...q,
      id: T8(Q),
      sig: T8(G)
    }
  ])
}
var NQ = ($, J) => {
  v8[$] = J
  return e([
    'REQ',
    $,
    {
      kinds: [TQ(J)],
      since: xQ(),
      [`#${BQ}`]: [J]
    }
  ])
}
var VQ = ($) => {
  delete v8[$]
  return e(['CLOSE', $])
}
var MJ = ZQ({
  init: ($) => {
    const J = $?.relayUrls?.length ? $.relayUrls : null
    const q = J ?? LQ
    const Q = JSON.parse(localStorage.getItem(U8) ?? '[]')
    if (J) {
      console.log('[GenosRTC] Using user relay list.')
    }
    const G = z$($, q, CQ, true).map((z) => {
      const U = G$(z, (Y) => {
        const [X, V, N, L] = R0(Y)
        if (X !== U$) {
          if (X === 'NOTICE' || (X === 'OK' && !N)) {
            if ((X === 'NOTICE' ? V : L).match(HQ)?.[1] > 0) {
              E8.add(z.replace(/\/$/, ''))
              U.close?.()
              delete c0[z]
            }
          }
          return
        }
        l0[V]?.(v8[V], N.content)
      })
      c0[z] = U
      return U.ready.then(() => U)
    })
    KJ($, Q, q.length)
    return G
  },
  subscribe: ($, J, q, Q) => {
    const G = Q8(64)
    const z = Q8(64)
    l0[G] = l0[z] = (U, Y) =>
      Q(U, Y, async (X, V) => {
        if (E8.has($.url.replace(/\/$/, ''))) {
          return
        }
        $.send(await WQ(X, V))
      })
    $.send(NQ(G, J))
    $.send(NQ(z, q))
    return () => {
      $.send(VQ(G))
      $.send(VQ(z))
      delete l0[G]
      delete l0[z]
    }
  },
  announce: async ($, J) => {
    if (E8.has($.url.replace(/\/$/, ''))) {
      return
    }
    $.send(
      await WQ(
        J,
        e({
          peerId: N0
        })
      )
    )
  }
})
var DJ = DQ(c0)
export { N0 as selfId, MJ as join, DJ as getRelaySockets }
