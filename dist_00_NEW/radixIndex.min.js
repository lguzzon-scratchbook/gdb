function createRadixIndex(options = {}) {
  let index = {}
  let fragmentedIndexes = {}
  const maxSize = options.maxSize || 1048576
  const encode = options.encode
  const decode = options.decode
  const pako = options.pako
  function upsert(documentId, documentValue) {
    extractPrefixes(documentValue).forEach((prefix) => {
      if (!index[prefix]) {
        index[prefix] = []
      }
      if (!index[prefix].includes(documentId)) {
        index[prefix].push(documentId)
      }
    })
    if (JSON.stringify(index).length > maxSize) {
      splitIndex()
    }
  }
  function remove(documentId, documentValue) {
    extractPrefixes(documentValue).forEach((prefix) => {
      if (index[prefix]) {
        index[prefix] = index[prefix].filter((docId) => docId !== documentId)
        if (index[prefix].length === 0) {
          delete index[prefix]
        }
      }
    })
  }
  function extractPrefixes(documentValue) {
    const prefixes = []
    if (typeof documentValue === 'string') {
      for (let index = 1; index <= documentValue.length; index++) {
        prefixes.push(documentValue.substring(0, index))
      }
    } else if (typeof documentValue === 'number') {
      prefixes.push(String(documentValue))
    } else if (typeof documentValue === 'object' && documentValue !== null) {
      Object.keys(documentValue).forEach((key) => {
        prefixes.push(key.toString())
        const value = documentValue[key]
        if (typeof value === 'string' || typeof value === 'number') {
          prefixes.push(`${key}:${value}`)
        }
      })
    }
    return prefixes
  }
  function splitIndex() {
    const keys = Object.keys(index)
    const splitPoint = Math.ceil(keys.length / 2)
    const fragment1 = {}
    const fragment2 = {}
    keys.slice(0, splitPoint).forEach((key) => {
      fragment1[key] = index[key]
    })
    keys.slice(splitPoint).forEach((key) => {
      fragment2[key] = index[key]
    })
    fragmentedIndexes.fragment1 = fragment1
    fragmentedIndexes.fragment2 = fragment2
    index = {}
  }
  function mergeFragments() {
    for (const fragment of Object.values(fragmentedIndexes)) {
      Object.assign(index, fragment)
    }
    fragmentedIndexes = {}
  }
  function searchByPrefix(prefix) {
    return index[prefix] || []
  }
  function searchAllByPrefix(prefix) {
    return Object.keys(index)
      .filter((key) => key.startsWith(prefix))
      .flatMap((key) => index[key])
  }
  function serialize() {
    if (!encode || !pako) {
      throw new Error('Radix: encode y pako deben estar en options')
    }
    const data = {
      index: index,
      fragmentedIndexes: fragmentedIndexes
    }
    return pako.deflate(encode(data))
  }
  function deserialize(data) {
    if (!decode || !pako) {
      throw new Error('Radix: decode y pako deben estar en options')
    }
    const inflatedData = pako.inflate(new Uint8Array(data))
    const parsedData = decode(inflatedData)
    index = parsedData.index || {}
    fragmentedIndexes = parsedData.fragmentedIndexes || {}
  }
  function validateIndex() {
    if (JSON.stringify(index).length > maxSize) {
      throw new Error('Index too large')
    }
    if (!index || typeof index !== 'object') {
      index = {}
    }
  }
  return {
    upsert: upsert,
    remove: remove,
    extractPrefixes: extractPrefixes,
    splitIndex: splitIndex,
    mergeFragments: mergeFragments,
    searchByPrefix: searchByPrefix,
    searchAllByPrefix: searchAllByPrefix,
    serialize: serialize,
    deserialize: deserialize,
    validateIndex: validateIndex
  }
}
function createRadixIndexer(options) {
  const { worker: workerInstance, encode, decode, pako } = options
  const radixIndex = createRadixIndex({
    maxSize: options.maxSize || 1048576,
    encode: encode,
    decode: decode,
    pako: pako
  })
  const indexFilename = options.indexFileName || 'graph_radix_index.msgpack'
  const debouncedSave = ((callback, delay) => {
    let timeoutHandler
    return (...args) => {
      clearTimeout(timeoutHandler)
      timeoutHandler = setTimeout(() => callback.apply(null, args), delay)
    }
  })(() => saveIndex(), 200)
  async function loadIndex() {
    try {
      const indexData = await new Promise((resolve, reject) => {
        const messageHandler = (event) => {
          if (
            event.data.type === 'loaded' &&
            event.data.name === indexFilename
          ) {
            workerInstance.removeEventListener('message', messageHandler)
            resolve(new Uint8Array(event.data.data))
          } else if (event.data.type === 'error') {
            workerInstance.removeEventListener('message', messageHandler)
            reject(
              new Error(event.data.message || 'Error loading the Radix index')
            )
          }
        }
        workerInstance.addEventListener('message', messageHandler)
        workerInstance.postMessage({
          type: 'load',
          name: indexFilename
        })
      })
      if (indexData.byteLength > 0) {
        radixIndex.deserialize(indexData)
      }
    } catch {}
  }
  async function saveIndex() {
    try {
      const serializedData = radixIndex.serialize()
      await new Promise((resolve, reject) => {
        const messageHandler = (event) => {
          if (
            event.data.type === 'saved' &&
            event.data.name === indexFilename
          ) {
            workerInstance.removeEventListener('message', messageHandler)
            resolve()
          } else if (event.data.type === 'error') {
            workerInstance.removeEventListener('message', messageHandler)
            reject(
              new Error(event.data.message || 'Error saving the Radix index')
            )
          }
        }
        workerInstance.addEventListener('message', messageHandler)
        workerInstance.postMessage({
          type: 'save',
          name: indexFilename,
          content: serializedData
        })
      })
    } catch {}
  }
  async function build() {
    try {
      radixIndex.validateIndex()
      ;(typeof options.graph?.getAllNodes === 'function'
        ? await options.graph.getAllNodes()
        : Object.values(options.graph.nodes)
      ).forEach((document) => {
        radixIndex.upsert(document.id, document.value)
      })
    } catch {}
  }
  async function updateIndex(documentId, documentValue, operation = 'insert') {
    switch (operation) {
      case 'insert':
        radixIndex.upsert(documentId, documentValue)
        break
      case 'remove':
        radixIndex.remove(documentId, documentValue)
        break
    }
    debouncedSave()
  }
  function searchByPrefix(prefix) {
    return radixIndex.searchAllByPrefix(prefix)
  }
  return {
    ready: loadIndex().then(build),
    updateIndex: updateIndex,
    searchByPrefix: searchByPrefix
  }
}
function withRadixIndexModule(moduleConfig) {
  const radixIndexer = createRadixIndexer(moduleConfig)
  const originalPut = moduleConfig.put
  moduleConfig.put = async function (key, location) {
    const existingDoc = location ? this.graph.get(location) : null
    const result = await originalPut.call(this, key, location)
    if (existingDoc) {
      await radixIndexer.updateIndex(result, existingDoc.value, 'remove')
    }
    await radixIndexer.updateIndex(result, key, 'insert')
    return result
  }
  const originalRemove = moduleConfig.remove
  moduleConfig.remove = async function (key) {
    const document = this.graph.get(key)
    await originalRemove.call(this, key)
    if (document) {
      await radixIndexer.updateIndex(key, document.value, 'remove')
    }
  }
  const originalMap = moduleConfig.map
  moduleConfig.map = async function (...args) {
    const result = await originalMap.call(this, ...args)
    const queryObject = args.find((arg) => typeof arg === 'object')
    if (queryObject?.query?.id?.$startsWith) {
      const prefix = queryObject.query.id.$startsWith
      const matchingIds = radixIndexer.searchByPrefix(prefix)
      return result.filter((item) => matchingIds.includes(item.id))
    }
    return result
  }
  moduleConfig.searchByPrefix = async function (prefix) {
    return radixIndexer.searchByPrefix(prefix).map((id) => this.graph.get(id))
  }
  return moduleConfig
}
var initRadixIndex = (moduleConfig) => {
  console.log('ðŸŒ³ RadixIndexer module loaded.')
  return withRadixIndexModule(moduleConfig)
}
export {
  withRadixIndexModule as withModule,
  initRadixIndex as init,
  createRadixIndexer as RadixIndexer
}
