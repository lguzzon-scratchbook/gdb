var globalCrypto =
  typeof globalThis === 'object' && 'crypto' in globalThis
    ? globalThis.crypto
    : undefined
function isUint8Array(input) {
  return (
    input instanceof Uint8Array ||
    (ArrayBuffer.isView(input) && input.constructor.name === 'Uint8Array')
  )
}
function validatePositiveInteger(value) {
  if (!Number.isSafeInteger(value) || value < 0) {
    throw new Error(`positive integer expected, got ${value}`)
  }
}
function validateUint8Array(input, ...validLengths) {
  if (!isUint8Array(input)) {
    throw new Error('Uint8Array expected')
  }
  if (validLengths.length > 0 && !validLengths.includes(input.length)) {
    throw new Error(
      `Uint8Array expected of length ${validLengths}, got length=${input.length}`
    )
  }
}
function _validateHasher(hasher) {
  if (typeof hasher !== 'function' || typeof hasher.create !== 'function') {
    throw new Error('Hash should be wrapped by utils.createHasher')
  }
  validatePositiveInteger(hasher.outputLen)
  validatePositiveInteger(hasher.blockLen)
}
function _checkHashState(hashInstance, checkFinished = true) {
  if (hashInstance.destroyed) {
    throw new Error('Hash instance has been destroyed')
  }
  if (checkFinished && hashInstance.finished) {
    throw new Error('Hash#digest() has already been called')
  }
}
function _validateDigestOutput(outputBuffer, hashInstance) {
  validateUint8Array(outputBuffer)
  const expectedLength = hashInstance.outputLen
  if (outputBuffer.length < expectedLength) {
    throw new Error(
      `digestInto() expects output buffer of length at least ${expectedLength}`
    )
  }
}
function clearArrays(...arrays) {
  for (let i = 0; i < arrays.length; i++) {
    arrays[i].fill(0)
  }
}
function _createDataView(uint8Array) {
  return new DataView(
    uint8Array.buffer,
    uint8Array.byteOffset,
    uint8Array.byteLength
  )
}
function rotl32(value, shift) {
  return (value << (32 - shift)) | (value >>> shift)
}
function _bytesToHex(bytes) {
  validateUint8Array(bytes)
  if (nativeHexSupport) {
    return bytes.toHex()
  }
  let hex = ''
  for (let i = 0; i < bytes.length; i++) {
    hex += hexLookupTable[bytes[i]]
  }
  return hex
}
function hexCharToValue(charCode) {
  if (charCode >= hexChars._0 && charCode <= hexChars._9) {
    return charCode - hexChars._0
  }
  if (charCode >= hexChars.A && charCode <= hexChars.F) {
    return charCode - (hexChars.A - 10)
  }
  if (charCode >= hexChars.a && charCode <= hexChars.f) {
    return charCode - (hexChars.a - 10)
  }
  return
}
function _hexToBytes(hexString) {
  if (typeof hexString !== 'string') {
    throw new Error(`hex string expected, got ${typeof hexString}`)
  }
  if (nativeHexSupport) {
    return Uint8Array.fromHex(hexString)
  }
  const length = hexString.length
  const byteLength = length / 2
  if (length % 2) {
    throw new Error(`hex string expected, got unpadded hex of length ${length}`)
  }
  const result = new Uint8Array(byteLength)
  for (let i = 0, pos = 0; i < byteLength; i++, pos += 2) {
    const highNibble = hexCharToValue(hexString.charCodeAt(pos))
    const lowNibble = hexCharToValue(hexString.charCodeAt(pos + 1))
    if (highNibble === undefined || lowNibble === undefined) {
      const invalidChar = hexString[pos] + hexString[pos + 1]
      throw new Error(
        `hex string expected, got non-hex character "${invalidChar}" at index ${pos}`
      )
    }
    result[i] = highNibble * 16 + lowNibble
  }
  return result
}
function stringToBytes(input) {
  if (typeof input !== 'string') {
    throw new Error('string expected')
  }
  return new Uint8Array(new TextEncoder().encode(input))
}
function normalizeBytes(input) {
  if (typeof input === 'string') {
    input = stringToBytes(input)
  }
  validateUint8Array(input)
  return input
}
function _concatBytes(...arrays) {
  let totalLength = 0
  for (let i = 0; i < arrays.length; i++) {
    const array = arrays[i]
    validateUint8Array(array)
    totalLength += array.length
  }
  const result = new Uint8Array(totalLength)
  for (let i = 0, offset = 0; i < arrays.length; i++) {
    const array = arrays[i]
    result.set(array, offset)
    offset += array.length
  }
  return result
}
function wrapHasher(hasherFactory) {
  const hash = (data) => hasherFactory().update(normalizeBytes(data)).digest()
  const hasherInstance = hasherFactory()
  hash.outputLen = hasherInstance.outputLen
  hash.blockLen = hasherInstance.blockLen
  hash.create = () => hasherFactory()
  return hash
}
function _getRandomBytes(length = 32) {
  if (globalCrypto && typeof globalCrypto.getRandomValues === 'function') {
    return globalCrypto.getRandomValues(new Uint8Array(length))
  }
  if (globalCrypto && typeof globalCrypto.randomBytes === 'function') {
    return Uint8Array.from(globalCrypto.randomBytes(length))
  }
  throw new Error('crypto.getRandomValues must be defined')
} /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var nativeHexSupport = (() =>
  typeof Uint8Array.from([]).toHex === 'function' &&
  typeof Uint8Array.fromHex === 'function')()
var hexLookupTable = Array.from(
  {
    length: 256
  },
  (_, index) => index.toString(16).padStart(2, '0')
)
var hexChars = {
  _0: 48,
  _9: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
}
class HashBase {}
function _setBigUint64LE(dataView, offset, value, isLittleEndian) {
  if (typeof dataView.setBigUint64 === 'function') {
    return dataView.setBigUint64(offset, value, isLittleEndian)
  }
  const shiftBits = BigInt(32)
  const mask32 = BigInt(4294967295)
  const highWord = Number((value >> shiftBits) & mask32)
  const lowWord = Number(value & mask32)
  const highOffset = isLittleEndian ? 4 : 0
  const lowOffset = isLittleEndian ? 0 : 4
  dataView.setUint32(offset + highOffset, highWord, isLittleEndian)
  dataView.setUint32(offset + lowOffset, lowWord, isLittleEndian)
}
function ch(x, y, z) {
  return (x & y) ^ (~x & z)
}
function maj(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z)
}
class SHA2 extends HashBase {
  constructor($, J, q, Q) {
    super()
    this.finished = false
    this.length = 0
    this.pos = 0
    this.destroyed = false
    this.blockLen = $
    this.outputLen = J
    this.padOffset = q
    this.isLE = Q
    this.buffer = new Uint8Array($)
    this.view = X8(this.buffer)
  }
  update($) {
    b0(this)
    $ = o0($)
    $0($)
    const { view: J, buffer: q, blockLen: Q } = this
    const G = $.length
    for (let z = 0; z < G; ) {
      const U = Math.min(Q - this.pos, G - z)
      if (U === Q) {
        const X = X8($)
        for (; Q <= G - z; z += Q) {
          this.process(X, z)
        }
        continue
      }
      q.set($.subarray(z, z + U), this.pos)
      this.pos += U
      z += U
      if (this.pos === Q) {
        this.process(J, 0)
        this.pos = 0
      }
    }
    this.length += $.length
    this.roundClean()
    return this
  }
  digestInto($) {
    b0(this)
    U$($, this)
    this.finished = true
    const { buffer: J, view: q, blockLen: Q, isLE: G } = this
    let { pos: z } = this
    J[z++] = 128
    I0(this.buffer.subarray(z))
    if (this.padOffset > Q - z) {
      this.process(q, 0)
      z = 0
    }
    for (let N = z; N < Q; N++) {
      J[N] = 0
    }
    RQ(q, Q - 8, BigInt(this.length * 8), G)
    this.process(q, 0)
    const U = X8($)
    const X = this.outputLen
    if (X % 4) {
      throw new Error('_sha2: outputLen should be aligned to 32bit')
    }
    const Z = X / 4
    const V = this.get()
    if (Z > V.length) {
      throw new Error('_sha2: outputLen bigger than state')
    }
    for (let N = 0; N < Z; N++) {
      U.setUint32(N * 4, V[N], G)
    }
  }
  digest() {
    const { buffer: $, outputLen: J } = this
    this.digestInto($)
    const q = $.slice(0, J)
    this.destroy()
    return q
  }
  _cloneInto($) {
    $ ||= new this.constructor()
    $.set(...this.get())
    const {
      blockLen: J,
      buffer: q,
      length: Q,
      finished: G,
      destroyed: z,
      pos: U
    } = this
    $.destroyed = z
    $.finished = G
    $.length = Q
    $.pos = U
    if (Q % J) {
      $.buffer.set(q)
    }
    return $
  }
  clone() {
    return this._cloneInto()
  }
}
var SHA256_INIT = Uint32Array.from([
  1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924,
  528734635, 1541459225
])
var SHA256_K = Uint32Array.from([
  1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
  2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
  1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774,
  264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
  2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711,
  113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
  1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
  3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
  430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063,
  1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474,
  2756734187, 3204031479, 3329325298
])
var messageSchedule = new Uint32Array(64)
class SHA256 extends SHA2 {
  constructor(outputLen = 32) {
    super(64, outputLen, 8, false)
    this.A = SHA256_INIT[0] | 0
    this.B = SHA256_INIT[1] | 0
    this.C = SHA256_INIT[2] | 0
    this.D = SHA256_INIT[3] | 0
    this.E = SHA256_INIT[4] | 0
    this.F = SHA256_INIT[5] | 0
    this.G = SHA256_INIT[6] | 0
    this.H = SHA256_INIT[7] | 0
  }
  get() {
    const { A: a, B: b, C: c, D: d, E: e, F: f, G: g, H: h } = this
    return [a, b, c, d, e, f, g, h]
  }
  set(a, b, c, d, e, f, g, h) {
    this.A = a | 0
    this.B = b | 0
    this.C = c | 0
    this.D = d | 0
    this.E = e | 0
    this.F = f | 0
    this.G = g | 0
    this.H = h | 0
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4) {
      messageSchedule[i] = view.getUint32(offset, false)
    }
    for (let i = 16; i < 64; i++) {
      const s0 = messageSchedule[i - 15]
      const s1 = messageSchedule[i - 2]
      const sigma0 = rotl32(s0, 7) ^ rotl32(s0, 18) ^ (s0 >>> 3)
      const sigma1 = rotl32(s1, 17) ^ rotl32(s1, 19) ^ (s1 >>> 10)
      messageSchedule[i] =
        (sigma1 + messageSchedule[i - 7] + sigma0 + messageSchedule[i - 16]) | 0
    }
    let { A: a, B: b, C: c, D: d, E: e, F: f, G: g, H: h } = this
    for (let i = 0; i < 64; i++) {
      const S1 = rotl32(e, 6) ^ rotl32(e, 11) ^ rotl32(e, 25)
      const chValue =
        (h + S1 + ch(e, f, g) + SHA256_K[i] + messageSchedule[i]) | 0
      const majValue =
        ((rotl32(a, 2) ^ rotl32(a, 13) ^ rotl32(a, 22)) + maj(a, b, c)) | 0
      h = g
      g = f
      f = e
      e = (d + chValue) | 0
      d = c
      c = b
      b = a
      a = (chValue + majValue) | 0
    }
    a = (a + this.A) | 0
    b = (b + this.B) | 0
    c = (c + this.C) | 0
    d = (d + this.D) | 0
    e = (e + this.E) | 0
    f = (f + this.F) | 0
    g = (g + this.G) | 0
    h = (h + this.H) | 0
    this.set(a, b, c, d, e, f, g, h)
  }
  roundClean() {
    clearArrays(messageSchedule)
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0)
    clearArrays(this.buffer)
  }
}
var _sha256 = wrapHasher(() => new SHA256())
class HMAC extends HashBase {
  constructor($, J) {
    super()
    this.finished = false
    this.destroyed = false
    Y8($)
    const q = o0(J)
    this.iHash = $.create()
    if (typeof this.iHash.update !== 'function') {
      throw new Error('Expected instance of class which extends utils.Hash')
    }
    this.blockLen = this.iHash.blockLen
    this.outputLen = this.iHash.outputLen
    const Q = this.blockLen
    const G = new Uint8Array(Q)
    G.set(q.length > Q ? $.create().update(q).digest() : q)
    for (let z = 0; z < G.length; z++) {
      G[z] ^= 54
    }
    this.iHash.update(G)
    this.oHash = $.create()
    for (let z = 0; z < G.length; z++) {
      G[z] ^= 106
    }
    this.oHash.update(G)
    I0(G)
  }
  update($) {
    b0(this)
    this.iHash.update($)
    return this
  }
  digestInto($) {
    b0(this)
    $0($, this.outputLen)
    this.finished = true
    this.iHash.digestInto($)
    this.oHash.update($)
    this.oHash.digestInto($)
    this.destroy()
  }
  digest() {
    const $ = new Uint8Array(this.oHash.outputLen)
    this.digestInto($)
    return $
  }
  _cloneInto($) {
    $ ||= Object.create(Object.getPrototypeOf(this), {})
    const {
      oHash: J,
      iHash: q,
      finished: Q,
      destroyed: G,
      blockLen: z,
      outputLen: U
    } = this
    $ = $
    $.finished = Q
    $.destroyed = G
    $.blockLen = z
    $.outputLen = U
    $.oHash = J._cloneInto($.oHash)
    $.iHash = q._cloneInto($.iHash)
    return $
  }
  clone() {
    return this._cloneInto()
  }
  destroy() {
    this.destroyed = true
    this.oHash.destroy()
    this.iHash.destroy()
  }
}
var _hmac = (hasher, key, data) => new HMAC(hasher, key).update(data).digest()
v8.create = ($, J) => new f8($, J)
function p0($, J = '') {
  if (typeof $ !== 'boolean') {
    const q = J && `"${J}"`
    throw new Error(`${q}expected boolean, got type=${typeof $}`)
  }
  return $
}
function x0($, J, q = '') {
  const Q = w0($)
  const G = $?.length
  const z = J !== undefined
  if (!Q || (z && G !== J)) {
    const U = q && `"${q}" `
    const X = z ? ` of length ${J}` : ''
    const Z = Q ? `length=${G}` : `type=${typeof $}`
    throw new Error(`${U}expected Uint8Array${X}, got ${Z}`)
  }
  return $
}
function i0($) {
  const J = $.toString(16)
  if (J.length & 1) {
    return `0${J}`
  } else {
    return J
  }
}
function M$($) {
  if (typeof $ !== 'string') {
    throw new Error(`hex string expected, got ${typeof $}`)
  }
  if ($ === '') {
    return g8
  } else {
    return BigInt(`0x${$}`)
  }
}
function M0($) {
  return M$(Z0($))
}
function y8($) {
  $0($)
  return M$(Z0(Uint8Array.from($).reverse()))
}
function _0($, J) {
  return k0($.toString(16).padStart(J * 2, '0'))
}
function u8($, J) {
  return _0($, J).reverse()
}
function m($, J, q) {
  let Q
  if (typeof J === 'string') {
    try {
      Q = k0(J)
    } catch (z) {
      throw new Error(`${$} must be hex string or Uint8Array, cause: ${z}`)
    }
  } else if (w0(J)) {
    Q = Uint8Array.from(J)
  } else {
    throw new Error(`${$} must be hex string or Uint8Array`)
  }
  const G = Q.length
  if (typeof q === 'number' && G !== q) {
    throw new Error(`${$} of length ${q} expected, got ${G}`)
  }
  return Q
}
function a0($, J, q) {
  return b8($) && b8(J) && b8(q) && J <= $ && $ < q
}
function D$($, J, q, Q) {
  if (!a0(J, q, Q)) {
    throw new Error(`expected valid ${$}: ${q} <= n < ${Q}, got ${J}`)
  }
}
function M8($) {
  let J
  for (J = 0; $ > g8; J += 1) {
    $ >>= _8
  }
  return J
}
function W$($, J, q) {
  if (typeof $ !== 'number' || $ < 2) {
    throw new Error('hashLen must be a number')
  }
  if (typeof J !== 'number' || J < 2) {
    throw new Error('qByteLen must be a number')
  }
  if (typeof q !== 'function') {
    throw new Error('hmacFn must be a function')
  }
  const Q = (K) => new Uint8Array(K)
  const G = (K) => Uint8Array.of(K)
  let z = Q($)
  let U = Q($)
  let X = 0
  const Z = () => {
    z.fill(1)
    U.fill(0)
    X = 0
  }
  const V = (...K) => q(U, z, ...K)
  const N = (K = Q(0)) => {
    U = V(G(0), K)
    z = V()
    if (K.length === 0) {
      return
    }
    U = V(G(1), K)
    z = V()
  }
  const L = () => {
    if (X++ >= 1000) {
      throw new Error('drbg: tried 1000 values')
    }
    let K = 0
    const H = []
    while (K < J) {
      z = V()
      const A = z.slice()
      H.push(A)
      K += z.length
    }
    return o(...H)
  }
  return (K, H) => {
    Z()
    N(K)
    let A
    while (!(A = H(L()))) {
      N()
    }
    Z()
    return A
  }
}
function n0($, J, q = {}) {
  if (!$ || typeof $ !== 'object') {
    throw new Error('expected valid options object')
  }
  function Q(G, z, U) {
    const X = $[G]
    if (U && X === undefined) {
      return
    }
    const Z = typeof X
    if (Z !== z || X === null) {
      throw new Error(`param "${G}" is invalid: expected ${z}, got ${Z}`)
    }
  }
  Object.entries(J).forEach(([G, z]) => Q(G, z, false))
  Object.entries(q).forEach(([G, z]) => Q(G, z, true))
}
function m8($) {
  const J = new WeakMap()
  return (q, ...Q) => {
    const G = J.get(q)
    if (G !== undefined) {
      return G
    }
    const z = $(q, ...Q)
    J.set(q, z)
    return z
  }
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var g8 = BigInt(0)
var _8 = BigInt(1)
var b8 = ($) => typeof $ === 'bigint' && g8 <= $
var H0 = ($) => (_8 << BigInt($)) - _8
function p($, J) {
  const q = $ % J
  if (q >= l) {
    return q
  } else {
    return J + q
  }
}
function i($, J, q) {
  let Q = $
  while (J-- > l) {
    Q *= Q
    Q %= q
  }
  return Q
}
function N$($, J) {
  if ($ === l) {
    throw new Error('invert: expected non-zero number')
  }
  if (J <= l) {
    throw new Error(`invert: expected positive modulus, got ${J}`)
  }
  let q = p($, J)
  let Q = J
  let G = l
  let z = h
  let U = h
  let X = l
  while (q !== l) {
    const V = Q / q
    const N = Q % q
    const L = G - U * V
    const j = z - X * V
    Q = q
    q = N
    G = U
    z = X
    U = L
    X = j
  }
  if (Q !== h) {
    throw new Error('invert: does not exist')
  }
  return p(G, J)
}
function F8($, J, q) {
  if (!$.eql($.sqr(J), q)) {
    throw new Error('Cannot find square root')
  }
}
function O$($, J) {
  const q = ($.ORDER + h) / T$
  const Q = $.pow(J, q)
  F8($, Q, J)
  return Q
}
function IQ($, J) {
  const q = ($.ORDER - B$) / x$
  const Q = $.mul(J, P0)
  const G = $.pow(Q, q)
  const z = $.mul(J, G)
  const U = $.mul($.mul(z, P0), G)
  const X = $.mul(z, $.sub(U, $.ONE))
  F8($, X, J)
  return X
}
function kQ($) {
  const J = O0($)
  const q = R$($)
  const Q = q(J, J.neg(J.ONE))
  const G = q(J, Q)
  const z = q(J, J.neg(Q))
  const U = ($ + AQ) / H$
  return (X, Z) => {
    let V = X.pow(Z, U)
    let N = X.mul(V, Q)
    const L = X.mul(V, G)
    const j = X.mul(V, z)
    const K = X.eql(X.sqr(N), Z)
    const H = X.eql(X.sqr(L), Z)
    V = X.cmov(V, N, K)
    N = X.cmov(j, L, H)
    const A = X.eql(X.sqr(N), Z)
    const E = X.cmov(V, N, A)
    F8(X, E, Z)
    return E
  }
}
function R$($) {
  if ($ < C$) {
    throw new Error('sqrt is not defined for small field')
  }
  let J = $ - h
  let q = 0
  while (J % P0 === l) {
    J /= P0
    q++
  }
  let Q = P0
  const G = O0($)
  while (V$(G, Q) === 1) {
    if (Q++ > 1000) {
      throw new Error('Cannot find square root: probably non-prime P')
    }
  }
  if (q === 1) {
    return O$
  }
  const z = G.pow(Q, J)
  const U = (J + h) / P0
  return function X(Z, V) {
    if (Z.is0(V)) {
      return V
    }
    if (V$(Z, V) !== 1) {
      throw new Error('Cannot find square root')
    }
    let N = q
    let L = Z.mul(Z.ONE, z)
    let j = Z.pow(V, J)
    let K = Z.pow(V, U)
    while (!Z.eql(j, Z.ONE)) {
      if (Z.is0(j)) {
        return Z.ZERO
      }
      let H = 1
      let A = Z.sqr(j)
      while (!Z.eql(A, Z.ONE)) {
        H++
        A = Z.sqr(A)
        if (H === N) {
          throw new Error('Cannot find square root')
        }
      }
      const E = h << BigInt(N - H - 1)
      const v = Z.pow(L, E)
      N = H
      L = Z.sqr(v)
      j = Z.mul(j, L)
      K = Z.mul(K, v)
    }
    return K
  }
}
function SQ($) {
  if ($ % T$ === C$) {
    return O$
  }
  if ($ % x$ === B$) {
    return IQ
  }
  if ($ % H$ === wQ) {
    return kQ($)
  }
  return R$($)
}
function h8($) {
  const J = {
    ORDER: 'bigint',
    MASK: 'bigint',
    BYTES: 'number',
    BITS: 'number'
  }
  const q = PQ.reduce((Q, G) => {
    Q[G] = 'function'
    return Q
  }, J)
  n0($, q)
  return $
}
function EQ($, J, q) {
  if (q < l) {
    throw new Error('invalid exponent, negatives unsupported')
  }
  if (q === l) {
    return $.ONE
  }
  if (q === h) {
    return J
  }
  let Q = $.ONE
  let G = J
  while (q > l) {
    if (q & h) {
      Q = $.mul(Q, G)
    }
    G = $.sqr(G)
    q >>= h
  }
  return Q
}
function D8($, J, q = false) {
  const Q = new Array(J.length).fill(q ? $.ZERO : undefined)
  const G = J.reduce((U, X, Z) => {
    if ($.is0(X)) {
      return U
    }
    Q[Z] = U
    return $.mul(U, X)
  }, $.ONE)
  const z = $.inv(G)
  J.reduceRight((U, X, Z) => {
    if ($.is0(X)) {
      return U
    }
    Q[Z] = $.mul(U, Q[Z])
    return $.mul(U, X)
  }, z)
  return Q
}
function V$($, J) {
  const q = ($.ORDER - h) / P0
  const Q = $.pow(J, q)
  const G = $.eql(Q, $.ONE)
  const z = $.eql(Q, $.ZERO)
  const U = $.eql(Q, $.neg($.ONE))
  if (!G && !z && !U) {
    throw new Error('invalid Legendre symbol result')
  }
  if (G) {
    return 1
  } else if (z) {
    return 0
  } else {
    return -1
  }
}
function W8($, J) {
  if (J !== undefined) {
    d0(J)
  }
  const q = J !== undefined ? J : $.toString(2).length
  const Q = Math.ceil(q / 8)
  return {
    nBitLength: q,
    nByteLength: Q
  }
}
function O0($, J, q = false, Q = {}) {
  if ($ <= l) {
    throw new Error(`invalid field: expected ORDER > 0, got ${$}`)
  }
  let G
  let z
  let U = false
  let X
  if (typeof J === 'object' && J != null) {
    if (Q.sqrt || q) {
      throw new Error('cannot specify opts in two arguments')
    }
    const j = J
    if (j.BITS) {
      G = j.BITS
    }
    if (j.sqrt) {
      z = j.sqrt
    }
    if (typeof j.isLE === 'boolean') {
      q = j.isLE
    }
    if (typeof j.modFromBytes === 'boolean') {
      U = j.modFromBytes
    }
    X = j.allowedLengths
  } else {
    if (typeof J === 'number') {
      G = J
    }
    if (Q.sqrt) {
      z = Q.sqrt
    }
  }
  const { nBitLength: Z, nByteLength: V } = W8($, G)
  if (V > 2048) {
    throw new Error('invalid field: expected ORDER of <= 2048 bytes')
  }
  let N
  const L = Object.freeze({
    ORDER: $,
    isLE: q,
    BITS: Z,
    BYTES: V,
    MASK: H0(Z),
    ZERO: l,
    ONE: h,
    allowedLengths: X,
    create: (j) => p(j, $),
    isValid: (j) => {
      if (typeof j !== 'bigint') {
        throw new Error(
          `invalid field element: expected bigint, got ${typeof j}`
        )
      }
      return l <= j && j < $
    },
    is0: (j) => j === l,
    isValidNot0: (j) => !L.is0(j) && L.isValid(j),
    isOdd: (j) => (j & h) === h,
    neg: (j) => p(-j, $),
    eql: (j, K) => j === K,
    sqr: (j) => p(j * j, $),
    add: (j, K) => p(j + K, $),
    sub: (j, K) => p(j - K, $),
    mul: (j, K) => p(j * K, $),
    pow: (j, K) => EQ(L, j, K),
    div: (j, K) => p(j * N$(K, $), $),
    sqrN: (j) => j * j,
    addN: (j, K) => j + K,
    subN: (j, K) => j - K,
    mulN: (j, K) => j * K,
    inv: (j) => N$(j, $),
    sqrt:
      z ||
      ((j) => {
        if (!N) {
          N = SQ($)
        }
        return N(L, j)
      }),
    toBytes: (j) => (q ? u8(j, V) : _0(j, V)),
    fromBytes: (j, K = true) => {
      if (X) {
        if (!X.includes(j.length) || j.length > V) {
          throw new Error(
            `Field.fromBytes: expected ${X} bytes, got ${j.length}`
          )
        }
        const A = new Uint8Array(V)
        A.set(j, q ? 0 : A.length - j.length)
        j = A
      }
      if (j.length !== V) {
        throw new Error(`Field.fromBytes: expected ${V} bytes, got ${j.length}`)
      }
      let H = q ? y8(j) : M0(j)
      if (U) {
        H = p(H, $)
      }
      if (!K) {
        if (!L.isValid(H)) {
          throw new Error('invalid field element: outside of range 0..ORDER')
        }
      }
      return H
    },
    invertBatch: (j) => D8(L, j),
    cmov: (j, K, H) => (H ? K : j)
  })
  return Object.freeze(L)
}
function L$($) {
  if (typeof $ !== 'bigint') {
    throw new Error('field order must be bigint')
  }
  const J = $.toString(2).length
  return Math.ceil(J / 8)
}
function l8($) {
  const J = L$($)
  return J + Math.ceil(J / 2)
}
function N8($, J, q = false) {
  const Q = $.length
  const G = L$(J)
  const z = l8(J)
  if (Q < 16 || Q < z || Q > 1024) {
    throw new Error(`expected ${z}-1024 bytes of input, got ${Q}`)
  }
  const U = q ? y8($) : M0($)
  const X = p(U, J - h) + h
  if (q) {
    return u8(X, G)
  } else {
    return _0(X, G)
  }
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var l = BigInt(0)
var h = BigInt(1)
var P0 = BigInt(2)
var C$ = BigInt(3)
var T$ = BigInt(4)
var B$ = BigInt(5)
var AQ = BigInt(7)
var x$ = BigInt(8)
var wQ = BigInt(9)
var H$ = BigInt(16)
var PQ = [
  'create',
  'isValid',
  'is0',
  'neg',
  'inv',
  'sqrt',
  'sqr',
  'eql',
  'add',
  'sub',
  'mul',
  'pow',
  'div',
  'addN',
  'subN',
  'mulN',
  'sqrN'
]
function s0($, J) {
  const q = J.negate()
  if ($) {
    return q
  } else {
    return J
  }
}
function V8($, J) {
  const q = D8(
    $.Fp,
    J.map((Q) => Q.Z)
  )
  return J.map((Q, G) => $.fromAffine(Q.toAffine(q[G])))
}
function k$($, J) {
  if (!Number.isSafeInteger($) || $ <= 0 || $ > J) {
    throw new Error(`invalid window size, expected [1..${J}], got W=${$}`)
  }
}
function c8($, J) {
  k$($, J)
  const q = Math.ceil(J / $) + 1
  const Q = 2 ** ($ - 1)
  const G = 2 ** $
  const z = H0($)
  const U = BigInt($)
  return {
    windows: q,
    windowSize: Q,
    mask: z,
    maxNumber: G,
    shiftBy: U
  }
}
function A$($, J, q) {
  const { windowSize: Q, mask: G, maxNumber: z, shiftBy: U } = q
  let X = Number($ & G)
  let Z = $ >> U
  if (X > Q) {
    X -= z
    Z += E0
  }
  const V = J * Q
  const N = V + Math.abs(X) - 1
  const L = X === 0
  const j = X < 0
  const K = J % 2 !== 0
  return {
    nextN: Z,
    offset: N,
    isZero: L,
    isNeg: j,
    isNegF: K,
    offsetF: V
  }
}
function fQ($, J) {
  if (!Array.isArray($)) {
    throw new Error('array expected')
  }
  $.forEach((q, Q) => {
    if (!(q instanceof J)) {
      throw new Error(`invalid point at index ${Q}`)
    }
  })
}
function vQ($, J) {
  if (!Array.isArray($)) {
    throw new Error('array of scalars expected')
  }
  $.forEach((q, Q) => {
    if (!J.isValid(q)) {
      throw new Error(`invalid scalar at index ${Q}`)
    }
  })
}
function o8($) {
  return S$.get($) || 1
}
function w$($) {
  if ($ !== g0) {
    throw new Error('invalid wNAF')
  }
}
function P$($, J, q, Q) {
  let G = J
  let z = $.ZERO
  let U = $.ZERO
  while (q > g0 || Q > g0) {
    if (q & E0) {
      z = z.add(G)
    }
    if (Q & E0) {
      U = U.add(G)
    }
    G = G.double()
    q >>= E0
    Q >>= E0
  }
  return {
    p1: z,
    p2: U
  }
}
function E$($, J, q, Q) {
  fQ(q, $)
  vQ(Q, J)
  const G = q.length
  const z = Q.length
  if (G !== z) {
    throw new Error('arrays of points and scalars must have equal length')
  }
  const U = $.ZERO
  const X = M8(BigInt(G))
  let Z = 1
  if (X > 12) {
    Z = X - 3
  } else if (X > 4) {
    Z = X - 2
  } else if (X > 0) {
    Z = 2
  }
  const V = H0(Z)
  const N = new Array(Number(V) + 1).fill(U)
  const L = Math.floor((J.BITS - 1) / Z) * Z
  let j = U
  for (let K = L; K >= 0; K -= Z) {
    N.fill(U)
    for (let A = 0; A < z; A++) {
      const E = Q[A]
      const v = Number((E >> BigInt(K)) & V)
      N[v] = N[v].add(q[A])
    }
    let H = U
    for (let A = N.length - 1, E = U; A > 0; A--) {
      E = E.add(N[A])
      H = H.add(E)
    }
    j = j.add(H)
    if (K !== 0) {
      for (let A = 0; A < Z; A++) {
        j = j.double()
      }
    }
  }
  return j
}
function I$($, J, q) {
  if (J) {
    if (J.ORDER !== $) {
      throw new Error('Field.ORDER must match order: Fp == p, Fn == n')
    }
    h8(J)
    return J
  } else {
    return O0($, {
      isLE: q
    })
  }
}
function f$($, J, q = {}, Q = $ === 'edwards') {
  if (!J || typeof J !== 'object') {
    throw new Error(`expected valid ${$} CURVE object`)
  }
  for (const Z of ['p', 'n', 'h']) {
    const V = J[Z]
    if (typeof V !== 'bigint' || !(V > g0)) {
      throw new Error(`CURVE.${Z} must be positive bigint`)
    }
  }
  const G = I$(J.p, q.Fp, Q)
  const z = I$(J.n, q.Fn, Q)
  const X = ['Gx', 'Gy', 'a', $ === 'weierstrass' ? 'b' : 'd']
  for (const Z of X) {
    if (!G.isValid(J[Z])) {
      throw new Error(`CURVE.${Z} must be valid field element of CURVE.Fp`)
    }
  }
  J = Object.freeze(Object.assign({}, J))
  return {
    CURVE: J,
    Fp: G,
    Fn: z
  }
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var g0 = BigInt(0)
var E0 = BigInt(1)
var d8 = new WeakMap()
var S$ = new WeakMap()
class r8 {
  constructor($, J) {
    this.BASE = $.BASE
    this.ZERO = $.ZERO
    this.Fn = $.Fn
    this.bits = J
  }
  _unsafeLadder($, J, q = this.ZERO) {
    let Q = $
    while (J > g0) {
      if (J & E0) {
        q = q.add(Q)
      }
      Q = Q.double()
      J >>= E0
    }
    return q
  }
  precomputeWindow($, J) {
    const { windows: q, windowSize: Q } = c8(J, this.bits)
    const G = []
    let z = $
    let U = z
    for (let X = 0; X < q; X++) {
      U = z
      G.push(U)
      for (let Z = 1; Z < Q; Z++) {
        U = U.add(z)
        G.push(U)
      }
      z = U.double()
    }
    return G
  }
  wNAF($, J, q) {
    if (!this.Fn.isValid(q)) {
      throw new Error('invalid scalar')
    }
    let Q = this.ZERO
    let G = this.BASE
    const z = c8($, this.bits)
    for (let U = 0; U < z.windows; U++) {
      const {
        nextN: X,
        offset: Z,
        isZero: V,
        isNeg: N,
        isNegF: L,
        offsetF: j
      } = A$(q, U, z)
      q = X
      if (V) {
        G = G.add(s0(L, J[j]))
      } else {
        Q = Q.add(s0(N, J[Z]))
      }
    }
    w$(q)
    return {
      p: Q,
      f: G
    }
  }
  wNAFUnsafe($, J, q, Q = this.ZERO) {
    const G = c8($, this.bits)
    for (let z = 0; z < G.windows; z++) {
      if (q === g0) {
        break
      }
      const { nextN: U, offset: X, isZero: Z, isNeg: V } = A$(q, z, G)
      q = U
      if (Z) {
      } else {
        const N = J[X]
        Q = Q.add(V ? N.negate() : N)
      }
    }
    w$(q)
    return Q
  }
  getPrecomputes($, J, q) {
    let Q = d8.get(J)
    if (!Q) {
      Q = this.precomputeWindow(J, $)
      if ($ !== 1) {
        if (typeof q === 'function') {
          Q = q(Q)
        }
        d8.set(J, Q)
      }
    }
    return Q
  }
  cached($, J, q) {
    const Q = o8($)
    return this.wNAF(Q, this.getPrecomputes(Q, $, q), J)
  }
  unsafe($, J, q, Q) {
    const G = o8($)
    if (G === 1) {
      return this._unsafeLadder($, J, Q)
    }
    return this.wNAFUnsafe(G, this.getPrecomputes(G, $, q), J, Q)
  }
  createCache($, J) {
    k$(J, this.bits)
    S$.set($, J)
    d8.delete($)
  }
  hasCache($) {
    return o8($) !== 1
  }
}
function bQ($, J, q) {
  const [[Q, G], [z, U]] = J
  const X = v$(U * $, q)
  const Z = v$(-G * $, q)
  let V = $ - X * Q - Z * z
  let N = -X * G - Z * U
  const L = V < W0
  const j = N < W0
  if (L) {
    V = -V
  }
  if (j) {
    N = -N
  }
  const K = H0(Math.ceil(M8(q) / 2)) + y0
  if (V < W0 || V >= K || N < W0 || N >= K) {
    throw new Error(`splitScalar (endomorphism): failed, k=${$}`)
  }
  return {
    k1neg: L,
    k1: V,
    k2neg: j,
    k2: N
  }
}
function i8($) {
  if (!['compact', 'recovered', 'der'].includes($)) {
    throw new Error('Signature format must be "compact", "recovered", or "der"')
  }
  return $
}
function p8($, J) {
  const q = {}
  for (const Q of Object.keys(J)) {
    q[Q] = $[Q] === undefined ? J[Q] : $[Q]
  }
  p0(q.lowS, 'lowS')
  p0(q.prehash, 'prehash')
  if (q.format !== undefined) {
    i8(q.format)
  }
  return q
}
function R0($, J) {
  const { BYTES: q } = $
  let Q
  if (typeof J === 'bigint') {
    Q = J
  } else {
    const G = m('private key', J)
    try {
      Q = $.fromBytes(G)
    } catch (_z) {
      throw new Error(
        `invalid private key: expected ui8a of size ${q}, got ${typeof J}`
      )
    }
  }
  if (!$.isValidNot0(Q)) {
    throw new Error('invalid private key: out of range [1..N-1]')
  }
  return Q
}
function gQ($, J = {}) {
  const q = f$('weierstrass', $, J)
  const { Fp: Q, Fn: G } = q
  const z = q.CURVE
  const { h: U, n: X } = z
  n0(
    J,
    {},
    {
      allowInfinityPoint: 'boolean',
      clearCofactor: 'function',
      isTorsionFree: 'function',
      fromBytes: 'function',
      toBytes: 'function',
      endo: 'object',
      wrapPrivateKey: 'boolean'
    }
  )
  const { endo: Z } = J
  if (Z) {
    if (
      !Q.is0(z.a) ||
      typeof Z.beta !== 'bigint' ||
      !Array.isArray(Z.basises)
    ) {
      throw new Error(
        'invalid endo: expected "beta": bigint and "basises": array'
      )
    }
  }
  const V = y$(Q, G)
  function N() {
    if (!Q.isOdd) {
      throw new Error(
        'compression is not supported: Field does not have .isOdd()'
      )
    }
  }
  function L(_W, O, M) {
    const { x: B, y: Y } = O.toAffine()
    const D = Q.toBytes(B)
    p0(M, 'isCompressed')
    if (M) {
      N()
      const C = !Q.isOdd(Y)
      return o(g$(C), D)
    } else {
      return o(Uint8Array.of(4), D, Q.toBytes(Y))
    }
  }
  function j(W) {
    x0(W, undefined, 'Point')
    const { publicKey: O, publicKeyUncompressed: M } = V
    const B = W.length
    const Y = W[0]
    const D = W.subarray(1)
    if (B === O && (Y === 2 || Y === 3)) {
      const C = Q.fromBytes(D)
      if (!Q.isValid(C)) {
        throw new Error('bad point: is not on curve, wrong x')
      }
      const x = A(C)
      let T
      try {
        T = Q.sqrt(x)
      } catch (k) {
        const w = k instanceof Error ? `: ${k.message}` : ''
        throw new Error(`bad point: is not on curve, sqrt error${w}`)
      }
      N()
      const R = Q.isOdd(T)
      if (((Y & 1) === 1) !== R) {
        T = Q.neg(T)
      }
      return {
        x: C,
        y: T
      }
    } else if (B === M && Y === 4) {
      const C = Q.BYTES
      const x = Q.fromBytes(D.subarray(0, C))
      const T = Q.fromBytes(D.subarray(C, C * 2))
      if (!E(x, T)) {
        throw new Error('bad point: is not on curve')
      }
      return {
        x,
        y: T
      }
    } else {
      throw new Error(
        `bad point: got length ${B}, expected compressed=${O} or uncompressed=${M}`
      )
    }
  }
  const K = J.toBytes || L
  const H = J.fromBytes || j
  function A(W) {
    const O = Q.sqr(W)
    const M = Q.mul(O, W)
    return Q.add(Q.add(M, Q.mul(W, z.a)), z.b)
  }
  function E(W, O) {
    const M = Q.sqr(O)
    const B = A(W)
    return Q.eql(M, B)
  }
  if (!E(z.Gx, z.Gy)) {
    throw new Error('bad curve params: generator point')
  }
  const v = Q.mul(Q.pow(z.a, C8), _Q)
  const q0 = Q.mul(Q.sqr(z.b), BigInt(27))
  if (Q.is0(Q.add(v, q0))) {
    throw new Error('bad curve params: a or b')
  }
  function _(W, O, M = false) {
    if (!Q.isValid(O) || (M && Q.is0(O))) {
      throw new Error(`bad point coordinate ${W}`)
    }
    return O
  }
  function n(W) {
    if (!(W instanceof I)) {
      throw new Error('ProjectivePoint expected')
    }
  }
  function c(W) {
    if (!Z || !Z.basises) {
      throw new Error('no endo')
    }
    return bQ(W, Z.basises, G.ORDER)
  }
  const s = m8((W, O) => {
    const { X: M, Y: B, Z: Y } = W
    if (Q.eql(Y, Q.ONE)) {
      return {
        x: M,
        y: B
      }
    }
    const D = W.is0()
    if (O == null) {
      O = D ? Q.ONE : Q.inv(Y)
    }
    const C = Q.mul(M, O)
    const x = Q.mul(B, O)
    const T = Q.mul(Y, O)
    if (D) {
      return {
        x: Q.ZERO,
        y: Q.ZERO
      }
    }
    if (!Q.eql(T, Q.ONE)) {
      throw new Error('invZ was invalid')
    }
    return {
      x: C,
      y: x
    }
  })
  const C0 = m8((W) => {
    if (W.is0()) {
      if (J.allowInfinityPoint && !Q.is0(W.Y)) {
        return
      }
      throw new Error('bad point: ZERO')
    }
    const { x: O, y: M } = W.toAffine()
    if (!Q.isValid(O) || !Q.isValid(M)) {
      throw new Error('bad point: x or y not field elements')
    }
    if (!E(O, M)) {
      throw new Error('bad point: equation left != right')
    }
    if (!W.isTorsionFree()) {
      throw new Error('bad point: not in prime-order subgroup')
    }
    return true
  })
  function G0(W, O, M, B, Y) {
    M = new I(Q.mul(M.X, W), M.Y, M.Z)
    O = s0(B, O)
    M = s0(Y, M)
    return O.add(M)
  }
  class I {
    constructor(W, O, M) {
      this.X = _('x', W)
      this.Y = _('y', O, true)
      this.Z = _('z', M)
      Object.freeze(this)
    }
    static CURVE() {
      return z
    }
    static fromAffine(W) {
      const { x: O, y: M } = W || {}
      if (!W || !Q.isValid(O) || !Q.isValid(M)) {
        throw new Error('invalid affine point')
      }
      if (W instanceof I) {
        throw new Error('projective point not allowed')
      }
      if (Q.is0(O) && Q.is0(M)) {
        return I.ZERO
      }
      return new I(O, M, Q.ONE)
    }
    static fromBytes(W) {
      const O = I.fromAffine(H(x0(W, undefined, 'point')))
      O.assertValidity()
      return O
    }
    static fromHex(W) {
      return I.fromBytes(m('pointHex', W))
    }
    get x() {
      return this.toAffine().x
    }
    get y() {
      return this.toAffine().y
    }
    precompute(W = 8, O = true) {
      S.createCache(this, W)
      if (!O) {
        this.multiply(C8)
      }
      return this
    }
    assertValidity() {
      C0(this)
    }
    hasEvenY() {
      const { y: W } = this.toAffine()
      if (!Q.isOdd) {
        throw new Error("Field doesn't support isOdd")
      }
      return !Q.isOdd(W)
    }
    equals(W) {
      n(W)
      const { X: O, Y: M, Z: B } = this
      const { X: Y, Y: D, Z: C } = W
      const x = Q.eql(Q.mul(O, C), Q.mul(Y, B))
      const T = Q.eql(Q.mul(M, C), Q.mul(D, B))
      return x && T
    }
    negate() {
      return new I(this.X, Q.neg(this.Y), this.Z)
    }
    double() {
      const { a: W, b: O } = z
      const M = Q.mul(O, C8)
      const { X: B, Y, Z: D } = this
      let { ZERO: C, ZERO: x, ZERO: T } = Q
      let R = Q.mul(B, B)
      const g = Q.mul(Y, Y)
      let k = Q.mul(D, D)
      let w = Q.mul(B, Y)
      w = Q.add(w, w)
      T = Q.mul(B, D)
      T = Q.add(T, T)
      C = Q.mul(W, T)
      x = Q.mul(M, k)
      x = Q.add(C, x)
      C = Q.sub(g, x)
      x = Q.add(g, x)
      x = Q.mul(C, x)
      C = Q.mul(w, C)
      T = Q.mul(M, T)
      k = Q.mul(W, k)
      w = Q.sub(R, k)
      w = Q.mul(W, w)
      w = Q.add(w, T)
      T = Q.add(R, R)
      R = Q.add(T, R)
      R = Q.add(R, k)
      R = Q.mul(R, w)
      x = Q.add(x, R)
      k = Q.mul(Y, D)
      k = Q.add(k, k)
      R = Q.mul(k, w)
      C = Q.sub(C, R)
      T = Q.mul(k, g)
      T = Q.add(T, T)
      T = Q.add(T, T)
      return new I(C, x, T)
    }
    add(W) {
      n(W)
      const { X: O, Y: M, Z: B } = this
      const { X: Y, Y: D, Z: C } = W
      let { ZERO: x, ZERO: T, ZERO: R } = Q
      const g = z.a
      const k = Q.mul(z.b, C8)
      let w = Q.mul(O, Y)
      let P = Q.mul(M, D)
      let f = Q.mul(B, C)
      let b = Q.add(O, M)
      let y = Q.add(Y, D)
      b = Q.mul(b, y)
      y = Q.add(w, P)
      b = Q.sub(b, y)
      y = Q.add(O, B)
      let u = Q.add(Y, C)
      y = Q.mul(y, u)
      u = Q.add(w, f)
      y = Q.sub(y, u)
      u = Q.add(M, B)
      x = Q.add(D, C)
      u = Q.mul(u, x)
      x = Q.add(P, f)
      u = Q.sub(u, x)
      R = Q.mul(g, y)
      x = Q.mul(k, f)
      R = Q.add(x, R)
      x = Q.sub(P, R)
      R = Q.add(P, R)
      T = Q.mul(x, R)
      P = Q.add(w, w)
      P = Q.add(P, w)
      f = Q.mul(g, f)
      y = Q.mul(k, y)
      P = Q.add(P, f)
      f = Q.sub(w, f)
      f = Q.mul(g, f)
      y = Q.add(y, f)
      w = Q.mul(P, y)
      T = Q.add(T, w)
      w = Q.mul(u, y)
      x = Q.mul(b, x)
      x = Q.sub(x, w)
      w = Q.mul(b, P)
      R = Q.mul(u, R)
      R = Q.add(R, w)
      return new I(x, T, R)
    }
    subtract(W) {
      return this.add(W.negate())
    }
    is0() {
      return this.equals(I.ZERO)
    }
    multiply(W) {
      const { endo: O } = J
      if (!G.isValidNot0(W)) {
        throw new Error('invalid scalar: out of range')
      }
      let M
      let B
      const Y = (D) => S.cached(this, D, (C) => V8(I, C))
      if (O) {
        const { k1neg: D, k1: C, k2neg: x, k2: T } = c(W)
        const { p: R, f: g } = Y(C)
        const { p: k, f: w } = Y(T)
        B = g.add(w)
        M = G0(O.beta, R, k, D, x)
      } else {
        const { p: D, f: C } = Y(W)
        M = D
        B = C
      }
      return V8(I, [M, B])[0]
    }
    multiplyUnsafe(W) {
      const { endo: O } = J
      if (!G.isValid(W)) {
        throw new Error('invalid scalar: out of range')
      }
      if (W === W0 || this.is0()) {
        return I.ZERO
      }
      if (W === y0) {
        return this
      }
      if (S.hasCache(this)) {
        return this.multiply(W)
      }
      if (O) {
        const { k1neg: B, k1: Y, k2neg: D, k2: C } = c(W)
        const { p1: x, p2: T } = P$(I, this, Y, C)
        return G0(O.beta, x, T, B, D)
      } else {
        return S.unsafe(this, W)
      }
    }
    multiplyAndAddUnsafe(W, O, M) {
      const B = this.multiplyUnsafe(O).add(W.multiplyUnsafe(M))
      if (B.is0()) {
        return undefined
      } else {
        return B
      }
    }
    toAffine(W) {
      return s(this, W)
    }
    isTorsionFree() {
      const { isTorsionFree: W } = J
      if (U === y0) {
        return true
      }
      if (W) {
        return W(I, this)
      }
      return S.unsafe(this, X).is0()
    }
    clearCofactor() {
      const { clearCofactor: W } = J
      if (U === y0) {
        return this
      }
      if (W) {
        return W(I, this)
      }
      return this.multiplyUnsafe(U)
    }
    isSmallOrder() {
      return this.multiplyUnsafe(U).is0()
    }
    toBytes(W = true) {
      p0(W, 'isCompressed')
      this.assertValidity()
      return K(I, this, W)
    }
    toHex(W = true) {
      return Z0(this.toBytes(W))
    }
    toString() {
      return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`
    }
    get px() {
      return this.X
    }
    get py() {
      return this.X
    }
    get pz() {
      return this.Z
    }
    toRawBytes(W = true) {
      return this.toBytes(W)
    }
    _setWindowSize(W) {
      this.precompute(W)
    }
    static normalizeZ(W) {
      return V8(I, W)
    }
    static msm(W, O) {
      return E$(I, G, W, O)
    }
    static fromPrivateKey(W) {
      return I.BASE.multiply(R0(G, W))
    }
  }
  I.BASE = new I(z.Gx, z.Gy, Q.ONE)
  I.ZERO = new I(Q.ZERO, Q.ONE, Q.ZERO)
  I.Fp = Q
  I.Fn = G
  const Y0 = G.BITS
  const S = new r8(I, J.endo ? Math.ceil(Y0 / 2) : Y0)
  I.BASE.precompute(8)
  return I
}
function g$($) {
  return Uint8Array.of($ ? 2 : 3)
}
function y$($, J) {
  return {
    secretKey: J.BYTES,
    publicKey: 1 + $.BYTES,
    publicKeyUncompressed: 1 + $.BYTES * 2,
    publicKeyHasPrefix: true,
    signature: J.BYTES * 2
  }
}
function yQ($, J = {}) {
  const { Fn: q } = $
  const Q = J.randomBytes || S0
  const G = Object.assign(y$($.Fp, q), {
    seed: l8(q.ORDER)
  })
  function z(K) {
    try {
      return !!R0(q, K)
    } catch (_H) {
      return false
    }
  }
  function U(K, H) {
    const { publicKey: A, publicKeyUncompressed: E } = G
    try {
      const v = K.length
      if (H === true && v !== A) {
        return false
      }
      if (H === false && v !== E) {
        return false
      }
      return !!$.fromBytes(K)
    } catch (_v) {
      return false
    }
  }
  function X(K = Q(G.seed)) {
    return N8(x0(K, G.seed, 'seed'), q.ORDER)
  }
  function Z(K, H = true) {
    return $.BASE.multiply(R0(q, K)).toBytes(H)
  }
  function V(K) {
    const H = X(K)
    return {
      secretKey: H,
      publicKey: Z(H)
    }
  }
  function N(K) {
    if (typeof K === 'bigint') {
      return false
    }
    if (K instanceof $) {
      return true
    }
    const { secretKey: H, publicKey: A, publicKeyUncompressed: E } = G
    if (q.allowedLengths || H === A) {
      return
    }
    const v = m('key', K).length
    return v === A || v === E
  }
  function L(K, H, A = true) {
    if (N(K) === true) {
      throw new Error('first arg must be private key')
    }
    if (N(H) === false) {
      throw new Error('second arg must be public key')
    }
    const E = R0(q, K)
    return $.fromHex(H).multiply(E).toBytes(A)
  }
  return Object.freeze({
    getPublicKey: Z,
    getSharedSecret: L,
    keygen: V,
    Point: $,
    utils: {
      isValidSecretKey: z,
      isValidPublicKey: U,
      randomSecretKey: X,
      isValidPrivateKey: z,
      randomPrivateKey: X,
      normPrivateKeyToScalar: (K) => R0(q, K),
      precompute(K = 8, H = $.BASE) {
        return H.precompute(K, false)
      }
    },
    lengths: G
  })
}
function uQ($, J, q = {}) {
  Y8(J)
  n0(
    q,
    {},
    {
      hmac: 'function',
      lowS: 'boolean',
      randomBytes: 'function',
      bits2int: 'function',
      bits2int_modN: 'function'
    }
  )
  const Q = q.randomBytes || S0
  const G = q.hmac || ((M, ...B) => v8(J, M, o(...B)))
  const { Fp: z, Fn: U } = $
  const { ORDER: X, BITS: Z } = U
  const {
    keygen: V,
    getPublicKey: N,
    getSharedSecret: L,
    utils: j,
    lengths: K
  } = yQ($, q)
  const H = {
    prehash: false,
    lowS: typeof q.lowS === 'boolean' ? q.lowS : false,
    format: undefined,
    extraEntropy: false
  }
  const A = 'compact'
  function E(M) {
    const B = X >> y0
    return M > B
  }
  function v(M, B) {
    if (!U.isValidNot0(B)) {
      throw new Error(`invalid signature ${M}: out of range 1..Point.Fn.ORDER`)
    }
    return B
  }
  function q0(M, B) {
    i8(B)
    const Y = K.signature
    const D = B === 'compact' ? Y : B === 'recovered' ? Y + 1 : undefined
    return x0(M, D, `${B} signature`)
  }
  class _ {
    constructor(M, B, Y) {
      this.r = v('r', M)
      this.s = v('s', B)
      if (Y != null) {
        this.recovery = Y
      }
      Object.freeze(this)
    }
    static fromBytes(M, B = A) {
      q0(M, B)
      let Y
      if (B === 'der') {
        const { r: T, s: R } = D0.toSig(x0(M))
        return new _(T, R)
      }
      if (B === 'recovered') {
        Y = M[0]
        B = 'compact'
        M = M.subarray(1)
      }
      const D = U.BYTES
      const C = M.subarray(0, D)
      const x = M.subarray(D, D * 2)
      return new _(U.fromBytes(C), U.fromBytes(x), Y)
    }
    static fromHex(M, B) {
      return _.fromBytes(k0(M), B)
    }
    addRecoveryBit(M) {
      return new _(this.r, this.s, M)
    }
    recoverPublicKey(M) {
      const B = z.ORDER
      const { r: Y, s: D, recovery: C } = this
      if (C == null || ![0, 1, 2, 3].includes(C)) {
        throw new Error('recovery id invalid')
      }
      if (X * _$ < B && C > 1) {
        throw new Error('recovery id is ambiguous for h>1 curve')
      }
      const T = C === 2 || C === 3 ? Y + X : Y
      if (!z.isValid(T)) {
        throw new Error('recovery id 2 or 3 invalid')
      }
      const R = z.toBytes(T)
      const g = $.fromBytes(o(g$((C & 1) === 0), R))
      const k = U.inv(T)
      const w = c(m('msgHash', M))
      const P = U.create(-w * k)
      const f = U.create(D * k)
      const b = $.BASE.multiplyUnsafe(P).add(g.multiplyUnsafe(f))
      if (b.is0()) {
        throw new Error('point at infinify')
      }
      b.assertValidity()
      return b
    }
    hasHighS() {
      return E(this.s)
    }
    toBytes(M = A) {
      i8(M)
      if (M === 'der') {
        return k0(D0.hexFromSig(this))
      }
      const B = U.toBytes(this.r)
      const Y = U.toBytes(this.s)
      if (M === 'recovered') {
        if (this.recovery == null) {
          throw new Error('recovery bit must be present')
        }
        return o(Uint8Array.of(this.recovery), B, Y)
      }
      return o(B, Y)
    }
    toHex(M) {
      return Z0(this.toBytes(M))
    }
    assertValidity() {}
    static fromCompact(M) {
      return _.fromBytes(m('sig', M), 'compact')
    }
    static fromDER(M) {
      return _.fromBytes(m('sig', M), 'der')
    }
    normalizeS() {
      if (this.hasHighS()) {
        return new _(this.r, U.neg(this.s), this.recovery)
      } else {
        return this
      }
    }
    toDERRawBytes() {
      return this.toBytes('der')
    }
    toDERHex() {
      return Z0(this.toBytes('der'))
    }
    toCompactRawBytes() {
      return this.toBytes('compact')
    }
    toCompactHex() {
      return Z0(this.toBytes('compact'))
    }
  }
  const n =
    q.bits2int ||
    function M(B) {
      if (B.length > 8192) {
        throw new Error('input is too large')
      }
      const Y = M0(B)
      const D = B.length * 8 - Z
      if (D > 0) {
        return Y >> BigInt(D)
      } else {
        return Y
      }
    }
  const c =
    q.bits2int_modN ||
    function M(B) {
      return U.create(n(B))
    }
  const s = H0(Z)
  function C0(M) {
    D$(`num < 2^${Z}`, M, W0, s)
    return U.toBytes(M)
  }
  function G0(M, B) {
    x0(M, undefined, 'message')
    if (B) {
      return x0(J(M), undefined, 'prehashed message')
    } else {
      return M
    }
  }
  function I(M, B, Y) {
    if (['recovered', 'canonical'].some((f) => f in Y)) {
      throw new Error('sign() legacy options not supported')
    }
    const { lowS: D, prehash: C, extraEntropy: x } = p8(Y, H)
    M = G0(M, C)
    const T = c(M)
    const R = R0(U, B)
    const g = [C0(R), C0(T)]
    if (x != null && x !== false) {
      const f = x === true ? Q(K.secretKey) : x
      g.push(m('extraEntropy', f))
    }
    const k = o(...g)
    const w = T
    function P(f) {
      const b = n(f)
      if (!U.isValidNot0(b)) {
        return
      }
      const y = U.inv(b)
      const u = $.BASE.multiply(b).toAffine()
      const F = U.create(u.x)
      if (F === W0) {
        return
      }
      const t = U.create(y * U.create(w + F * R))
      if (t === W0) {
        return
      }
      let z0 = (u.x === F ? 0 : 2) | Number(u.y & y0)
      let r = t
      if (D && E(t)) {
        r = U.neg(t)
        z0 ^= 1
      }
      return new _(F, r, z0)
    }
    return {
      seed: k,
      k2sig: P
    }
  }
  function Y0(M, B, Y = {}) {
    M = m('message', M)
    const { seed: D, k2sig: C } = I(M, B, Y)
    return W$(J.outputLen, U.BYTES, G)(D, C)
  }
  function S(M) {
    let B
    const Y = typeof M === 'string' || w0(M)
    const D =
      !Y &&
      M !== null &&
      typeof M === 'object' &&
      typeof M.r === 'bigint' &&
      typeof M.s === 'bigint'
    if (!Y && !D) {
      throw new Error(
        'invalid signature, expected Uint8Array, hex string or Signature instance'
      )
    }
    if (D) {
      B = new _(M.r, M.s)
    } else if (Y) {
      try {
        B = _.fromBytes(m('sig', M), 'der')
      } catch (C) {
        if (!(C instanceof D0.Err)) {
          throw C
        }
      }
      if (!B) {
        try {
          B = _.fromBytes(m('sig', M), 'compact')
        } catch (_C) {
          return false
        }
      }
    }
    if (!B) {
      return false
    }
    return B
  }
  function W(M, B, Y, D = {}) {
    const { lowS: C, prehash: x, format: T } = p8(D, H)
    Y = m('publicKey', Y)
    B = G0(m('message', B), x)
    if ('strict' in D) {
      throw new Error('options.strict was renamed to lowS')
    }
    const R = T === undefined ? S(M) : _.fromBytes(m('sig', M), T)
    if (R === false) {
      return false
    }
    try {
      const g = $.fromBytes(Y)
      if (C && R.hasHighS()) {
        return false
      }
      const { r: k, s: w } = R
      const P = c(B)
      const f = U.inv(w)
      const b = U.create(P * f)
      const y = U.create(k * f)
      const u = $.BASE.multiplyUnsafe(b).add(g.multiplyUnsafe(y))
      if (u.is0()) {
        return false
      }
      return U.create(u.x) === k
    } catch (_g) {
      return false
    }
  }
  function O(M, B, Y = {}) {
    const { prehash: D } = p8(Y, H)
    B = G0(B, D)
    return _.fromBytes(M, 'recovered').recoverPublicKey(B).toBytes()
  }
  return Object.freeze({
    keygen: V,
    getPublicKey: N,
    getSharedSecret: L,
    utils: j,
    lengths: K,
    Point: $,
    sign: Y0,
    verify: W,
    recoverPublicKey: O,
    Signature: _,
    hash: J
  })
}
function mQ($) {
  const J = {
    a: $.a,
    b: $.b,
    p: $.Fp.ORDER,
    n: $.n,
    h: $.h,
    Gx: $.Gx,
    Gy: $.Gy
  }
  const q = $.Fp
  const Q = $.allowedPrivateKeyLengths
    ? Array.from(
        new Set($.allowedPrivateKeyLengths.map((U) => Math.ceil(U / 2)))
      )
    : undefined
  const G = O0(J.n, {
    BITS: $.nBitLength,
    allowedLengths: Q,
    modFromBytes: $.wrapPrivateKey
  })
  const z = {
    Fp: q,
    Fn: G,
    allowInfinityPoint: $.allowInfinityPoint,
    endo: $.endo,
    isTorsionFree: $.isTorsionFree,
    clearCofactor: $.clearCofactor,
    fromBytes: $.fromBytes,
    toBytes: $.toBytes
  }
  return {
    CURVE: J,
    curveOpts: z
  }
}
function FQ($) {
  const { CURVE: J, curveOpts: q } = mQ($)
  const Q = {
    hmac: $.hmac,
    randomBytes: $.randomBytes,
    lowS: $.lowS,
    bits2int: $.bits2int,
    bits2int_modN: $.bits2int_modN
  }
  return {
    CURVE: J,
    curveOpts: q,
    hash: $.hash,
    ecdsaOpts: Q
  }
}
function hQ($, J) {
  const q = J.Point
  return Object.assign({}, J, {
    ProjectivePoint: q,
    CURVE: Object.assign({}, $, W8(q.Fn.ORDER, q.Fn.BITS))
  })
}
function u$($) {
  const { CURVE: J, curveOpts: q, hash: Q, ecdsaOpts: G } = FQ($)
  const z = gQ(J, q)
  const U = uQ(z, Q, G)
  return hQ($, U)
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var v$ = ($, J) => ($ + ($ >= 0 ? J : -J) / _$) / J
class b$ extends Error {
  constructor($ = '') {
    super($)
  }
}
var D0 = {
  Err: b$,
  _tlv: {
    encode: ($, J) => {
      const { Err: q } = D0
      if ($ < 0 || $ > 256) {
        throw new q('tlv.encode: wrong tag')
      }
      if (J.length & 1) {
        throw new q('tlv.encode: unpadded data')
      }
      const Q = J.length / 2
      const G = i0(Q)
      if ((G.length / 2) & 128) {
        throw new q('tlv.encode: long form length too big')
      }
      const z = Q > 127 ? i0((G.length / 2) | 128) : ''
      return i0($) + z + G + J
    },
    decode($, J) {
      const { Err: q } = D0
      let Q = 0
      if ($ < 0 || $ > 256) {
        throw new q('tlv.encode: wrong tag')
      }
      if (J.length < 2 || J[Q++] !== $) {
        throw new q('tlv.decode: wrong tlv')
      }
      const G = J[Q++]
      const z = !!(G & 128)
      let U = 0
      if (!z) {
        U = G
      } else {
        const Z = G & 127
        if (!Z) {
          throw new q('tlv.decode(long): indefinite length not supported')
        }
        if (Z > 4) {
          throw new q('tlv.decode(long): byte length is too big')
        }
        const V = J.subarray(Q, Q + Z)
        if (V.length !== Z) {
          throw new q('tlv.decode: length bytes not complete')
        }
        if (V[0] === 0) {
          throw new q('tlv.decode(long): zero leftmost byte')
        }
        for (const N of V) {
          U = (U << 8) | N
        }
        Q += Z
        if (U < 128) {
          throw new q('tlv.decode(long): not minimal encoding')
        }
      }
      const X = J.subarray(Q, Q + U)
      if (X.length !== U) {
        throw new q('tlv.decode: wrong value length')
      }
      return {
        v: X,
        l: J.subarray(Q + U)
      }
    }
  },
  _int: {
    encode($) {
      const { Err: J } = D0
      if ($ < W0) {
        throw new J('integer: negative integers are not allowed')
      }
      let q = i0($)
      if (Number.parseInt(q[0], 16) & 8) {
        q = `00${q}`
      }
      if (q.length & 1) {
        throw new J('unexpected DER parsing assertion: unpadded hex')
      }
      return q
    },
    decode($) {
      const { Err: J } = D0
      if ($[0] & 128) {
        throw new J('invalid signature integer: negative')
      }
      if ($[0] === 0 && !($[1] & 128)) {
        throw new J('invalid signature integer: unnecessary leading zero')
      }
      return M0($)
    }
  },
  toSig($) {
    const { Err: J, _int: q, _tlv: Q } = D0
    const G = m('signature', $)
    const { v: z, l: U } = Q.decode(48, G)
    if (U.length) {
      throw new J('invalid signature: left bytes after parsing')
    }
    const { v: X, l: Z } = Q.decode(2, z)
    const { v: V, l: N } = Q.decode(2, Z)
    if (N.length) {
      throw new J('invalid signature: left bytes after parsing')
    }
    return {
      r: q.decode(X),
      s: q.decode(V)
    }
  },
  hexFromSig($) {
    const { _tlv: J, _int: q } = D0
    const Q = J.encode(2, q.encode($.r))
    const G = J.encode(2, q.encode($.s))
    const z = Q + G
    return J.encode(48, z)
  }
}
var W0 = BigInt(0)
var y0 = BigInt(1)
var _$ = BigInt(2)
var C8 = BigInt(3)
var _Q = BigInt(4)
function m$($, J) {
  const q = (Q) =>
    u$({
      ...$,
      hash: Q
    })
  return {
    ...q(J),
    create: q
  }
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function dQ($) {
  const J = u0.p
  const q = BigInt(3)
  const Q = BigInt(6)
  const G = BigInt(11)
  const z = BigInt(22)
  const U = BigInt(23)
  const X = BigInt(44)
  const Z = BigInt(88)
  const V = ($ * $ * $) % J
  const N = (V * V * $) % J
  const L = (i(N, q, J) * N) % J
  const j = (i(L, q, J) * N) % J
  const K = (i(j, a8, J) * V) % J
  const H = (i(K, G, J) * K) % J
  const A = (i(H, z, J) * H) % J
  const E = (i(A, X, J) * A) % J
  const v = (i(E, Z, J) * E) % J
  const q0 = (i(v, X, J) * A) % J
  const _ = (i(q0, q, J) * N) % J
  const n = (i(_, U, J) * H) % J
  const c = (i(n, Q, J) * V) % J
  const s = i(c, a8, J)
  if (!T8.eql(T8.sqr(s), $)) {
    throw new Error('Cannot find square root')
  }
  return s
}
function B8($, ...J) {
  let q = h$[$]
  if (q === undefined) {
    const Q = K8(Z8($))
    q = o(Q, Q)
    h$[$] = q
  }
  return K8(o(q, ...J))
}
function n8($) {
  const { Fn: J, BASE: q } = m0
  const Q = R0(J, $)
  const G = q.multiply(Q)
  return {
    scalar: t8(G.y) ? Q : J.neg(Q),
    bytes: s8(G)
  }
}
function d$($) {
  const J = T8
  if (!J.isValidNot0($)) {
    throw new Error('invalid x: Fail if x ≥ p')
  }
  const q = J.create($ * $)
  const Q = J.create(q * $ + BigInt(7))
  let G = J.sqrt(Q)
  if (!t8(G)) {
    G = J.neg(G)
  }
  const z = m0.fromAffine({
    x: $,
    y: G
  })
  z.assertValidity()
  return z
}
function o$(...$) {
  return m0.Fn.create(t0(B8('BIP0340/challenge', ...$)))
}
function l$($) {
  return n8($).bytes
}
function oQ($, J, q = S0(32)) {
  const { Fn: Q } = m0
  const G = m('message', $)
  const { bytes: z, scalar: U } = n8(J)
  const X = m('auxRand', q, 32)
  const Z = Q.toBytes(U ^ t0(B8('BIP0340/aux', X)))
  const V = B8('BIP0340/nonce', Z, z, G)
  const { bytes: N, scalar: L } = n8(V)
  const j = o$(N, z, G)
  const K = new Uint8Array(64)
  K.set(N, 0)
  K.set(Q.toBytes(Q.create(L + j * U)), 32)
  if (!r$(K, G, z)) {
    throw new Error('sign: Invalid signature produced')
  }
  return K
}
function r$($, J, q) {
  const { Fn: Q, BASE: G } = m0
  const z = m('signature', $, 64)
  const U = m('message', J)
  const X = m('publicKey', q, 32)
  try {
    const Z = d$(t0(X))
    const V = t0(z.subarray(0, 32))
    if (!a0(V, F$, u0.p)) {
      return false
    }
    const N = t0(z.subarray(32, 64))
    if (!a0(N, F$, u0.n)) {
      return false
    }
    const L = o$(Q.toBytes(V), s8(Z), U)
    const j = G.multiplyUnsafe(N).add(Z.multiplyUnsafe(Q.neg(L)))
    const { x: K, y: H } = j.toAffine()
    if (j.is0() || !t8(H) || K !== V) {
      return false
    }
    return true
  } catch (_Z) {
    return false
  }
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var u0 = {
  p: BigInt(
    '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'
  ),
  n: BigInt(
    '0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'
  ),
  h: BigInt(1),
  a: BigInt(0),
  b: BigInt(7),
  Gx: BigInt(
    '0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'
  ),
  Gy: BigInt(
    '0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8'
  )
}
var lQ = {
  beta: BigInt(
    '0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'
  ),
  basises: [
    [
      BigInt('0x3086d221a7d46bcde86c90e49284eb15'),
      -BigInt('0xe4437ed6010e88286f547fa90abfe4c3')
    ],
    [
      BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8'),
      BigInt('0x3086d221a7d46bcde86c90e49284eb15')
    ]
  ]
}
var cQ = BigInt(0)
var F$ = BigInt(1)
var a8 = BigInt(2)
var T8 = O0(u0.p, {
  sqrt: dQ
})
var c$ = m$(
  {
    ...u0,
    Fp: T8,
    lowS: true,
    endo: lQ
  },
  K8
)
var h$ = {}
var s8 = ($) => $.toBytes(true).slice(1)
var m0 = (() => c$.Point)()
var t8 = ($) => $ % a8 === cQ
var t0 = M0
var x8 = (() => {
  const q = (G = S0(48)) => {
    return N8(G, u0.n)
  }
  c$.utils.randomSecretKey
  function Q(G) {
    const z = q(G)
    return {
      secretKey: z,
      publicKey: l$(z)
    }
  }
  return {
    keygen: Q,
    getPublicKey: l$,
    sign: oQ,
    verify: r$,
    Point: m0,
    utils: {
      randomSecretKey: q,
      randomPrivateKey: q,
      taggedHash: B8,
      lift_x: d$,
      pointToBytes: s8,
      numberToBytesBE: _0,
      bytesToNumberBE: M0,
      mod: p
    },
    lengths: {
      secretKey: 32,
      publicKey: 32,
      publicKeyHasPrefix: false,
      signature: 64,
      seed: 48
    }
  }
})()
var rQ = new TextEncoder()
var pQ = new TextDecoder()
var j0 = ($) => rQ.encode($)
var f0 = ($) => pQ.decode($)
var H8 = ($) => Array.from($, (J) => J.toString(16).padStart(2, '0')).join('')
var e = JSON.stringify
var v0 = JSON.parse
var O8 = ($, J = Number.MAX_SAFE_INTEGER) =>
  $.split('').reduce((q, Q) => q + Q.charCodeAt(0), 0) % J
var e8 = 'AES-GCM'
var iQ = {}
var p$ = '$'
var i$ = ','
var aQ = ($) => {
  const J = new Uint8Array($)
  let Q = ''
  for (let G = 0; G < J.length; G += 32768) {
    Q += String.fromCharCode(...J.subarray(G, G + 32768))
  }
  return btoa(Q)
}
var nQ = ($) => Uint8Array.from(atob($), (J) => J.charCodeAt(0)).buffer
var e0 = ($) =>
  (iQ[$] ??= crypto.subtle.digest('SHA-1', j0($)).then((J) => {
    const q = new Uint8Array(J)
    let Q = ''
    for (const G of q) {
      Q += G.toString(36)
    }
    return Q
  }))
var a$ = async ($, J, q) => {
  const Q = await crypto.subtle.digest('SHA-256', j0(`${$}:${J}:${q}`))
  return crypto.subtle.importKey(
    'raw',
    Q,
    {
      name: e8
    },
    false,
    ['encrypt', 'decrypt']
  )
}
var n$ = async ($, J) => {
  const q = crypto.getRandomValues(new Uint8Array(12))
  const Q = await $
  const G = await crypto.subtle.encrypt(
    {
      name: e8,
      iv: q
    },
    Q,
    j0(J)
  )
  return `${q.join(i$)}${p$}${aQ(G)}`
}
var s$ = async ($, J) => {
  const [q, Q] = J.split(p$)
  if (!q || !Q) {
    throw new Error('Invalid encrypted payload format')
  }
  const G = Uint8Array.from(q.split(i$), Number)
  const z = await $
  const U = await crypto.subtle.decrypt(
    {
      name: e8,
      iv: G
    },
    z,
    nQ(Q)
  )
  return f0(U)
}
var a = 'GenosRTC'
var F0 = ($, J) =>
  Array.from(
    {
      length: $
    },
    J
  )
var $8 = ($) =>
  Array.from(
    crypto.getRandomValues(new Uint8Array($)),
    (J) =>
      '0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz'[
        J %
          '0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz'
            .length
      ]
  ).join('')
var N0 = $8(20)
var V0 = Promise.all.bind(Promise)
var t$ = typeof window !== 'undefined'
var { entries: e$, fromEntries: R8, keys: J1 } = Object
var $Q = () => {}
var J0 = ($) => new Error(`GenosRTC: ${$}`)
var Q8 = (...$) => $.join('@')
var QQ = ($, J) => {
  const q = [...$]
  let Q = q.length
  const G = () => {
    const z = Math.sin(J++) * 10000
    return z - Math.floor(z)
  }
  while (Q) {
    const z = Math.floor(G() * Q--)
    ;[q[Q], q[z]] = [q[z], q[Q]]
  }
  return q
}
var sQ = 5000
var JQ = 'icegatheringstatechange'
var qQ = 'offer'
var tQ = 'answer'
var eQ = [
  ...F0(3, (_$, J) => `stun:stun${J || ''}.l.google.com:19302`),
  'stun:stun.cloudflare.com:3478'
].map(($) => ({
  urls: $
}))
var L8 = ($, { rtcConfig: J, rtcPolyfill: q, turnConfig: Q }) => {
  const G = new (q || RTCPeerConnection)({
    iceServers: [...eQ, ...(Q || [])],
    ...J
  })
  const z = {}
  let U = false
  let X = false
  let Z
  const V = (j) =>
    Object.assign(j, {
      binaryType: 'arraybuffer',
      bufferedAmountLowThreshold: 65535,
      onmessage: (K) => z.data?.(K.data),
      onopen: () => z.connect?.(),
      onclose: () => z.close?.(),
      onerror: (K) =>
        !K?.error?.message?.includes('User-Initiated Abort') && z.error?.(K)
    })
  const N = () =>
    Promise.race([
      new Promise((j) => {
        const K = () => {
          if (G.iceGatheringState === 'complete') {
            G.removeEventListener(JQ, K)
            j()
          }
        }
        G.addEventListener(JQ, K)
        K()
      }),
      new Promise((j) => setTimeout(j, sQ))
    ]).then(() => ({
      type: G.localDescription.type,
      sdp: G.localDescription.sdp.replace(/a=ice-options:trickle\s\n/g, '')
    }))
  if ($) {
    V((Z = G.createDataChannel('data')))
  } else {
    G.ondatachannel = ({ channel: j }) => V((Z = j))
  }
  G.onnegotiationneeded = async () => {
    try {
      U = true
      await G.setLocalDescription()
      z.signal?.(await N())
    } catch (j) {
      z.error?.(j)
    } finally {
      U = false
    }
  }
  G.onconnectionstatechange = () => {
    if (['disconnected', 'failed', 'closed'].includes(G.connectionState)) {
      z.close?.()
    }
  }
  G.ontrack = (j) => {
    z.track?.(j.track, j.streams[0])
    z.stream?.(j.streams[0])
  }
  G.onremovestream = (j) => z.stream?.(j.stream)
  if ($ && !G.canTrickleIceCandidates) {
    G.onnegotiationneeded()
  }
  const L = () => G.getSenders()
  return {
    created: Date.now(),
    connection: G,
    get channel() {
      return Z
    },
    get isDead() {
      return G.connectionState === 'closed'
    },
    async signal(j) {
      if (Z?.readyState === 'open' && !j.sdp?.includes('a=rtpmap')) {
        return
      }
      try {
        if (j.type === qQ) {
          if (U || (G.signalingState !== 'stable' && !X)) {
            if ($) {
              return
            }
            await V0([
              G.setLocalDescription({
                type: 'rollback'
              }),
              G.setRemoteDescription(j)
            ])
          } else {
            await G.setRemoteDescription(j)
          }
          await G.setLocalDescription()
          const K = await N()
          z.signal?.(K)
          return K
        }
        if (j.type === tQ) {
          X = true
          try {
            await G.setRemoteDescription(j)
          } finally {
            X = false
          }
        }
      } catch (K) {
        z.error?.(K)
      }
    },
    sendData: (j) => Z.send(j),
    destroy: () => {
      Z?.close()
      G.close()
      U = X = false
    },
    setHandlers: (j) => Object.assign(z, j),
    offerPromise: $
      ? new Promise((j) => (z.signal = (K) => K.type === qQ && j(K)))
      : Promise.resolve(),
    addStream: (j) => j.getTracks().forEach((K) => G.addTrack(K, j)),
    removeStream: (j) =>
      L()
        .filter((K) => j.getTracks().includes(K.track))
        .forEach((K) => G.removeTrack(K)),
    addTrack: (j, K) => G.addTrack(j, K),
    removeTrack: (j) => {
      const K = L().find((H) => H.track === j)
      if (K) {
        G.removeTrack(K)
      }
    },
    replaceTrack: (j, K) =>
      L()
        .find((H) => H.track === j)
        ?.replaceTrack(K)
  }
}
var $J = Object.getPrototypeOf(Uint8Array)
var w8 = 12
var GQ = 0
var I8 = GQ + w8
var k8 = I8 + 1
var q8 = k8 + 1
var G8 = q8 + 1
var J8 = 16384 - G8
var A8 = 255
var $$ = 'bufferedamountlow'
var h0 = ($) => `@_${$}`
var Q$ = 100
var QJ = 3
var JJ = 200
var zQ = ($, J, q) => {
  const Q = new Map()
  const G = new Map()
  const z = new Map()
  const U = {}
  const X = {}
  const Z = {}
  const V = {}
  const N = new Map()
  const L = (Y, D) => {
    if (!N.has(Y)) {
      N.set(Y, new Set())
    }
    N.get(Y).add(D)
  }
  const j = (Y, D) => N.get(Y)?.delete(D)
  const K = (Y, ...D) => N.get(Y)?.forEach((C) => C(...D))
  const H = (Y, D) => {
    const C = Y ? (Array.isArray(Y) ? Y : [Y]) : Q.keys()
    return Array.from(C, (x) => {
      const T = Q.get(x)
      if (!T) {
        console.warn(`${a}: no peer with id ${x}`)
        return null
      }
      return D(x, T)
    }).filter(Boolean)
  }
  const A = (Y) => {
    if (!Q.has(Y)) {
      return
    }
    Q.delete(Y)
    delete U[Y]
    delete X[Y]
    delete Z[Y]
    delete V[Y]
    K('peer:leave', Y)
    J(Y)
  }
  const E = (Y) =>
    new Promise((D, C) => {
      const x = setTimeout(() => {
        Y.removeEventListener($$, T)
        C(new Error(`${a}: bufferLow timeout`))
      }, 5000)
      function T() {
        clearTimeout(x)
        Y.removeEventListener($$, T)
        D()
      }
      Y.addEventListener($$, T)
    })
  const v = (Y) => {
    if (z.has(Y)) {
      return z.get(Y)
    }
    if (!Y) {
      throw J0('action type is required')
    }
    const D = j0(Y)
    if (D.byteLength > w8) {
      throw J0(`\u274C "${Y}" exceeds ${w8} bytes. Use a shorter name.`)
    }
    const C = new Uint8Array(w8).map((_P, f) => D[f] || 0)
    let x = 0
    const T = new Map([
      ['message', new Set()],
      ['progress', new Set()]
    ])
    const R = (P, f) => T.get(P)?.add(f)
    const g = (P, f) => T.get(P)?.delete(f)
    const k = async (P, f, b, y) => {
      if (b && typeof b !== 'object') {
        throw J0('meta must be object')
      }
      if (P === undefined) {
        throw J0('data cannot be undefined')
      }
      const u = P instanceof Blob
      const F = u || P instanceof ArrayBuffer || P instanceof $J
      const t = typeof P !== 'string'
      if (b && !F) {
        throw J0('meta only allowed with binary')
      }
      const z0 = F
        ? new Uint8Array(u ? await P.arrayBuffer() : P)
        : j0(t ? e(P) : P)
      const r = b ? j0(e(b)) : null
      const d = Math.ceil(z0.byteLength / J8) + (b ? 1 : 0) || 1
      if (d > Q$) {
        throw J0(`Message too large, exceeds max chunks ${Q$}`)
      }
      const G$ = F0(d, (_U8, U0) => {
        const c0 = U0 === d - 1
        const L0 = b && U0 === 0
        const j8 = L0
          ? r
          : z0.subarray(
              b ? (U0 - 1) * J8 : U0 * J8,
              b ? U0 * J8 : (U0 + 1) * J8
            )
        const T0 = new Uint8Array(G8 + j8.byteLength)
        T0.set(C)
        T0.set([x], I8)
        T0.set([c0 | (L0 << 1) | (F << 2) | (t << 3)], k8)
        T0.set([Math.round(((U0 + 1) / d) * A8)], q8)
        T0.set(j8, G8)
        return T0
      })
      x = (x + 1) & A8
      return V0(
        H(f, async (U8, U0) => {
          const { channel: c0 } = U0
          for (let L0 = 0; L0 < d; L0++) {
            let j8 = 0
            while (c0.bufferedAmount > c0.bufferedAmountLowThreshold) {
              if (j8++ > QJ) {
                throw J0(
                  `${a}: send buffer full, max retries reached for peer ${U8}`
                )
              }
              try {
                await E(c0)
              } catch (T0) {
                console.warn(T0.message)
                await new Promise((HQ) => setTimeout(HQ, JJ))
              }
            }
            if (!Q.has(U8)) {
              break
            }
            U0.sendData(G$[L0])
            y?.(G$[L0][q8] / A8, U8, b)
          }
        })
      )
    }
    G.set(Y, {
      listeners: T,
      send: k
    })
    const w = {
      send: k,
      on: R,
      off: g
    }
    z.set(Y, w)
    return w
  }
  const q0 = (Y, D) => {
    try {
      const C = new Uint8Array(D)
      const x = f0(C.subarray(GQ, I8)).replace(/ /g, '')
      if (!G.has(x)) {
        return console.warn(`${a}: unregistered type (${x})`)
      }
      const [T] = C.subarray(I8, k8)
      const [R] = C.subarray(k8, q8)
      const [g] = C.subarray(q8, G8)
      const k = C.subarray(G8)
      const w = Boolean(R & 1)
      const P = Boolean(R & 2)
      const f = Boolean(R & 4)
      const b = Boolean(R & 8)
      const y = G.get(x)
      const u = ((U[Y] ||= {})[x] ||= {})
      if (u[T]?.chunks?.length > Q$) {
        console.warn(
          `${a}: peer ${Y} sent too many chunks for nonce ${T}, ignoring.`
        )
        return
      }
      const F = (u[T] ||= {
        chunks: []
      })
      if (P) {
        try {
          F.meta = v0(f0(k))
        } catch {
          console.warn(
            `${a}: failed to parse meta from peer ${Y} for type ${x}`
          )
          return
        }
      } else {
        F.chunks.push(k)
      }
      y.listeners.get('progress').forEach((r) => {
        try {
          r(g / A8, Y, F.meta)
        } catch (d) {
          console.error(d)
        }
      })
      if (!w) {
        return
      }
      const t = new Uint8Array(F.chunks.reduce((r, d) => r + d.byteLength, 0))
      F.chunks.reduce((r, d) => {
        t.set(d, r)
        return r + d.byteLength
      }, 0)
      delete u[T]
      let z0
      if (f) {
        z0 = t
      } else if (b) {
        try {
          z0 = v0(f0(t))
        } catch {
          console.warn(
            `${a}: failed to parse JSON message data from peer ${Y} for type ${x}`
          )
          return
        }
      } else {
        z0 = f0(t)
      }
      y.listeners.get('message').forEach((r) => {
        try {
          r(z0, Y, F.meta)
        } catch (d) {
          console.error(d)
        }
      })
    } catch (C) {
      console.error(`${a}: error handling data from peer ${Y}:`, C)
    }
  }
  const _ = async () => {
    try {
      await M('')
      await new Promise((Y) => setTimeout(Y, 99))
    } catch (Y) {
      console.warn(`${a}: error sending leave`, Y)
    }
    for (const [Y, D] of Q) {
      try {
        D.destroy()
      } catch {}
      Q.delete(Y)
    }
    q()
  }
  const { send: n, on: c } = v(h0('ping'))
  const { send: s, on: C0 } = v(h0('pong'))
  const { send: G0, on: I } = v(h0('signal'))
  const { send: Y0, on: S } = v(h0('stream'))
  const { send: W, on: O } = v(h0('track'))
  const { send: M, on: B } = v(h0('leave'))
  $((Y, D) => {
    if (Q.has(D)) {
      return
    }
    Q.set(D, Y)
    Y.setHandlers({
      data: (C) => q0(D, C),
      stream: (C) => {
        K('stream:add', C, D, Z[D])
        delete Z[D]
      },
      track: (C, x) => {
        K('track:add', C, x, D, V[D])
        delete V[D]
      },
      signal: (C) => G0(C, D),
      close: () => A(D),
      error: (C) => {
        console.error(`${a}: peer error for ${D}`, C)
        A(D)
      }
    })
    K('peer:join', D)
  })
  c('message', (_Y, D) => s('', D))
  C0('message', (_Y, D) => {
    X[D]?.()
    delete X[D]
  })
  I('message', (Y, D) => Q.get(D)?.signal(Y))
  S('message', (Y, D) => (Z[D] = Y))
  O('message', (Y, D) => (V[D] = Y))
  B('message', (_Y, D) => A(D))
  if (t$) {
    addEventListener('beforeunload', _)
  }
  return {
    on: L,
    off: j,
    channel: v,
    leave: _,
    ping: async (Y) => {
      if (!Y) {
        throw J0('ping() requires target peer ID')
      }
      const D = Date.now()
      n('', Y)
      await new Promise((C) => (X[Y] = C))
      return Date.now() - D
    },
    getPeers: () => R8(Array.from(Q, ([Y, D]) => [Y, D.connection])),
    addStream: (Y, D, C) =>
      H(D, async (x, T) => {
        if (C) {
          await Y0(C, x)
        }
        T.addStream(Y)
      }),
    removeStream: (Y, D) => H(D, (_C, x) => x.removeStream(Y)),
    addTrack: (Y, D, C, x) =>
      H(C, async (T, R) => {
        if (x) {
          await W(x, T)
        }
        R.addTrack(Y, D)
      }),
    removeTrack: (Y, D) => H(D, (_C, x) => x.removeTrack(Y)),
    replaceTrack: (Y, D, C, x) =>
      H(C, async (T, R) => {
        if (x) {
          await W(x, T)
        }
        R.replaceTrack(Y, D)
      })
  }
}
var qJ = 20
var GJ = 5333
var UQ = 57333
var jQ = ({ init: $, subscribe: J, announce: q }) => {
  const Q = {}
  let G = false
  let z
  let U
  return (X, Z, V) => {
    const { appId: N } = X
    if (Q[N]?.[Z]) {
      return Q[N][Z]
    }
    if (!X || !Z || (!N && !X.firebaseApp)) {
      throw J0(
        !X ? 'config required' : !Z ? 'roomId required' : 'appId missing'
      )
    }
    let L = $Q
    if (!G) {
      const S = $(X)
      U = F0(qJ, () => L8(true, X))
      z = Array.isArray(S) ? S : [S]
      const W = setInterval(() => {
        U = U.filter((O) => {
          const M = Date.now() - O.created < UQ
          if (!M) {
            O.destroy()
          }
          return M
        })
      }, UQ)
      Q.offerCleanupTimer ||= W
      G = true
    }
    const j = {}
    const K = {}
    const H = Q8(a, N, Z)
    const A = e0(H)
    const E = e0(Q8(H, N0))
    const v = a$(X.password || '', N, Z)
    const q0 = (S) => async (W) => ({
      type: W.type,
      sdp: await S(v, W.sdp)
    })
    const _ = q0(s$)
    const n = q0(n$)
    const c = (S, W) => {
      if (K[W] === S) {
        return
      }
      K[W]?.destroy()
      K[W] = S
      L(S, W)
      j[W]?.forEach((O) => O !== S && O.destroy())
      delete j[W]
    }
    const s = (S, W) => {
      if (K[W] === S) {
        delete K[W]
      }
    }
    const C0 = (S) => async (W, O, M) => {
      const [B, Y] = await V0([A, E])
      if (W !== B && W !== Y) {
        return
      }
      const {
        peerId: D,
        offer: C,
        answer: x
      } = typeof O === 'string' ? v0(O) : O
      if (D === N0 || K[D]) {
        return
      }
      if (C) {
        if (j[D]?.[S] && N0 > D) {
          return
        }
        const T = L8(false, X)
        T.setHandlers({
          connect: () => c(T, D),
          close: () => s(T, D)
        })
        try {
          const R = await _(C)
          if (T.isDead) {
            return
          }
          const [g, k] = await V0([e0(Q8(H, D)), T.signal(R).then(n)])
          M(
            g,
            e({
              peerId: N0,
              answer: k
            })
          )
        } catch {
          V?.({
            error: 'decryption failed (offer)',
            appId: N,
            peerId: D,
            roomId: Z
          })
        }
      } else if (x) {
        const T = j[D]?.[S]
        if (!T || T.isDead) {
          return
        }
        T.setHandlers({
          connect: () => c(T, D),
          close: () => s(T, D)
        })
        try {
          T.signal(await _(x))
        } catch {
          V?.({
            error: 'decryption failed (answer)',
            appId: N,
            peerId: D,
            roomId: Z
          })
        }
      } else {
        if (j[D]?.[S]) {
          return
        }
        const T = U.pop() || L8(true, X)
        const [R, { offer: g }] = await V0([
          e0(Q8(H, D)),
          T.offerPromise.then(n).then((k) => ({
            offer: k
          }))
        ])
        j[D] ||= []
        j[D][S] = T
        T.setHandlers({
          connect: () => c(T, D),
          close: () => s(T, D)
        })
        M(
          R,
          e({
            peerId: N0,
            offer: g,
            peer: T
          })
        )
      }
    }
    const G0 = V0(z.map(async (S, W) => J(await S, await A, await E, C0(W))))
    const I = []
    G0.then((S) => {
      z.forEach((W, O) => {
        const M = async () => {
          const B = await q(await W, await A, await E)
          I[O] = setTimeout(M, typeof B === 'number' ? B : GJ)
        }
        M()
      })
      Q[N][Z].onCleanup = () => {
        delete Q[N][Z]
        I.forEach(clearTimeout)
        S.forEach((W) => W())
        if (Object.keys(Q).length === 0) {
          clearInterval(Q.offerCleanupTimer)
          delete Q.offerCleanupTimer
        }
      }
    })
    Q[N] ||= {}
    const Y0 = zQ(
      (S) => (L = S),
      (S) => delete K[S],
      () => Y0.onCleanup?.()
    )
    return (Q[N][Z] = Y0)
  }
}
var YQ = 3333
var S8 = {}
var XQ = {}
var ZQ = ($, J) => {
  const q = {}
  let Q = null
  const G = () => {
    if (Q) {
      clearTimeout(Q)
      Q = null
    }
    const z = new WebSocket($)
    z.onclose = () => {
      S8[$] ??= YQ
      Q = setTimeout(G, S8[$])
      S8[$] *= 2
    }
    z.onmessage = (U) => J(U.data)
    q.socket = z
    q.url = z.url
    q.ready = new Promise((U) => {
      z.onopen = () => {
        S8[$] = YQ
        U(q)
      }
    })
    q.send = (U) => {
      if (z.readyState === 1) {
        z.send(U)
      }
    }
  }
  q.forceReconnect = G
  G()
  XQ[$] = q
  return q
}
if (typeof window !== 'undefined') {
  const $ = () => {
    console.info('⚡ [GenosRTC] Network event detected. Forcing reconnection…')
    Object.values(XQ).forEach((J) => {
      if (
        J.socket &&
        J.socket.readyState !== WebSocket.OPEN &&
        J.socket.readyState !== WebSocket.CONNECTING
      ) {
        J.forceReconnect()
      }
    })
  }
  window.addEventListener('online', () => {
    console.info('✅ Reconnected to the network.')
    $()
  })
  window.addEventListener('offline', async () => {
    console.info('❌ Disconnected from the network.')
  })
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible') {
      $()
    }
  })
}
var KQ = ($) => () => R8(e$($).map(([J, q]) => [J, q.socket]))
var MQ = ($, J, q, Q) =>
  ($.relayUrls ?? (Q ? QQ(J, O8($.appId)) : J)).slice(
    0,
    $.relayUrls?.length ?? $.relayRedundancy ?? q
  )
var l0 = {}
var zJ = 5
var VQ = 'x'
var CQ = 'EVENT'
var UJ = /pow:\s*(\d+)\s*bits needed\.?/i
var J$ = new Set()
var TQ = x8.utils.randomSecretKey()
var jJ = H8(x8.getPublicKey(TQ))
var q$ = {}
var z8 = {}
var YJ = {}
var BQ = () => Math.floor(Date.now() / 1000)
var xQ = ($) => (YJ[$] ??= O8($, 10000) + 20000)
var P8 = ($) => $.replace(/\/$/, '')
var XJ = [
  'wss://black.nostrcity.club',
  'wss://eu.purplerelay.com',
  'wss://ftp.halifax.rwth-aachen.de/nostr',
  'wss://nostr.cool110.xyz',
  'wss://nostr.data.haus',
  'wss://nostr.mom',
  'wss://nostr.oxtr.dev',
  'wss://nostr.sathoarder.com',
  'wss://nostr.vulpem.com',
  'wss://relay.agorist.space',
  'wss://relay.binaryrobot.com',
  'wss://relay.fountain.fm',
  'wss://relay.mostro.network',
  'wss://relay.nostraddress.com',
  'wss://relay.nostrdice.com',
  'wss://relay.nostromo.social',
  'wss://relay.oldenburg.cool',
  'wss://relay.snort.social',
  'wss://relay.verified-nostr.com',
  'wss://sendit.nosflare.com',
  'wss://yabu.me/v2',
  'wss://relay.damus.io'
]
var ZJ = ($, J) => {
  const [q, Q, G, z] = v0(J)
  if (q === CQ) {
    return z8[Q]?.(q$[Q], G.content)
  }
  if (q === 'NOTICE' || (q === 'OK' && !G)) {
    if (+((q === 'NOTICE' ? Q : z).match(UJ)?.[1] ?? 0) > 0) {
      const X = P8($)
      J$.add(X)
      l0[X]?.close?.()
      delete l0[X]
    }
  }
}
var KJ = ($) => {
  const J = P8($)
  if (l0[J]) {
    return l0[J]
  }
  const q = ZQ(J, (Q) => ZJ(J, Q))
  return (l0[J] = q)
}
var DQ = async ($, J) => {
  const q = {
    kind: xQ($),
    content: J,
    pubkey: jJ,
    created_at: BQ(),
    tags: [[VQ, $]]
  }
  const Q = j0(e([0, q.pubkey, q.created_at, q.kind, q.tags, q.content]))
  const G = new Uint8Array(await crypto.subtle.digest('SHA-256', Q))
  const z = x8.sign(G, TQ)
  return e([
    CQ,
    {
      ...q,
      id: H8(G),
      sig: H8(z)
    }
  ])
}
var WQ = ($, J) => {
  q$[$] = J
  return e([
    'REQ',
    $,
    {
      kinds: [xQ(J)],
      since: BQ(),
      [`#${VQ}`]: [J]
    }
  ])
}
var NQ = ($) => {
  delete q$[$]
  return e(['CLOSE', $])
}
var MJ = jQ({
  init: ($) => {
    const q = ($?.relayUrls?.length ? $.relayUrls : null) ?? XJ
    return MQ($, q, zJ, true)
      .map(KJ)
      .map((G) => G.ready.then(() => G).catch(() => null))
  },
  subscribe: ($, J, q, Q) => {
    const G = $8(64)
    const z = $8(64)
    z8[G] = z8[z] = (U, X) =>
      Q(U, X, async (Z, V) => {
        if (J$.has(P8($.url))) {
          return
        }
        $.send(await DQ(Z, V))
      })
    $.send(WQ(G, J))
    $.send(WQ(z, q))
    return () => {
      $.send(NQ(G))
      $.send(NQ(z))
      delete z8[G]
      delete z8[z]
    }
  },
  announce: async ($, J) => {
    if (J$.has(P8($.url))) {
      return
    }
    $.send(
      await DQ(
        J,
        e({
          peerId: N0
        })
      )
    )
  }
})
var DJ = KQ(l0)
export { N0 as selfId, MJ as join, DJ as getRelaySockets }
