async function Audit(
  store,
  {
    spamThreshold: spamThresholdParam = 3,
    spamWindowMs: spamWindowMsParam = 2000,
    apiDebounceMs: apiDebounceMsParam = 500,
    sources: sourcesParam = [
      'https://raw.githubusercontent.com/LDNOOBW/List-of-Dirty-Naughty-Obscene-and-Otherwise-Bad-Words/master/es',
      'https://raw.githubusercontent.com/LDNOOBW/List-of-Dirty-Naughty-Obscene-and-Otherwise-Bad-Words/master/en'
    ]
  } = {}
) {
  const hardcodedWords = ['gay', 'boludo', 'gilipollas', 'cabron'].map(
    normalize
  )
  const bannedWordsSet = new Set(hardcodedWords)
  try {
    const fetchedWords = await loadBannedWords(sourcesParam)
    for (const word of fetchedWords) {
      bannedWordsSet.add(word)
    }
  } catch {
    console.warn('üõ°Ô∏è Audit: Could not load the banned terms list.')
  }
  const containsBannedContent = (nodeValue) =>
    typeof nodeValue === 'string'
      ? extractWords(nodeValue).some((word) => bannedWordsSet.has(word))
      : Array.isArray(nodeValue)
        ? nodeValue.some(containsBannedContent)
        : nodeValue && typeof nodeValue === 'object'
          ? Object.values(nodeValue).some(containsBannedContent)
          : false
  const pendingNodes = new Map()
  const processBannedContent = debounce(() => {
    for (const [nodeId, nodeValue] of pendingNodes) {
      if (nodeValue && containsBannedContent(nodeValue)) {
        store.remove?.(nodeId)
        store.oplog?.remove?.(nodeId)
        console.log(
          `\uD83D\uDEE1\uFE0F Audit: Node removed due to banned content \u2192 ${nodeId}`
        )
      }
    }
    pendingNodes.clear()
  }, apiDebounceMsParam)
  let recentOps = []
  let lastTimestamp = 0
  const processSpamDetection = debounce(() => {
    if (recentOps.length >= spamThresholdParam) {
      console.log(
        `\uD83D\uDEE1\uFE0F Audit: Spam detected (${recentOps.length} ops in ${spamWindowMsParam / 1000}s) [${recentOps.map((op) => op.id).join(', ')}]`
      )
      for (const op of recentOps) {
        store.remove?.(op.id)
        store.oplog?.remove?.(op.id)
      }
    }
    recentOps = []
    lastTimestamp = 0
  }, apiDebounceMsParam)
  const { unsubscribe } = store.map?.(
    ({ id: nodeId, value: nodeValue, action, timestamp }) => {
      if ((action === 'added' || action === 'updated') && nodeValue) {
        pendingNodes.set(nodeId, nodeValue)
        processBannedContent()
        const currentTimestamp = timestamp.physical
        recentOps =
          lastTimestamp && currentTimestamp - lastTimestamp < spamWindowMsParam
            ? [
                ...recentOps,
                {
                  id: nodeId,
                  ts: currentTimestamp
                }
              ]
            : [
                {
                  id: nodeId,
                  ts: currentTimestamp
                }
              ]
        lastTimestamp = currentTimestamp
        processSpamDetection()
      }
    }
  ) ?? {
    unsubscribe: () => {}
  }
  return {
    stop: () => unsubscribe?.()
  }
}
var debounce = (func, delay = 500) => {
  let timeoutId
  return (...args) => {
    clearTimeout(timeoutId)
    timeoutId = setTimeout(() => func(...args), delay)
  }
}
var normalize = (text) =>
  text.toLowerCase().normalize('NFD').replace(/\p{M}/gu, '')
var extractWords = (text) => normalize(text).match(/\p{L}+/gu) || []
var fetchWithTimeout = async (url, timeout = 10000) => {
  const abortController = new AbortController()
  const timeoutId = setTimeout(() => abortController.abort(), timeout)
  try {
    const response = await fetch(url, {
      mode: 'cors',
      cache: 'no-cache'
    })
    if (response.ok) {
      return await response.text()
    } else {
      return ''
    }
  } finally {
    clearTimeout(timeoutId)
  }
}
var loadBannedWords = async (sources) =>
  new Set(
    (await Promise.all(sources.map(fetchWithTimeout)))
      .flatMap((text) =>
        text
          .split(/\r?\n/)
          .map((word) => word.trim())
          .filter(Boolean)
      )
      .map(normalize)
  )
var init = (store) => {
  console.log('üõ°Ô∏è Audit module loaded.')
  return Audit(store)
}
export { init, debounce, Audit }
