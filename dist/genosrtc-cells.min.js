var F0=typeof globalThis==="object"&&("crypto"in globalThis)?globalThis.crypto:void 0;function m0($){return $ instanceof Uint8Array||ArrayBuffer.isView($)&&$.constructor.name==="Uint8Array"}function X8($){if(!Number.isSafeInteger($)||$<0)throw new Error("positive integer expected, got "+$)}function B0($,...J){if(!m0($))throw new Error("Uint8Array expected");if(J.length>0&&!J.includes($.length))throw new Error("Uint8Array expected of length "+J+", got length="+$.length)}function w8($){if(typeof $!=="function"||typeof $.create!=="function")throw new Error("Hash should be wrapped by utils.createHasher");X8($.outputLen),X8($.blockLen)}function e0($,J=!0){if($.destroyed)throw new Error("Hash instance has been destroyed");if(J&&$.finished)throw new Error("Hash#digest() has already been called")}function P$($,J){B0($);const q=J.outputLen;if($.length<q)throw new Error("digestInto() expects output buffer of length at least "+q)}function h0(...$){for(let J=0;J<$.length;J++)$[J].fill(0)}function C8($){return new DataView($.buffer,$.byteOffset,$.byteLength)}function O0($,J){return $<<32-J|$>>>J}function k0($){if(B0($),I$)return $.toHex();let J="";for(let q=0;q<$.length;q++)J+=nQ[$[q]];return J}var S$=function($){if($>=C0._0&&$<=C0._9)return $-C0._0;if($>=C0.A&&$<=C0.F)return $-(C0.A-10);if($>=C0.a&&$<=C0.f)return $-(C0.a-10);return};function c0($){if(typeof $!=="string")throw new Error("hex string expected, got "+typeof $);if(I$)return Uint8Array.fromHex($);const J=$.length,q=J/2;if(J%2)throw new Error("hex string expected, got unpadded hex of length "+J);const Q=new Uint8Array(q);for(let G=0,U=0;G<q;G++,U+=2){const Y=S$($.charCodeAt(U)),Z=S$($.charCodeAt(U+1));if(Y===void 0||Z===void 0){const X=$[U]+$[U+1];throw new Error('hex string expected, got non-hex character "'+X+'" at index '+U)}Q[G]=Y*16+Z}return Q}function k8($){if(typeof $!=="string")throw new Error("string expected");return new Uint8Array((new TextEncoder()).encode($))}function z8($){if(typeof $==="string")$=k8($);return B0($),$}function z0(...$){let J=0;for(let Q=0;Q<$.length;Q++){const G=$[Q];B0(G),J+=G.length}const q=new Uint8Array(J);for(let Q=0,G=0;Q<$.length;Q++){const U=$[Q];q.set(U,G),G+=U.length}return q}function E$($){const J=(Q)=>$().update(z8(Q)).digest(),q=$();return J.outputLen=q.outputLen,J.blockLen=q.blockLen,J.create=()=>$(),J}function l0($=32){if(F0&&typeof F0.getRandomValues==="function")return F0.getRandomValues(new Uint8Array($));if(F0&&typeof F0.randomBytes==="function")return Uint8Array.from(F0.randomBytes($));throw new Error("crypto.getRandomValues must be defined")}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */var I$=(()=>typeof Uint8Array.from([]).toHex==="function"&&typeof Uint8Array.fromHex==="function")(),nQ=Array.from({length:256},($,J)=>J.toString(16).padStart(2,"0")),C0={_0:48,_9:57,A:65,F:70,a:97,f:102};class K8{}function sQ($,J,q,Q){if(typeof $.setBigUint64==="function")return $.setBigUint64(J,q,Q);const G=BigInt(32),U=BigInt(4294967295),Y=Number(q>>G&U),Z=Number(q&U),X=Q?4:0,N=Q?0:4;$.setUint32(J+X,Y,Q),$.setUint32(J+N,Z,Q)}function v$($,J,q){return $&J^~$&q}function _$($,J,q){return $&J^$&q^J&q}class e8 extends K8{constructor($,J,q,Q){super();this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=$,this.outputLen=J,this.padOffset=q,this.isLE=Q,this.buffer=new Uint8Array($),this.view=C8(this.buffer)}update($){e0(this),$=z8($),B0($);const{view:J,buffer:q,blockLen:Q}=this,G=$.length;for(let U=0;U<G;){const Y=Math.min(Q-this.pos,G-U);if(Y===Q){const Z=C8($);for(;Q<=G-U;U+=Q)this.process(Z,U);continue}if(q.set($.subarray(U,U+Y),this.pos),this.pos+=Y,U+=Y,this.pos===Q)this.process(J,0),this.pos=0}return this.length+=$.length,this.roundClean(),this}digestInto($){e0(this),P$($,this),this.finished=!0;const{buffer:J,view:q,blockLen:Q,isLE:G}=this;let{pos:U}=this;if(J[U++]=128,h0(this.buffer.subarray(U)),this.padOffset>Q-U)this.process(q,0),U=0;for(let K=U;K<Q;K++)J[K]=0;sQ(q,Q-8,BigInt(this.length*8),G),this.process(q,0);const Y=C8($),Z=this.outputLen;if(Z%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const X=Z/4,N=this.get();if(X>N.length)throw new Error("_sha2: outputLen bigger than state");for(let K=0;K<X;K++)Y.setUint32(4*K,N[K],G)}digest(){const{buffer:$,outputLen:J}=this;this.digestInto($);const q=$.slice(0,J);return this.destroy(),q}_cloneInto($){$||($=new this.constructor),$.set(...this.get());const{blockLen:J,buffer:q,length:Q,finished:G,destroyed:U,pos:Y}=this;if($.destroyed=U,$.finished=G,$.length=Q,$.pos=Y,Q%J)$.buffer.set(q);return $}clone(){return this._cloneInto()}}var S0=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]);var tQ=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),f0=new Uint32Array(64);class f$ extends e8{constructor($=32){super(64,$,8,!1);this.A=S0[0]|0,this.B=S0[1]|0,this.C=S0[2]|0,this.D=S0[3]|0,this.E=S0[4]|0,this.F=S0[5]|0,this.G=S0[6]|0,this.H=S0[7]|0}get(){const{A:$,B:J,C:q,D:Q,E:G,F:U,G:Y,H:Z}=this;return[$,J,q,Q,G,U,Y,Z]}set($,J,q,Q,G,U,Y,Z){this.A=$|0,this.B=J|0,this.C=q|0,this.D=Q|0,this.E=G|0,this.F=U|0,this.G=Y|0,this.H=Z|0}process($,J){for(let K=0;K<16;K++,J+=4)f0[K]=$.getUint32(J,!1);for(let K=16;K<64;K++){const w=f0[K-15],j=f0[K-2],z=O0(w,7)^O0(w,18)^w>>>3,L=O0(j,17)^O0(j,19)^j>>>10;f0[K]=L+f0[K-7]+z+f0[K-16]|0}let{A:q,B:Q,C:G,D:U,E:Y,F:Z,G:X,H:N}=this;for(let K=0;K<64;K++){const w=O0(Y,6)^O0(Y,11)^O0(Y,25),j=N+w+v$(Y,Z,X)+tQ[K]+f0[K]|0,L=(O0(q,2)^O0(q,13)^O0(q,22))+_$(q,Q,G)|0;N=X,X=Z,Z=Y,Y=U+j|0,U=G,G=Q,Q=q,q=j+L|0}q=q+this.A|0,Q=Q+this.B|0,G=G+this.C|0,U=U+this.D|0,Y=Y+this.E|0,Z=Z+this.F|0,X=X+this.G|0,N=N+this.H|0,this.set(q,Q,G,U,Y,Z,X,N)}roundClean(){h0(f0)}destroy(){this.set(0,0,0,0,0,0,0,0),h0(this.buffer)}}var S8=E$(()=>new f$);class $$ extends K8{constructor($,J){super();this.finished=!1,this.destroyed=!1,w8($);const q=z8(J);if(this.iHash=$.create(),typeof this.iHash.update!=="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const Q=this.blockLen,G=new Uint8Array(Q);G.set(q.length>Q?$.create().update(q).digest():q);for(let U=0;U<G.length;U++)G[U]^=54;this.iHash.update(G),this.oHash=$.create();for(let U=0;U<G.length;U++)G[U]^=54^92;this.oHash.update(G),h0(G)}update($){return e0(this),this.iHash.update($),this}digestInto($){e0(this),B0($,this.outputLen),this.finished=!0,this.iHash.digestInto($),this.oHash.update($),this.oHash.digestInto($),this.destroy()}digest(){const $=new Uint8Array(this.oHash.outputLen);return this.digestInto($),$}_cloneInto($){$||($=Object.create(Object.getPrototypeOf(this),{}));const{oHash:J,iHash:q,finished:Q,destroyed:G,blockLen:U,outputLen:Y}=this;return $=$,$.finished=Q,$.destroyed=G,$.blockLen=U,$.outputLen=Y,$.oHash=J._cloneInto($.oHash),$.iHash=q._cloneInto($.iHash),$}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}var Q$=($,J,q)=>new $$($,J).update(q).digest();Q$.create=($,J)=>new $$($,J);function D8($,J=""){if(typeof $!=="boolean"){const q=J&&`"${J}"`;throw new Error(q+"expected boolean, got type="+typeof $)}return $}function b0($,J,q=""){const Q=m0($),G=$?.length,U=J!==void 0;if(!Q||U&&G!==J){const Y=q&&`"${q}" `,Z=U?` of length ${J}`:"",X=Q?`length=${G}`:`type=${typeof $}`;throw new Error(Y+"expected Uint8Array"+Z+", got "+X)}return $}function W8($){const J=$.toString(16);return J.length&1?"0"+J:J}function b$($){if(typeof $!=="string")throw new Error("hex string expected, got "+typeof $);return $===""?G$:BigInt("0x"+$)}function P0($){return b$(k0($))}function U$($){return B0($),b$(k0(Uint8Array.from($).reverse()))}function $8($,J){return c0($.toString(16).padStart(J*2,"0"))}function Y$($,J){return $8($,J).reverse()}function o($,J,q){let Q;if(typeof J==="string")try{Q=c0(J)}catch(U){throw new Error($+" must be hex string or Uint8Array, cause: "+U)}else if(m0(J))Q=Uint8Array.from(J);else throw new Error($+" must be hex string or Uint8Array");const G=Q.length;if(typeof q==="number"&&G!==q)throw new Error($+" of length "+q+" expected, got "+G);return Q}function M8($,J,q){return J$($)&&J$(J)&&J$(q)&&J<=$&&$<q}function y$($,J,q,Q){if(!M8(J,q,Q))throw new Error("expected valid "+$+": "+q+" <= n < "+Q+", got "+J)}function P8($){let J;for(J=0;$>G$;$>>=q$,J+=1);return J}function g$($,J,q){if(typeof $!=="number"||$<2)throw new Error("hashLen must be a number");if(typeof J!=="number"||J<2)throw new Error("qByteLen must be a number");if(typeof q!=="function")throw new Error("hmacFn must be a function");const Q=(z)=>new Uint8Array(z),G=(z)=>Uint8Array.of(z);let U=Q($),Y=Q($),Z=0;const X=()=>{U.fill(1),Y.fill(0),Z=0},N=(...z)=>q(Y,U,...z),K=(z=Q(0))=>{if(Y=N(G(0),z),U=N(),z.length===0)return;Y=N(G(1),z),U=N()},w=()=>{if(Z++>=1000)throw new Error("drbg: tried 1000 values");let z=0;const L=[];while(z<J){U=N();const k=U.slice();L.push(k),z+=U.length}return z0(...L)};return(z,L)=>{X(),K(z);let k=void 0;while(!(k=L(w())))K();return X(),k}}function V8($,J,q={}){if(!$||typeof $!=="object")throw new Error("expected valid options object");function Q(G,U,Y){const Z=$[G];if(Y&&Z===void 0)return;const X=typeof Z;if(X!==U||Z===null)throw new Error(`param "${G}" is invalid: expected ${U}, got ${X}`)}Object.entries(J).forEach(([G,U])=>Q(G,U,!1)),Object.entries(q).forEach(([G,U])=>Q(G,U,!0))}function j$($){const J=new WeakMap;return(q,...Q)=>{const G=J.get(q);if(G!==void 0)return G;const U=$(q,...Q);return J.set(q,U),U}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var G$=BigInt(0),q$=BigInt(1),J$=($)=>typeof $==="bigint"&&G$<=$,y0=($)=>(q$<<BigInt($))-q$;function D0($,J){const q=$%J;return q>=Y0?q:J+q}function W0($,J,q){let Q=$;while(J-- >Y0)Q*=Q,Q%=q;return Q}function u$($,J){if($===Y0)throw new Error("invert: expected non-zero number");if(J<=Y0)throw new Error("invert: expected positive modulus, got "+J);let q=D0($,J),Q=J,G=Y0,U=G0,Y=G0,Z=Y0;while(q!==Y0){const N=Q/q,K=Q%q,w=G-Y*N,j=U-Z*N;Q=q,q=K,G=Y,U=Z,Y=w,Z=j}if(Q!==G0)throw new Error("invert: does not exist");return D0(G,J)}var Z$=function($,J,q){if(!$.eql($.sqr(J),q))throw new Error("Cannot find square root")},o$=function($,J){const q=($.ORDER+G0)/h$,Q=$.pow(J,q);return Z$($,Q,J),Q},Q1=function($,J){const q=($.ORDER-c$)/l$,Q=$.mul(J,d0),G=$.pow(Q,q),U=$.mul(J,G),Y=$.mul($.mul(U,d0),G),Z=$.mul(U,$.sub(Y,$.ONE));return Z$($,Z,J),Z},J1=function($){const J=g0($),q=p$($),Q=q(J,J.neg(J.ONE)),G=q(J,Q),U=q(J,J.neg(Q)),Y=($+eQ)/d$;return(Z,X)=>{let N=Z.pow(X,Y),K=Z.mul(N,Q);const w=Z.mul(N,G),j=Z.mul(N,U),z=Z.eql(Z.sqr(K),X),L=Z.eql(Z.sqr(w),X);N=Z.cmov(N,K,z),K=Z.cmov(j,w,L);const k=Z.eql(Z.sqr(K),X),S=Z.cmov(N,K,k);return Z$(Z,S,X),S}};function p$($){if($<m$)throw new Error("sqrt is not defined for small field");let J=$-G0,q=0;while(J%d0===Y0)J/=d0,q++;let Q=d0;const G=g0($);while(F$(G,Q)===1)if(Q++>1000)throw new Error("Cannot find square root: probably non-prime P");if(q===1)return o$;let U=G.pow(Q,J);const Y=(J+G0)/d0;return function Z(X,N){if(X.is0(N))return N;if(F$(X,N)!==1)throw new Error("Cannot find square root");let K=q,w=X.mul(X.ONE,U),j=X.pow(N,J),z=X.pow(N,Y);while(!X.eql(j,X.ONE)){if(X.is0(j))return X.ZERO;let L=1,k=X.sqr(j);while(!X.eql(k,X.ONE))if(L++,k=X.sqr(k),L===K)throw new Error("Cannot find square root");const S=G0<<BigInt(K-L-1),g=X.pow(w,S);K=L,w=X.sqr(g),j=X.mul(j,w),z=X.mul(z,g)}return z}}function q1($){if($%h$===m$)return o$;if($%l$===c$)return Q1;if($%d$===$1)return J1($);return p$($)}function X$($){const J={ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"},q=G1.reduce((Q,G)=>{return Q[G]="function",Q},J);return V8($,q),$}function U1($,J,q){if(q<Y0)throw new Error("invalid exponent, negatives unsupported");if(q===Y0)return $.ONE;if(q===G0)return J;let Q=$.ONE,G=J;while(q>Y0){if(q&G0)Q=$.mul(Q,G);G=$.sqr(G),q>>=G0}return Q}function I8($,J,q=!1){const Q=new Array(J.length).fill(q?$.ZERO:void 0),G=J.reduce((Y,Z,X)=>{if($.is0(Z))return Y;return Q[X]=Y,$.mul(Y,Z)},$.ONE),U=$.inv(G);return J.reduceRight((Y,Z,X)=>{if($.is0(Z))return Y;return Q[X]=$.mul(Y,Q[X]),$.mul(Y,Z)},U),Q}function F$($,J){const q=($.ORDER-G0)/d0,Q=$.pow(J,q),G=$.eql(Q,$.ONE),U=$.eql(Q,$.ZERO),Y=$.eql(Q,$.neg($.ONE));if(!G&&!U&&!Y)throw new Error("invalid Legendre symbol result");return G?1:U?0:-1}function E8($,J){if(J!==void 0)X8(J);const q=J!==void 0?J:$.toString(2).length,Q=Math.ceil(q/8);return{nBitLength:q,nByteLength:Q}}function g0($,J,q=!1,Q={}){if($<=Y0)throw new Error("invalid field: expected ORDER > 0, got "+$);let G=void 0,U=void 0,Y=!1,Z=void 0;if(typeof J==="object"&&J!=null){if(Q.sqrt||q)throw new Error("cannot specify opts in two arguments");const j=J;if(j.BITS)G=j.BITS;if(j.sqrt)U=j.sqrt;if(typeof j.isLE==="boolean")q=j.isLE;if(typeof j.modFromBytes==="boolean")Y=j.modFromBytes;Z=j.allowedLengths}else{if(typeof J==="number")G=J;if(Q.sqrt)U=Q.sqrt}const{nBitLength:X,nByteLength:N}=E8($,G);if(N>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let K;const w=Object.freeze({ORDER:$,isLE:q,BITS:X,BYTES:N,MASK:y0(X),ZERO:Y0,ONE:G0,allowedLengths:Z,create:(j)=>D0(j,$),isValid:(j)=>{if(typeof j!=="bigint")throw new Error("invalid field element: expected bigint, got "+typeof j);return Y0<=j&&j<$},is0:(j)=>j===Y0,isValidNot0:(j)=>!w.is0(j)&&w.isValid(j),isOdd:(j)=>(j&G0)===G0,neg:(j)=>D0(-j,$),eql:(j,z)=>j===z,sqr:(j)=>D0(j*j,$),add:(j,z)=>D0(j+z,$),sub:(j,z)=>D0(j-z,$),mul:(j,z)=>D0(j*z,$),pow:(j,z)=>U1(w,j,z),div:(j,z)=>D0(j*u$(z,$),$),sqrN:(j)=>j*j,addN:(j,z)=>j+z,subN:(j,z)=>j-z,mulN:(j,z)=>j*z,inv:(j)=>u$(j,$),sqrt:U||((j)=>{if(!K)K=q1($);return K(w,j)}),toBytes:(j)=>q?Y$(j,N):$8(j,N),fromBytes:(j,z=!0)=>{if(Z){if(!Z.includes(j.length)||j.length>N)throw new Error("Field.fromBytes: expected "+Z+" bytes, got "+j.length);const k=new Uint8Array(N);k.set(j,q?0:k.length-j.length),j=k}if(j.length!==N)throw new Error("Field.fromBytes: expected "+N+" bytes, got "+j.length);let L=q?U$(j):P0(j);if(Y)L=D0(L,$);if(!z){if(!w.isValid(L))throw new Error("invalid field element: outside of range 0..ORDER")}return L},invertBatch:(j)=>I8(w,j),cmov:(j,z,L)=>L?z:j});return Object.freeze(w)}function i$($){if(typeof $!=="bigint")throw new Error("field order must be bigint");const J=$.toString(2).length;return Math.ceil(J/8)}function z$($){const J=i$($);return J+Math.ceil(J/2)}function v8($,J,q=!1){const Q=$.length,G=i$(J),U=z$(J);if(Q<16||Q<U||Q>1024)throw new Error("expected "+U+"-1024 bytes of input, got "+Q);const Y=q?U$($):P0($),Z=D0(Y,J-G0)+G0;return q?Y$(Z,G):$8(Z,G)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var Y0=BigInt(0),G0=BigInt(1),d0=BigInt(2),m$=BigInt(3),h$=BigInt(4),c$=BigInt(5),eQ=BigInt(7),l$=BigInt(8),$1=BigInt(9),d$=BigInt(16);var G1=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function N8($,J){const q=J.negate();return $?q:J}function _8($,J){const q=I8($.Fp,J.map((Q)=>Q.Z));return J.map((Q,G)=>$.fromAffine(Q.toAffine(q[G])))}var s$=function($,J){if(!Number.isSafeInteger($)||$<=0||$>J)throw new Error("invalid window size, expected [1.."+J+"], got W="+$)},K$=function($,J){s$($,J);const q=Math.ceil(J/$)+1,Q=2**($-1),G=2**$,U=y0($),Y=BigInt($);return{windows:q,windowSize:Q,mask:U,maxNumber:G,shiftBy:Y}},r$=function($,J,q){const{windowSize:Q,mask:G,maxNumber:U,shiftBy:Y}=q;let Z=Number($&G),X=$>>Y;if(Z>Q)Z-=U,X+=o0;const N=J*Q,K=N+Math.abs(Z)-1,w=Z===0,j=Z<0,z=J%2!==0;return{nextN:X,offset:K,isZero:w,isNeg:j,isNegF:z,offsetF:N}},Y1=function($,J){if(!Array.isArray($))throw new Error("array expected");$.forEach((q,Q)=>{if(!(q instanceof J))throw new Error("invalid point at index "+Q)})},j1=function($,J){if(!Array.isArray($))throw new Error("array of scalars expected");$.forEach((q,Q)=>{if(!J.isValid(q))throw new Error("invalid scalar at index "+Q)})},W$=function($){return t$.get($)||1},a$=function($){if($!==Q8)throw new Error("invalid wNAF")};function e$($,J,q,Q){let G=J,U=$.ZERO,Y=$.ZERO;while(q>Q8||Q>Q8){if(q&o0)U=U.add(G);if(Q&o0)Y=Y.add(G);G=G.double(),q>>=o0,Q>>=o0}return{p1:U,p2:Y}}function $Q($,J,q,Q){Y1(q,$),j1(Q,J);const G=q.length,U=Q.length;if(G!==U)throw new Error("arrays of points and scalars must have equal length");const Y=$.ZERO,Z=P8(BigInt(G));let X=1;if(Z>12)X=Z-3;else if(Z>4)X=Z-2;else if(Z>0)X=2;const N=y0(X),K=new Array(Number(N)+1).fill(Y),w=Math.floor((J.BITS-1)/X)*X;let j=Y;for(let z=w;z>=0;z-=X){K.fill(Y);for(let k=0;k<U;k++){const S=Q[k],g=Number(S>>BigInt(z)&N);K[g]=K[g].add(q[k])}let L=Y;for(let k=K.length-1,S=Y;k>0;k--)S=S.add(K[k]),L=L.add(S);if(j=j.add(L),z!==0)for(let k=0;k<X;k++)j=j.double()}return j}var n$=function($,J,q){if(J){if(J.ORDER!==$)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return X$(J),J}else return g0($,{isLE:q})};function QQ($,J,q={},Q){if(Q===void 0)Q=$==="edwards";if(!J||typeof J!=="object")throw new Error(`expected valid ${$} CURVE object`);for(let X of["p","n","h"]){const N=J[X];if(!(typeof N==="bigint"&&N>Q8))throw new Error(`CURVE.${X} must be positive bigint`)}const G=n$(J.p,q.Fp,Q),U=n$(J.n,q.Fn,Q),Z=["Gx","Gy","a",$==="weierstrass"?"b":"d"];for(let X of Z)if(!G.isValid(J[X]))throw new Error(`CURVE.${X} must be valid field element of CURVE.Fp`);return J=Object.freeze(Object.assign({},J)),{CURVE:J,Fp:G,Fn:U}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var Q8=BigInt(0),o0=BigInt(1),D$=new WeakMap,t$=new WeakMap;class M${constructor($,J){this.BASE=$.BASE,this.ZERO=$.ZERO,this.Fn=$.Fn,this.bits=J}_unsafeLadder($,J,q=this.ZERO){let Q=$;while(J>Q8){if(J&o0)q=q.add(Q);Q=Q.double(),J>>=o0}return q}precomputeWindow($,J){const{windows:q,windowSize:Q}=K$(J,this.bits),G=[];let U=$,Y=U;for(let Z=0;Z<q;Z++){Y=U,G.push(Y);for(let X=1;X<Q;X++)Y=Y.add(U),G.push(Y);U=Y.double()}return G}wNAF($,J,q){if(!this.Fn.isValid(q))throw new Error("invalid scalar");let Q=this.ZERO,G=this.BASE;const U=K$($,this.bits);for(let Y=0;Y<U.windows;Y++){const{nextN:Z,offset:X,isZero:N,isNeg:K,isNegF:w,offsetF:j}=r$(q,Y,U);if(q=Z,N)G=G.add(N8(w,J[j]));else Q=Q.add(N8(K,J[X]))}return a$(q),{p:Q,f:G}}wNAFUnsafe($,J,q,Q=this.ZERO){const G=K$($,this.bits);for(let U=0;U<G.windows;U++){if(q===Q8)break;const{nextN:Y,offset:Z,isZero:X,isNeg:N}=r$(q,U,G);if(q=Y,X)continue;else{const K=J[Z];Q=Q.add(N?K.negate():K)}}return a$(q),Q}getPrecomputes($,J,q){let Q=D$.get(J);if(!Q){if(Q=this.precomputeWindow(J,$),$!==1){if(typeof q==="function")Q=q(Q);D$.set(J,Q)}}return Q}cached($,J,q){const Q=W$($);return this.wNAF(Q,this.getPrecomputes(Q,$,q),J)}unsafe($,J,q,Q){const G=W$($);if(G===1)return this._unsafeLadder($,J,Q);return this.wNAFUnsafe(G,this.getPrecomputes(G,$,q),J,Q)}createCache($,J){s$(J,this.bits),t$.set($,J),D$.delete($)}hasCache($){return W$($)!==1}}function Z1($,J,q){const[[Q,G],[U,Y]]=J,Z=JQ(Y*$,q),X=JQ(-G*$,q);let N=$-Z*Q-X*U,K=-Z*G-X*Y;const w=N<E0,j=K<E0;if(w)N=-N;if(j)K=-K;const z=y0(Math.ceil(P8(q)/2))+J8;if(N<E0||N>=z||K<E0||K>=z)throw new Error("splitScalar (endomorphism): failed, k="+$);return{k1neg:w,k1:N,k2neg:j,k2:K}}var N$=function($){if(!["compact","recovered","der"].includes($))throw new Error('Signature format must be "compact", "recovered", or "der"');return $},V$=function($,J){const q={};for(let Q of Object.keys(J))q[Q]=$[Q]===void 0?J[Q]:$[Q];if(D8(q.lowS,"lowS"),D8(q.prehash,"prehash"),q.format!==void 0)N$(q.format);return q};function u0($,J){const{BYTES:q}=$;let Q;if(typeof J==="bigint")Q=J;else{let G=o("private key",J);try{Q=$.fromBytes(G)}catch(U){throw new Error(`invalid private key: expected ui8a of size ${q}, got ${typeof J}`)}}if(!$.isValidNot0(Q))throw new Error("invalid private key: out of range [1..N-1]");return Q}function z1($,J={}){const q=QQ("weierstrass",$,J),{Fp:Q,Fn:G}=q;let U=q.CURVE;const{h:Y,n:Z}=U;V8(J,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:X}=J;if(X){if(!Q.is0(U.a)||typeof X.beta!=="bigint"||!Array.isArray(X.basises))throw new Error('invalid endo: expected "beta": bigint and "basises": array')}const N=YQ(Q,G);function K(){if(!Q.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function w(V,T,M){const{x:R,y:D}=T.toAffine(),W=Q.toBytes(R);if(D8(M,"isCompressed"),M){K();const O=!Q.isOdd(D);return z0(UQ(O),W)}else return z0(Uint8Array.of(4),W,Q.toBytes(D))}function j(V){b0(V,void 0,"Point");const{publicKey:T,publicKeyUncompressed:M}=N,R=V.length,D=V[0],W=V.subarray(1);if(R===T&&(D===2||D===3)){const O=Q.fromBytes(W);if(!Q.isValid(O))throw new Error("bad point: is not on curve, wrong x");const H=k(O);let x;try{x=Q.sqrt(H)}catch(f){const _=f instanceof Error?": "+f.message:"";throw new Error("bad point: is not on curve, sqrt error"+_)}K();const C=Q.isOdd(x);if((D&1)===1!==C)x=Q.neg(x);return{x:O,y:x}}else if(R===M&&D===4){const O=Q.BYTES,H=Q.fromBytes(W.subarray(0,O)),x=Q.fromBytes(W.subarray(O,O*2));if(!S(H,x))throw new Error("bad point: is not on curve");return{x:H,y:x}}else throw new Error(`bad point: got length ${R}, expected compressed=${T} or uncompressed=${M}`)}const z=J.toBytes||w,L=J.fromBytes||j;function k(V){const T=Q.sqr(V),M=Q.mul(T,V);return Q.add(Q.add(M,Q.mul(V,U.a)),U.b)}function S(V,T){const M=Q.sqr(T),R=k(V);return Q.eql(M,R)}if(!S(U.Gx,U.Gy))throw new Error("bad curve params: generator point");const g=Q.mul(Q.pow(U.a,f8),X1),s=Q.mul(Q.sqr(U.b),BigInt(27));if(Q.is0(Q.add(g,s)))throw new Error("bad curve params: a or b");function F(V,T,M=!1){if(!Q.isValid(T)||M&&Q.is0(T))throw new Error(`bad point coordinate ${V}`);return T}function r(V){if(!(V instanceof I))throw new Error("ProjectivePoint expected")}function J0(V){if(!X||!X.basises)throw new Error("no endo");return Z1(V,X.basises,G.ORDER)}const q0=j$((V,T)=>{const{X:M,Y:R,Z:D}=V;if(Q.eql(D,Q.ONE))return{x:M,y:R};const W=V.is0();if(T==null)T=W?Q.ONE:Q.inv(D);const O=Q.mul(M,T),H=Q.mul(R,T),x=Q.mul(D,T);if(W)return{x:Q.ZERO,y:Q.ZERO};if(!Q.eql(x,Q.ONE))throw new Error("invZ was invalid");return{x:O,y:H}}),V0=j$((V)=>{if(V.is0()){if(J.allowInfinityPoint&&!Q.is0(V.Y))return;throw new Error("bad point: ZERO")}const{x:T,y:M}=V.toAffine();if(!Q.isValid(T)||!Q.isValid(M))throw new Error("bad point: x or y not field elements");if(!S(T,M))throw new Error("bad point: equation left != right");if(!V.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function U0(V,T,M,R,D){return M=new I(Q.mul(M.X,V),M.Y,M.Z),T=N8(R,T),M=N8(D,M),T.add(M)}class I{constructor(V,T,M){this.X=F("x",V),this.Y=F("y",T,!0),this.Z=F("z",M),Object.freeze(this)}static CURVE(){return U}static fromAffine(V){const{x:T,y:M}=V||{};if(!V||!Q.isValid(T)||!Q.isValid(M))throw new Error("invalid affine point");if(V instanceof I)throw new Error("projective point not allowed");if(Q.is0(T)&&Q.is0(M))return I.ZERO;return new I(T,M,Q.ONE)}static fromBytes(V){const T=I.fromAffine(L(b0(V,void 0,"point")));return T.assertValidity(),T}static fromHex(V){return I.fromBytes(o("pointHex",V))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(V=8,T=!0){if(E.createCache(this,V),!T)this.multiply(f8);return this}assertValidity(){V0(this)}hasEvenY(){const{y:V}=this.toAffine();if(!Q.isOdd)throw new Error("Field doesn't support isOdd");return!Q.isOdd(V)}equals(V){r(V);const{X:T,Y:M,Z:R}=this,{X:D,Y:W,Z:O}=V,H=Q.eql(Q.mul(T,O),Q.mul(D,R)),x=Q.eql(Q.mul(M,O),Q.mul(W,R));return H&&x}negate(){return new I(this.X,Q.neg(this.Y),this.Z)}double(){const{a:V,b:T}=U,M=Q.mul(T,f8),{X:R,Y:D,Z:W}=this;let{ZERO:O,ZERO:H,ZERO:x}=Q,C=Q.mul(R,R),h=Q.mul(D,D),f=Q.mul(W,W),_=Q.mul(R,D);return _=Q.add(_,_),x=Q.mul(R,W),x=Q.add(x,x),O=Q.mul(V,x),H=Q.mul(M,f),H=Q.add(O,H),O=Q.sub(h,H),H=Q.add(h,H),H=Q.mul(O,H),O=Q.mul(_,O),x=Q.mul(M,x),f=Q.mul(V,f),_=Q.sub(C,f),_=Q.mul(V,_),_=Q.add(_,x),x=Q.add(C,C),C=Q.add(x,C),C=Q.add(C,f),C=Q.mul(C,_),H=Q.add(H,C),f=Q.mul(D,W),f=Q.add(f,f),C=Q.mul(f,_),O=Q.sub(O,C),x=Q.mul(f,h),x=Q.add(x,x),x=Q.add(x,x),new I(O,H,x)}add(V){r(V);const{X:T,Y:M,Z:R}=this,{X:D,Y:W,Z:O}=V;let{ZERO:H,ZERO:x,ZERO:C}=Q;const h=U.a,f=Q.mul(U.b,f8);let _=Q.mul(T,D),b=Q.mul(M,W),u=Q.mul(R,O),y=Q.add(T,M),l=Q.add(D,W);y=Q.mul(y,l),l=Q.add(_,b),y=Q.sub(y,l),l=Q.add(T,R);let d=Q.add(D,O);return l=Q.mul(l,d),d=Q.add(_,u),l=Q.sub(l,d),d=Q.add(M,R),H=Q.add(W,O),d=Q.mul(d,H),H=Q.add(b,u),d=Q.sub(d,H),C=Q.mul(h,l),H=Q.mul(f,u),C=Q.add(H,C),H=Q.sub(b,C),C=Q.add(b,C),x=Q.mul(H,C),b=Q.add(_,_),b=Q.add(b,_),u=Q.mul(h,u),l=Q.mul(f,l),b=Q.add(b,u),u=Q.sub(_,u),u=Q.mul(h,u),l=Q.add(l,u),_=Q.mul(b,l),x=Q.add(x,_),_=Q.mul(d,l),H=Q.mul(y,H),H=Q.sub(H,_),_=Q.mul(y,b),C=Q.mul(d,C),C=Q.add(C,_),new I(H,x,C)}subtract(V){return this.add(V.negate())}is0(){return this.equals(I.ZERO)}multiply(V){const{endo:T}=J;if(!G.isValidNot0(V))throw new Error("invalid scalar: out of range");let M,R;const D=(W)=>E.cached(this,W,(O)=>_8(I,O));if(T){const{k1neg:W,k1:O,k2neg:H,k2:x}=J0(V),{p:C,f:h}=D(O),{p:f,f:_}=D(x);R=h.add(_),M=U0(T.beta,C,f,W,H)}else{const{p:W,f:O}=D(V);M=W,R=O}return _8(I,[M,R])[0]}multiplyUnsafe(V){const{endo:T}=J,M=this;if(!G.isValid(V))throw new Error("invalid scalar: out of range");if(V===E0||M.is0())return I.ZERO;if(V===J8)return M;if(E.hasCache(this))return this.multiply(V);if(T){const{k1neg:R,k1:D,k2neg:W,k2:O}=J0(V),{p1:H,p2:x}=e$(I,M,D,O);return U0(T.beta,H,x,R,W)}else return E.unsafe(M,V)}multiplyAndAddUnsafe(V,T,M){const R=this.multiplyUnsafe(T).add(V.multiplyUnsafe(M));return R.is0()?void 0:R}toAffine(V){return q0(this,V)}isTorsionFree(){const{isTorsionFree:V}=J;if(Y===J8)return!0;if(V)return V(I,this);return E.unsafe(this,Z).is0()}clearCofactor(){const{clearCofactor:V}=J;if(Y===J8)return this;if(V)return V(I,this);return this.multiplyUnsafe(Y)}isSmallOrder(){return this.multiplyUnsafe(Y).is0()}toBytes(V=!0){return D8(V,"isCompressed"),this.assertValidity(),z(I,this,V)}toHex(V=!0){return k0(this.toBytes(V))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(V=!0){return this.toBytes(V)}_setWindowSize(V){this.precompute(V)}static normalizeZ(V){return _8(I,V)}static msm(V,T){return $Q(I,G,V,T)}static fromPrivateKey(V){return I.BASE.multiply(u0(G,V))}}I.BASE=new I(U.Gx,U.Gy,Q.ONE),I.ZERO=new I(Q.ZERO,Q.ONE,Q.ZERO),I.Fp=Q,I.Fn=G;const j0=G.BITS,E=new M$(I,J.endo?Math.ceil(j0/2):j0);return I.BASE.precompute(8),I}var UQ=function($){return Uint8Array.of($?2:3)};var YQ=function($,J){return{secretKey:J.BYTES,publicKey:1+$.BYTES,publicKeyUncompressed:1+2*$.BYTES,publicKeyHasPrefix:!0,signature:2*J.BYTES}};function K1($,J={}){const{Fn:q}=$,Q=J.randomBytes||l0,G=Object.assign(YQ($.Fp,q),{seed:z$(q.ORDER)});function U(z){try{return!!u0(q,z)}catch(L){return!1}}function Y(z,L){const{publicKey:k,publicKeyUncompressed:S}=G;try{const g=z.length;if(L===!0&&g!==k)return!1;if(L===!1&&g!==S)return!1;return!!$.fromBytes(z)}catch(g){return!1}}function Z(z=Q(G.seed)){return v8(b0(z,G.seed,"seed"),q.ORDER)}function X(z,L=!0){return $.BASE.multiply(u0(q,z)).toBytes(L)}function N(z){const L=Z(z);return{secretKey:L,publicKey:X(L)}}function K(z){if(typeof z==="bigint")return!1;if(z instanceof $)return!0;const{secretKey:L,publicKey:k,publicKeyUncompressed:S}=G;if(q.allowedLengths||L===k)return;const g=o("key",z).length;return g===k||g===S}function w(z,L,k=!0){if(K(z)===!0)throw new Error("first arg must be private key");if(K(L)===!1)throw new Error("second arg must be public key");const S=u0(q,z);return $.fromHex(L).multiply(S).toBytes(k)}return Object.freeze({getPublicKey:X,getSharedSecret:w,keygen:N,Point:$,utils:{isValidSecretKey:U,isValidPublicKey:Y,randomSecretKey:Z,isValidPrivateKey:U,randomPrivateKey:Z,normPrivateKeyToScalar:(z)=>u0(q,z),precompute(z=8,L=$.BASE){return L.precompute(z,!1)}},lengths:G})}function D1($,J,q={}){w8(J),V8(q,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const Q=q.randomBytes||l0,G=q.hmac||((M,...R)=>Q$(J,M,z0(...R))),{Fp:U,Fn:Y}=$,{ORDER:Z,BITS:X}=Y,{keygen:N,getPublicKey:K,getSharedSecret:w,utils:j,lengths:z}=K1($,q),L={prehash:!1,lowS:typeof q.lowS==="boolean"?q.lowS:!1,format:void 0,extraEntropy:!1},k="compact";function S(M){const R=Z>>J8;return M>R}function g(M,R){if(!Y.isValidNot0(R))throw new Error(`invalid signature ${M}: out of range 1..Point.Fn.ORDER`);return R}function s(M,R){N$(R);const D=z.signature,W=R==="compact"?D:R==="recovered"?D+1:void 0;return b0(M,W,`${R} signature`)}class F{constructor(M,R,D){if(this.r=g("r",M),this.s=g("s",R),D!=null)this.recovery=D;Object.freeze(this)}static fromBytes(M,R=k){s(M,R);let D;if(R==="der"){const{r:x,s:C}=I0.toSig(b0(M));return new F(x,C)}if(R==="recovered")D=M[0],R="compact",M=M.subarray(1);const W=Y.BYTES,O=M.subarray(0,W),H=M.subarray(W,W*2);return new F(Y.fromBytes(O),Y.fromBytes(H),D)}static fromHex(M,R){return this.fromBytes(c0(M),R)}addRecoveryBit(M){return new F(this.r,this.s,M)}recoverPublicKey(M){const R=U.ORDER,{r:D,s:W,recovery:O}=this;if(O==null||![0,1,2,3].includes(O))throw new Error("recovery id invalid");if(Z*GQ<R&&O>1)throw new Error("recovery id is ambiguous for h>1 curve");const x=O===2||O===3?D+Z:D;if(!U.isValid(x))throw new Error("recovery id 2 or 3 invalid");const C=U.toBytes(x),h=$.fromBytes(z0(UQ((O&1)===0),C)),f=Y.inv(x),_=J0(o("msgHash",M)),b=Y.create(-_*f),u=Y.create(W*f),y=$.BASE.multiplyUnsafe(b).add(h.multiplyUnsafe(u));if(y.is0())throw new Error("point at infinify");return y.assertValidity(),y}hasHighS(){return S(this.s)}toBytes(M=k){if(N$(M),M==="der")return c0(I0.hexFromSig(this));const R=Y.toBytes(this.r),D=Y.toBytes(this.s);if(M==="recovered"){if(this.recovery==null)throw new Error("recovery bit must be present");return z0(Uint8Array.of(this.recovery),R,D)}return z0(R,D)}toHex(M){return k0(this.toBytes(M))}assertValidity(){}static fromCompact(M){return F.fromBytes(o("sig",M),"compact")}static fromDER(M){return F.fromBytes(o("sig",M),"der")}normalizeS(){return this.hasHighS()?new F(this.r,Y.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return k0(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return k0(this.toBytes("compact"))}}const r=q.bits2int||function M(R){if(R.length>8192)throw new Error("input is too large");const D=P0(R),W=R.length*8-X;return W>0?D>>BigInt(W):D},J0=q.bits2int_modN||function M(R){return Y.create(r(R))},q0=y0(X);function V0(M){return y$("num < 2^"+X,M,E0,q0),Y.toBytes(M)}function U0(M,R){return b0(M,void 0,"message"),R?b0(J(M),void 0,"prehashed message"):M}function I(M,R,D){if(["recovered","canonical"].some((u)=>(u in D)))throw new Error("sign() legacy options not supported");const{lowS:W,prehash:O,extraEntropy:H}=V$(D,L);M=U0(M,O);const x=J0(M),C=u0(Y,R),h=[V0(C),V0(x)];if(H!=null&&H!==!1){const u=H===!0?Q(z.secretKey):H;h.push(o("extraEntropy",u))}const f=z0(...h),_=x;function b(u){const y=r(u);if(!Y.isValidNot0(y))return;const l=Y.inv(y),d=$.BASE.multiply(y).toAffine(),n=Y.create(d.x);if(n===E0)return;const Z0=Y.create(l*Y.create(_+n*C));if(Z0===E0)return;let t=(d.x===n?0:2)|Number(d.y&J8),e=Z0;if(W&&S(Z0))e=Y.neg(Z0),t^=1;return new F(n,e,t)}return{seed:f,k2sig:b}}function j0(M,R,D={}){M=o("message",M);const{seed:W,k2sig:O}=I(M,R,D);return g$(J.outputLen,Y.BYTES,G)(W,O)}function E(M){let R=void 0;const D=typeof M==="string"||m0(M),W=!D&&M!==null&&typeof M==="object"&&typeof M.r==="bigint"&&typeof M.s==="bigint";if(!D&&!W)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(W)R=new F(M.r,M.s);else if(D){try{R=F.fromBytes(o("sig",M),"der")}catch(O){if(!(O instanceof I0.Err))throw O}if(!R)try{R=F.fromBytes(o("sig",M),"compact")}catch(O){return!1}}if(!R)return!1;return R}function V(M,R,D,W={}){const{lowS:O,prehash:H,format:x}=V$(W,L);if(D=o("publicKey",D),R=U0(o("message",R),H),("strict"in W))throw new Error("options.strict was renamed to lowS");const C=x===void 0?E(M):F.fromBytes(o("sig",M),x);if(C===!1)return!1;try{const h=$.fromBytes(D);if(O&&C.hasHighS())return!1;const{r:f,s:_}=C,b=J0(R),u=Y.inv(_),y=Y.create(b*u),l=Y.create(f*u),d=$.BASE.multiplyUnsafe(y).add(h.multiplyUnsafe(l));if(d.is0())return!1;return Y.create(d.x)===f}catch(h){return!1}}function T(M,R,D={}){const{prehash:W}=V$(D,L);return R=U0(R,W),F.fromBytes(M,"recovered").recoverPublicKey(R).toBytes()}return Object.freeze({keygen:N,getPublicKey:K,getSharedSecret:w,utils:j,lengths:z,Point:$,sign:j0,verify:V,recoverPublicKey:T,Signature:F,hash:J})}var W1=function($){const J={a:$.a,b:$.b,p:$.Fp.ORDER,n:$.n,h:$.h,Gx:$.Gx,Gy:$.Gy},q=$.Fp;let Q=$.allowedPrivateKeyLengths?Array.from(new Set($.allowedPrivateKeyLengths.map((Y)=>Math.ceil(Y/2)))):void 0;const G=g0(J.n,{BITS:$.nBitLength,allowedLengths:Q,modFromBytes:$.wrapPrivateKey}),U={Fp:q,Fn:G,allowInfinityPoint:$.allowInfinityPoint,endo:$.endo,isTorsionFree:$.isTorsionFree,clearCofactor:$.clearCofactor,fromBytes:$.fromBytes,toBytes:$.toBytes};return{CURVE:J,curveOpts:U}},M1=function($){const{CURVE:J,curveOpts:q}=W1($),Q={hmac:$.hmac,randomBytes:$.randomBytes,lowS:$.lowS,bits2int:$.bits2int,bits2int_modN:$.bits2int_modN};return{CURVE:J,curveOpts:q,hash:$.hash,ecdsaOpts:Q}};var V1=function($,J){const q=J.Point;return Object.assign({},J,{ProjectivePoint:q,CURVE:Object.assign({},$,E8(q.Fn.ORDER,q.Fn.BITS))})};function jQ($){const{CURVE:J,curveOpts:q,hash:Q,ecdsaOpts:G}=M1($),U=z1(J,q),Y=D1(U,Q,G);return V1($,Y)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var JQ=($,J)=>($+($>=0?J:-J)/GQ)/J;class qQ extends Error{constructor($=""){super($)}}var I0={Err:qQ,_tlv:{encode:($,J)=>{const{Err:q}=I0;if($<0||$>256)throw new q("tlv.encode: wrong tag");if(J.length&1)throw new q("tlv.encode: unpadded data");const Q=J.length/2,G=W8(Q);if(G.length/2&128)throw new q("tlv.encode: long form length too big");const U=Q>127?W8(G.length/2|128):"";return W8($)+U+G+J},decode($,J){const{Err:q}=I0;let Q=0;if($<0||$>256)throw new q("tlv.encode: wrong tag");if(J.length<2||J[Q++]!==$)throw new q("tlv.decode: wrong tlv");const G=J[Q++],U=!!(G&128);let Y=0;if(!U)Y=G;else{const X=G&127;if(!X)throw new q("tlv.decode(long): indefinite length not supported");if(X>4)throw new q("tlv.decode(long): byte length is too big");const N=J.subarray(Q,Q+X);if(N.length!==X)throw new q("tlv.decode: length bytes not complete");if(N[0]===0)throw new q("tlv.decode(long): zero leftmost byte");for(let K of N)Y=Y<<8|K;if(Q+=X,Y<128)throw new q("tlv.decode(long): not minimal encoding")}const Z=J.subarray(Q,Q+Y);if(Z.length!==Y)throw new q("tlv.decode: wrong value length");return{v:Z,l:J.subarray(Q+Y)}}},_int:{encode($){const{Err:J}=I0;if($<E0)throw new J("integer: negative integers are not allowed");let q=W8($);if(Number.parseInt(q[0],16)&8)q="00"+q;if(q.length&1)throw new J("unexpected DER parsing assertion: unpadded hex");return q},decode($){const{Err:J}=I0;if($[0]&128)throw new J("invalid signature integer: negative");if($[0]===0&&!($[1]&128))throw new J("invalid signature integer: unnecessary leading zero");return P0($)}},toSig($){const{Err:J,_int:q,_tlv:Q}=I0,G=o("signature",$),{v:U,l:Y}=Q.decode(48,G);if(Y.length)throw new J("invalid signature: left bytes after parsing");const{v:Z,l:X}=Q.decode(2,U),{v:N,l:K}=Q.decode(2,X);if(K.length)throw new J("invalid signature: left bytes after parsing");return{r:q.decode(Z),s:q.decode(N)}},hexFromSig($){const{_tlv:J,_int:q}=I0,Q=J.encode(2,q.encode($.r)),G=J.encode(2,q.encode($.s)),U=Q+G;return J.encode(48,U)}},E0=BigInt(0),J8=BigInt(1),GQ=BigInt(2),f8=BigInt(3),X1=BigInt(4);function ZQ($,J){const q=(Q)=>jQ({...$,hash:Q});return{...q(J),create:q}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var O1=function($){const J=q8.p,q=BigInt(3),Q=BigInt(6),G=BigInt(11),U=BigInt(22),Y=BigInt(23),Z=BigInt(44),X=BigInt(88),N=$*$*$%J,K=N*N*$%J,w=W0(K,q,J)*K%J,j=W0(w,q,J)*K%J,z=W0(j,B$,J)*N%J,L=W0(z,G,J)*z%J,k=W0(L,U,J)*L%J,S=W0(k,Z,J)*k%J,g=W0(S,X,J)*S%J,s=W0(g,Z,J)*k%J,F=W0(s,q,J)*K%J,r=W0(F,Y,J)*L%J,J0=W0(r,Q,J)*N%J,q0=W0(J0,B$,J);if(!b8.eql(b8.sqr(q0),$))throw new Error("Cannot find square root");return q0},y8=function($,...J){let q=zQ[$];if(q===void 0){const Q=S8(k8($));q=z0(Q,Q),zQ[$]=q}return S8(z0(q,...J))},O$=function($){const{Fn:J,BASE:q}=G8,Q=u0(J,$),G=q.multiply(Q);return{scalar:R$(G.y)?Q:J.neg(Q),bytes:x$(G)}},WQ=function($){const J=b8;if(!J.isValidNot0($))throw new Error("invalid x: Fail if x \u2265 p");const q=J.create($*$),Q=J.create(q*$+BigInt(7));let G=J.sqrt(Q);if(!R$(G))G=J.neg(G);const U=G8.fromAffine({x:$,y:G});return U.assertValidity(),U},MQ=function(...$){return G8.Fn.create(B8(y8("BIP0340/challenge",...$)))},KQ=function($){return O$($).bytes},x1=function($,J,q=l0(32)){const{Fn:Q}=G8,G=o("message",$),{bytes:U,scalar:Y}=O$(J),Z=o("auxRand",q,32),X=Q.toBytes(Y^B8(y8("BIP0340/aux",Z))),N=y8("BIP0340/nonce",X,U,G),{bytes:K,scalar:w}=O$(N),j=MQ(K,U,G),z=new Uint8Array(64);if(z.set(K,0),z.set(Q.toBytes(Q.create(w+j*Y)),32),!VQ(z,G,U))throw new Error("sign: Invalid signature produced");return z},VQ=function($,J,q){const{Fn:Q,BASE:G}=G8,U=o("signature",$,64),Y=o("message",J),Z=o("publicKey",q,32);try{const X=WQ(B8(Z)),N=B8(U.subarray(0,32));if(!M8(N,XQ,q8.p))return!1;const K=B8(U.subarray(32,64));if(!M8(K,XQ,q8.n))return!1;const w=MQ(Q.toBytes(N),x$(X),Y),j=G.multiplyUnsafe(K).add(X.multiplyUnsafe(Q.neg(w))),{x:z,y:L}=j.toAffine();if(j.is0()||!R$(L)||z!==N)return!1;return!0}catch(X){return!1}};/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var q8={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},N1={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},B1=BigInt(0),XQ=BigInt(1),B$=BigInt(2),b8=g0(q8.p,{sqrt:O1}),DQ=ZQ({...q8,Fp:b8,lowS:!0,endo:N1},S8),zQ={},x$=($)=>$.toBytes(!0).slice(1),G8=(()=>DQ.Point)(),R$=($)=>$%B$===B1,B8=P0,g8=(()=>{const q=(G=l0(48))=>{return v8(G,q8.n)};DQ.utils.randomSecretKey;function Q(G){const U=q(G);return{secretKey:U,publicKey:KQ(U)}}return{keygen:Q,getPublicKey:KQ,sign:x1,verify:VQ,Point:G8,utils:{randomSecretKey:q,randomPrivateKey:q,taggedHash:y8,lift_x:WQ,pointToBytes:x$,numberToBytesBE:$8,bytesToNumberBE:P0,mod:D0},lengths:{secretKey:32,publicKey:32,publicKeyHasPrefix:!1,signature:64,seed:48}}})();var R1=new TextEncoder,H1=new TextDecoder,T0=($)=>R1.encode($),p0=($)=>H1.decode($),u8=($)=>Array.from($,(J)=>J.toString(16).padStart(2,"0")).join(""),N0=JSON.stringify,i0=JSON.parse,F8=($,J=Number.MAX_SAFE_INTEGER)=>$.split("").reduce((q,Q)=>q+Q.charCodeAt(0),0)%J;var H$="AES-GCM",L1={},NQ="$",BQ=",",T1=($)=>{const J=new Uint8Array($);let Q="";for(let G=0;G<J.length;G+=32768)Q+=String.fromCharCode(...J.subarray(G,G+32768));return btoa(Q)},A1=($)=>Uint8Array.from(atob($),(J)=>J.charCodeAt(0)).buffer,O8=($)=>L1[$]??=crypto.subtle.digest("SHA-1",T0($)).then((J)=>{const q=new Uint8Array(J);let Q="";for(let G of q)Q+=G.toString(36);return Q}),OQ=async($,J,q)=>{const Q=await crypto.subtle.digest("SHA-256",T0(`${$}:${J}:${q}`));return crypto.subtle.importKey("raw",Q,{name:H$},!1,["encrypt","decrypt"])},xQ=async($,J)=>{const q=crypto.getRandomValues(new Uint8Array(12)),Q=await $,G=await crypto.subtle.encrypt({name:H$,iv:q},Q,T0(J));return`${q.join(BQ)}${NQ}${T1(G)}`},RQ=async($,J)=>{const[q,Q]=J.split(NQ);if(!q||!Q)throw new Error("Invalid encrypted payload format");const G=Uint8Array.from(q.split(BQ),Number),U=await $,Y=await crypto.subtle.decrypt({name:H$,iv:G},U,A1(Q));return p0(Y)};var M0="GenosRTC",U8=($,J)=>Array.from({length:$},J);var x8=($)=>Array.from(crypto.getRandomValues(new Uint8Array($)),(J)=>"0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz"[J%"0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz".length]).join(""),m=x8(20),v0=Promise.all.bind(Promise),HQ=typeof window!=="undefined",{entries:LQ,fromEntries:m8,keys:yJ}=Object,TQ=()=>{},x0=($)=>new Error(`GenosRTC: ${$}`),R8=(...$)=>$.join("@"),AQ=($,J)=>{const q=[...$];let Q=q.length;const G=()=>{const U=Math.sin(J++)*1e4;return U-Math.floor(U)};while(Q){const U=Math.floor(G()*Q--);[q[Q],q[U]]=[q[U],q[Q]]}return q};var w1=5000,wQ="icegatheringstatechange",CQ="offer",C1="answer",k1=[...U8(3,($,J)=>`stun:stun${J||""}.l.google.com:19302`),"stun:stun.cloudflare.com:3478"].map(($)=>({urls:$})),h8=($,{rtcConfig:J,rtcPolyfill:q,turnConfig:Q})=>{const G=new(q||RTCPeerConnection)({iceServers:[...k1,...Q||[]],...J}),U={};let Y=!1,Z=!1,X;const N=(j)=>Object.assign(j,{binaryType:"arraybuffer",bufferedAmountLowThreshold:65535,onmessage:(z)=>U.data?.(z.data),onopen:()=>U.connect?.(),onclose:()=>U.close?.(),onerror:(z)=>!z?.error?.message?.includes("User-Initiated Abort")&&U.error?.(z)}),K=()=>Promise.race([new Promise((j)=>{const z=()=>{if(G.iceGatheringState==="complete")G.removeEventListener(wQ,z),j()};G.addEventListener(wQ,z),z()}),new Promise((j)=>setTimeout(j,w1))]).then(()=>({type:G.localDescription.type,sdp:G.localDescription.sdp.replace(/a=ice-options:trickle\s\n/g,"")}));if($?N(X=G.createDataChannel("data")):G.ondatachannel=({channel:j})=>N(X=j),G.onnegotiationneeded=async()=>{try{Y=!0,await G.setLocalDescription(),U.signal?.(await K())}catch(j){U.error?.(j)}finally{Y=!1}},G.onconnectionstatechange=()=>{if(["disconnected","failed","closed"].includes(G.connectionState))U.close?.()},G.ontrack=(j)=>{U.track?.(j.track,j.streams[0]),U.stream?.(j.streams[0])},G.onremovestream=(j)=>U.stream?.(j.stream),$&&!G.canTrickleIceCandidates)G.onnegotiationneeded();const w=()=>G.getSenders();return{created:Date.now(),connection:G,get channel(){return X},get isDead(){return G.connectionState==="closed"},async signal(j){if(X?.readyState==="open"&&!j.sdp?.includes("a=rtpmap"))return;try{if(j.type===CQ){if(Y||G.signalingState!=="stable"&&!Z){if($)return;await v0([G.setLocalDescription({type:"rollback"}),G.setRemoteDescription(j)])}else await G.setRemoteDescription(j);await G.setLocalDescription();const z=await K();return U.signal?.(z),z}if(j.type===C1){Z=!0;try{await G.setRemoteDescription(j)}finally{Z=!1}}}catch(z){U.error?.(z)}},sendData:(j)=>X.send(j),destroy:()=>{X?.close(),G.close(),Y=Z=!1},setHandlers:(j)=>Object.assign(U,j),offerPromise:$?new Promise((j)=>U.signal=(z)=>z.type===CQ&&j(z)):Promise.resolve(),addStream:(j)=>j.getTracks().forEach((z)=>G.addTrack(z,j)),removeStream:(j)=>w().filter((z)=>j.getTracks().includes(z.track)).forEach((z)=>G.removeTrack(z)),addTrack:(j,z)=>G.addTrack(j,z),removeTrack:(j)=>{const z=w().find((L)=>L.track===j);if(z)G.removeTrack(z)},replaceTrack:(j,z)=>w().find((L)=>L.track===j)?.replaceTrack(z)}};var S1=Object.getPrototypeOf(Uint8Array),l8=12,kQ=0,d8=kQ+l8,o8=d8+1,L8=o8+1,T8=L8+1,H8=16384-T8,c8=255,L$="bufferedamountlow",Y8=($)=>`@_${$}`,T$=100,P1=3,I1=200,SQ=($,J,q)=>{const Q=new Map,G=new Map,U=new Map,Y={},Z={},X={},N={},K=new Map,w=(D,W)=>{if(!K.has(D))K.set(D,new Set);K.get(D).add(W)},j=(D,W)=>K.get(D)?.delete(W),z=(D,...W)=>K.get(D)?.forEach((O)=>O(...W)),L=(D,W)=>{const O=D?Array.isArray(D)?D:[D]:Q.keys();return Array.from(O,(H)=>{const x=Q.get(H);if(!x)return console.warn(`${M0}: no peer with id ${H}`),null;return W(H,x)}).filter(Boolean)},k=(D)=>{if(!Q.has(D))return;Q.delete(D),delete Y[D],delete Z[D],delete X[D],delete N[D],z("peer:leave",D),J(D)},S=(D)=>new Promise((W,O)=>{let H=setTimeout(()=>{D.removeEventListener(L$,x),O(new Error(`${M0}: bufferLow timeout`))},5000);function x(){clearTimeout(H),D.removeEventListener(L$,x),W()}D.addEventListener(L$,x)}),g=(D)=>{if(U.has(D))return U.get(D);if(!D)throw x0("action type is required");const W=T0(D);if(W.byteLength>l8)throw x0(`\u274C "${D}" exceeds ${l8} bytes. Use a shorter name.`);const O=new Uint8Array(l8).map((b,u)=>W[u]||0);let H=0;const x=new Map([["message",new Set],["progress",new Set]]),C=(b,u)=>x.get(b)?.add(u),h=(b,u)=>x.get(b)?.delete(u),f=async(b,u,y,l)=>{if(y&&typeof y!=="object")throw x0("meta must be object");if(b===void 0)throw x0("data cannot be undefined");const d=b instanceof Blob,n=d||b instanceof ArrayBuffer||b instanceof S1,Z0=typeof b!=="string";if(y&&!n)throw x0("meta only allowed with binary");const t=n?new Uint8Array(d?await b.arrayBuffer():b):T0(Z0?N0(b):b),e=y?T0(N0(y)):null,i=Math.ceil(t.byteLength/H8)+(y?1:0)||1;if(i>T$)throw x0(`Message too large, exceeds max chunks ${T$}`);const r0=U8(i,(a0,X0)=>{const A0=X0===i-1,R0=y&&X0===0,n0=R0?e:t.subarray(y?(X0-1)*H8:X0*H8,y?X0*H8:(X0+1)*H8),H0=new Uint8Array(T8+n0.byteLength);return H0.set(O),H0.set([H],d8),H0.set([A0|R0<<1|n<<2|Z0<<3],o8),H0.set([Math.round((X0+1)/i*c8)],L8),H0.set(n0,T8),H0});return H=H+1&c8,v0(L(u,async(a0,X0)=>{const{channel:A0}=X0;for(let R0=0;R0<i;R0++){let n0=0;while(A0.bufferedAmount>A0.bufferedAmountLowThreshold){if(n0++>P1)throw x0(`${M0}: send buffer full, max retries reached for peer ${a0}`);try{await S(A0)}catch(H0){console.warn(H0.message),await new Promise((s8)=>setTimeout(s8,I1))}}if(!Q.has(a0))break;X0.sendData(r0[R0]),l?.(r0[R0][L8]/c8,a0,y)}}))};G.set(D,{listeners:x,send:f});const _={send:f,on:C,off:h};return U.set(D,_),_},s=(D,W)=>{try{const O=new Uint8Array(W),H=p0(O.subarray(kQ,d8)).replace(/ /g,"");if(!G.has(H))return console.warn(`${M0}: unregistered type (${H})`);const[x]=O.subarray(d8,o8),[C]=O.subarray(o8,L8),[h]=O.subarray(L8,T8),f=O.subarray(T8),_=Boolean(C&1),b=Boolean(C&2),u=Boolean(C&4),y=Boolean(C&8),l=G.get(H),d=(Y[D]||={})[H]||={};if(d[x]?.chunks?.length>T$){console.warn(`${M0}: peer ${D} sent too many chunks for nonce ${x}, ignoring.`);return}const n=d[x]||={chunks:[]};if(b)try{n.meta=i0(p0(f))}catch{console.warn(`${M0}: failed to parse meta from peer ${D} for type ${H}`);return}else n.chunks.push(f);if(l.listeners.get("progress").forEach((e)=>{try{e(h/c8,D,n.meta)}catch(i){console.error(i)}}),!_)return;const Z0=new Uint8Array(n.chunks.reduce((e,i)=>e+i.byteLength,0));n.chunks.reduce((e,i)=>(Z0.set(i,e),e+i.byteLength),0),delete d[x];let t;if(u)t=Z0;else if(y)try{t=i0(p0(Z0))}catch{console.warn(`${M0}: failed to parse JSON message data from peer ${D} for type ${H}`);return}else t=p0(Z0);l.listeners.get("message").forEach((e)=>{try{e(t,D,n.meta)}catch(i){console.error(i)}})}catch(O){console.error(`${M0}: error handling data from peer ${D}:`,O)}},F=async()=>{try{await M(""),await new Promise((D)=>setTimeout(D,99))}catch(D){console.warn(`${M0}: error sending leave`,D)}for(let[D,W]of Q){try{W.destroy()}catch{}Q.delete(D)}q()},{send:r,on:J0}=g(Y8("ping")),{send:q0,on:V0}=g(Y8("pong")),{send:U0,on:I}=g(Y8("signal")),{send:j0,on:E}=g(Y8("stream")),{send:V,on:T}=g(Y8("track")),{send:M,on:R}=g(Y8("leave"));if($((D,W)=>{if(Q.has(W))return;Q.set(W,D),D.setHandlers({data:(O)=>s(W,O),stream:(O)=>{z("stream:add",O,W,X[W]),delete X[W]},track:(O,H)=>{z("track:add",O,H,W,N[W]),delete N[W]},signal:(O)=>U0(O,W),close:()=>k(W),error:(O)=>{console.error(`${M0}: peer error for ${W}`,O),k(W)}}),z("peer:join",W)}),J0("message",(D,W)=>q0("",W)),V0("message",(D,W)=>{Z[W]?.(),delete Z[W]}),I("message",(D,W)=>Q.get(W)?.signal(D)),E("message",(D,W)=>X[W]=D),T("message",(D,W)=>N[W]=D),R("message",(D,W)=>k(W)),HQ)addEventListener("beforeunload",F);return{on:w,off:j,channel:g,leave:F,ping:async(D)=>{if(!D)throw x0("ping() requires target peer ID");const W=Date.now();return r("",D),await new Promise((O)=>Z[D]=O),Date.now()-W},getPeers:()=>m8(Array.from(Q,([D,W])=>[D,W.connection])),addStream:(D,W,O)=>L(W,async(H,x)=>{if(O)await j0(O,H);x.addStream(D)}),removeStream:(D,W)=>L(W,(O,H)=>H.removeStream(D)),addTrack:(D,W,O,H)=>L(O,async(x,C)=>{if(H)await V(H,x);C.addTrack(D,W)}),removeTrack:(D,W)=>L(W,(O,H)=>H.removeTrack(D)),replaceTrack:(D,W,O,H)=>L(O,async(x,C)=>{if(H)await V(H,x);C.replaceTrack(D,W)})}};var E1=20,v1=5333,PQ=57333,IQ=({init:$,subscribe:J,announce:q})=>{const Q={};let G=!1,U,Y;return(Z,X,N)=>{const{appId:K}=Z;if(Q[K]?.[X])return Q[K][X];if(!Z||!X||!K&&!Z.firebaseApp)throw x0(!Z?"config required":!X?"roomId required":"appId missing");let w=TQ;if(!G){const E=$(Z);Y=U8(E1,()=>h8(!0,Z)),U=Array.isArray(E)?E:[E];const V=setInterval(()=>{Y=Y.filter((T)=>{const M=Date.now()-T.created<PQ;if(!M)T.destroy();return M})},PQ);Q.offerCleanupTimer||=V,G=!0}const j={},z={},L=R8(M0,K,X),k=O8(L),S=O8(R8(L,m)),g=OQ(Z.password||"",K,X),s=(E)=>async(V)=>({type:V.type,sdp:await E(g,V.sdp)}),F=s(RQ),r=s(xQ),J0=(E,V)=>{if(z[V]===E)return;z[V]?.destroy(),z[V]=E,w(E,V),j[V]?.forEach((T)=>T!==E&&T.destroy()),delete j[V]},q0=(E,V)=>{if(z[V]===E)delete z[V]},V0=(E)=>async(V,T,M)=>{const[R,D]=await v0([k,S]);if(V!==R&&V!==D)return;const{peerId:W,offer:O,answer:H}=typeof T==="string"?i0(T):T;if(W===m||z[W])return;if(O){if(j[W]?.[E]&&m>W)return;const x=h8(!1,Z);x.setHandlers({connect:()=>J0(x,W),close:()=>q0(x,W)});try{const C=await F(O);if(x.isDead)return;const[h,f]=await v0([O8(R8(L,W)),x.signal(C).then(r)]);M(h,N0({peerId:m,answer:f}))}catch{N?.({error:"decryption failed (offer)",appId:K,peerId:W,roomId:X})}}else if(H){const x=j[W]?.[E];if(!x||x.isDead)return;x.setHandlers({connect:()=>J0(x,W),close:()=>q0(x,W)});try{x.signal(await F(H))}catch{N?.({error:"decryption failed (answer)",appId:K,peerId:W,roomId:X})}}else{if(j[W]?.[E])return;const x=Y.pop()||h8(!0,Z),[C,{offer:h}]=await v0([O8(R8(L,W)),x.offerPromise.then(r).then((f)=>({offer:f}))]);j[W]||=[],j[W][E]=x,x.setHandlers({connect:()=>J0(x,W),close:()=>q0(x,W)}),M(C,N0({peerId:m,offer:h,peer:x}))}},U0=v0(U.map(async(E,V)=>J(await E,await k,await S,V0(V)))),I=[];U0.then((E)=>{U.forEach((V,T)=>{const M=async()=>{const R=await q(await V,await k,await S);I[T]=setTimeout(M,typeof R==="number"?R:v1)};M()}),Q[K][X].onCleanup=()=>{if(delete Q[K][X],I.forEach(clearTimeout),E.forEach((V)=>V()),Object.keys(Q).length===0)clearInterval(Q.offerCleanupTimer),delete Q.offerCleanupTimer}}),Q[K]||={};const j0=SQ((E)=>w=E,(E)=>delete z[E],()=>j0.onCleanup?.());return Q[K][X]=j0}};var EQ=3333,p8={},vQ={},_Q=($,J)=>{const q={};let Q=null;const G=()=>{if(Q)clearTimeout(Q),Q=null;const U=new WebSocket($);U.onclose=()=>{p8[$]??=EQ,Q=setTimeout(G,p8[$]),p8[$]*=2},U.onmessage=(Y)=>J(Y.data),q.socket=U,q.url=U.url,q.ready=new Promise((Y)=>{U.onopen=()=>{p8[$]=EQ,Y(q)}}),q.send=(Y)=>{if(U.readyState===1)U.send(Y)}};return q.forceReconnect=G,G(),vQ[$]=q,q};if(typeof window!=="undefined"){const $=()=>{console.info("\u26A1 [GenosRTC] Network event detected. Forcing reconnection\u2026"),Object.values(vQ).forEach((J)=>{if(J.socket&&J.socket.readyState!==WebSocket.OPEN&&J.socket.readyState!==WebSocket.CONNECTING)J.forceReconnect()})};window.addEventListener("online",()=>{console.info("\u2705 Reconnected to the network."),$()}),window.addEventListener("offline",async()=>{console.info("\u274C Disconnected from the network.")}),document.addEventListener("visibilitychange",()=>{if(document.visibilityState==="visible")$()})}var fQ=($)=>()=>m8(LQ($).map(([J,q])=>[J,q.socket])),bQ=($,J,q,Q)=>($.relayUrls??(Q?AQ(J,F8($.appId)):J)).slice(0,$.relayUrls?.length??$.relayRedundancy??q);var j8={},_1=5,FQ="x",mQ="EVENT",f1=/pow:\s*(\d+)\s*bits needed\.?/i,A$=new Set,hQ=g8.utils.randomSecretKey(),b1=u8(g8.getPublicKey(hQ)),w$={},A8={},y1={},cQ=()=>Math.floor(Date.now()/1000),lQ=($)=>y1[$]??=F8($,1e4)+20000,i8=($)=>$.replace(/\/$/,""),g1=["wss://black.nostrcity.club","wss://eu.purplerelay.com","wss://ftp.halifax.rwth-aachen.de/nostr","wss://nostr.data.haus","wss://nostr.mom","wss://nostr.oxtr.dev","wss://nostr.sathoarder.com","wss://nostr.vulpem.com","wss://relay.agorist.space","wss://relay.binaryrobot.com","wss://relay.fountain.fm","wss://relay.mostro.network","wss://relay.nostrdice.com","wss://sendit.nosflare.com","wss://yabu.me/v2","wss://relay.damus.io"],u1=($,J)=>{const[q,Q,G,U]=i0(J);if(q===mQ)return A8[Q]?.(w$[Q],G.content);if(q==="NOTICE"||q==="OK"&&!G){if(+((q==="NOTICE"?Q:U).match(f1)?.[1]??0)>0){const Z=i8($);A$.add(Z),j8[Z]?.close?.(),delete j8[Z]}}},F1=($)=>{const J=i8($);if(j8[J])return j8[J];const q=_Q(J,(Q)=>u1(J,Q));return j8[J]=q},yQ=async($,J)=>{const q={kind:lQ($),content:J,pubkey:b1,created_at:cQ(),tags:[[FQ,$]]},Q=T0(N0([0,q.pubkey,q.created_at,q.kind,q.tags,q.content])),G=new Uint8Array(await crypto.subtle.digest("SHA-256",Q)),U=g8.sign(G,hQ);return N0([mQ,{...q,id:u8(G),sig:u8(U)}])},gQ=($,J)=>{return w$[$]=J,N0(["REQ",$,{kinds:[lQ(J)],since:cQ(),["#"+FQ]:[J]}])},uQ=($)=>{return delete w$[$],N0(["CLOSE",$])},dQ=IQ({init:($)=>{const q=($?.relayUrls?.length?$.relayUrls:null)??g1;return bQ($,q,_1,!0).map(F1).map((G)=>G.ready.then(()=>G).catch(()=>null))},subscribe:($,J,q,Q)=>{const G=x8(64),U=x8(64);return A8[G]=A8[U]=(Y,Z)=>Q(Y,Z,async(X,N)=>{if(A$.has(i8($.url)))return;$.send(await yQ(X,N))}),$.send(gQ(G,J)),$.send(gQ(U,q)),()=>{$.send(uQ(G)),$.send(uQ(U)),delete A8[G],delete A8[U]}},announce:async($,J)=>{if(A$.has(i8($.url)))return;$.send(await yQ(J,N0({peerId:m})))}}),m1=fQ(j8);var i1=function($,J={}){const q={...h1,...J},Q=!!q.debug,G=(...B)=>Q&&console.debug("[cells]",...B),U=Math.max(0,q.bridgesPerEdge|0),Y=Math.max(5,q.maxCellSize|0),Z=Math.max(10,q.targetCells|0),X=q.cellSize==="auto";let N=X?2:Math.max(1,q.cellSize|0),K={cellId:null,bridges:[],isBridge:!1},w=0,j=null,z=null,L=null;const k=new Map,S=new Map,g=new Set,s=new Map,F=new Set,r=new Set;let J0=0;const q0=[],V0=new Map,U0=new Set,I=new Map,j0=new Map,E=()=>{const B=Math.ceil(y().length/N);return Math.min(150,B+3)},V=$.on?.bind($),T=$.off?.bind($);if(V)$.on=(B,A)=>String(B).startsWith("mesh:")?D(B,A):V(B,A);if(T)$.off=(B,A)=>String(B).startsWith("mesh:")?s.get(B)?.delete(A):T(B,A);const M=(B)=>(g.add(B),()=>g.delete(B)),R=(B,A,P)=>{if(r.has(P))return;if(r.add(P),r.size>oQ){const v=r.values().next().value;r.delete(v)}for(let v of g)try{v(B,A)}catch(c){G("Error in deliver handler:",c)}},D=(B,A)=>{if(!s.has(B))s.set(B,new Set);return s.get(B).add(A),()=>s.get(B)?.delete(A)},W=(B,...A)=>{const P=s.get(B);if(P)for(let v of P)try{v(...A)}catch{}},O=(B)=>{try{return typeof B==="string"?JSON.parse(B):B}catch{return null}},H=()=>`${m}:${Date.now().toString(36)}:${(J0++&65535).toString(36)}`,x=()=>{if(F.size>oQ)F.delete(F.values().next().value)},C=(B,A,P=[])=>{if(!B||!A)return;if(k.set(B,{cell:A,isBridge:P.length>0,bridges:[...P]}),!S.has(B))S.set(B,new a8(B));const v=S.get(B);if(v.markSeen(),v.addConnectedCell(A),j0.set(A,{lastSeen:Date.now(),peerId:B}),P.length>0)for(let c of Z8(A))v.addConnectedCell(c)},h=(B)=>S.get(B),f=(B,A)=>{const P=S.get(B);if(P)P.addRttSample(A)},_=(B)=>{const A=t(B);if(A.length===0)return null;let P=0,v=0;for(let $0 of A){const Q0=S.get($0);if(Q0&&!Q0.isStale){if(P+=Q0.healthScore,Q0.isResponsive)v++}}const c=A.filter(($0)=>{const Q0=S.get($0);return Q0&&!Q0.isStale});return{cellId:B,memberCount:c.length,avgHealth:c.length>0?P/c.length:0,responsiveRatio:c.length>0?v/c.length:0}},b=()=>{const B=_(K.cellId);W("mesh:health",{...K,health:B})},u=()=>{const B=Object.keys($.getPeers?.()||{}),A=[...B,m].sort();return{peers:B,all:A}},y=()=>{const{all:B}=u();return B.filter((A)=>{if(A===m)return!0;const P=S.get(A);return P&&!P.isStale})},l=()=>{if(!X)return;const B=y().length,A=p1(B,Z,Y);if(A!==N)G("cellSize changed:",N,"->",A),N=A},d=(B,A)=>{if(U===0)return[];const P=n8(B),v=n8(A);if(P==null||v==null)return[];const c=y(),$0=Math.min(P,v)*N,Q0=(Math.max(P,v)+1)*N,a=c.slice($0,Q0);if(!a.length)return[];const s0=new Set(t(B)),t8=new Set(t(A)),L0=a.filter((K0)=>{if(K0===m)return!0;const w0=S.get(K0);if(!w0||w0.isStale)return!1;const p=s0.has(K0)||w0.connectedCells.has(B),_0=t8.has(K0)||w0.connectedCells.has(A);return p||_0});if(!L0.length)L0.push(...a);const t0=L0.map((K0)=>({id:K0,score:S.get(K0)?.healthScore||0.5}));return t0.sort((K0,w0)=>{const p=w0.score-K0.score;return p!==0?p:K0.id.localeCompare(w0.id)}),t0.slice(0,U).map((K0)=>K0.id)},n=(B,A)=>{if(U===0)return[];const P=Z8(A),v=[];for(let c of P)if(d(A,c).includes(B))v.push(c);return v},Z0=()=>{l();const B=y(),A=B.indexOf(m),v=`cell-${Math.max(0,Math.floor(A/N))}`,c=n(m,v),$0=c.length>0,Q0=Math.ceil(B.length/N)||1;return G("computeState",{self:m,myCell:v,isBridge:$0,bridgeEdges:c,cellSize:N,rosterSize:B.length,totalCells:Q0,dynamicTTL:E()}),{cellId:v,isBridge:$0,bridges:c,cellSize:N,dynamicTTL:E(),totalCells:Q0}},t=(B)=>{const A=[],P=new Set(Object.keys($.getPeers?.()||{}));for(let[v,c]of k)if(c.cell===B){const $0=S.get(v);if(P.has(v)&&(!$0||!$0.isStale))A.push(v)}return A.sort(),A},e=()=>{if(!j)return;A0=R0();const B={t:"state",id:H(),ttl:E(),data:{id:m,cell:K.cellId,bridges:K.bridges,health:S.get(m)?.healthScore||0.5,timestamp:Date.now()},origin:m,originCell:K.cellId},A=JSON.stringify(B);j.send(A),i(z,A)},i=(B,A)=>{const P=O(A);if(!P?.id||!P?.t)return;const v=F.has(P.id);if(!v)F.add(P.id),x();const{t:c,id:$0,ttl:Q0,data:a,origin:s0,originCell:t8}=P,L0=K.cellId;if(c==="state"&&a)C(a.id,a.cell,a.bridges),W("mesh:peer-state",a);if(c==="ping"&&a?.pingId&&s0!==m){const p={t:"pong",id:H(),ttl:E(),data:{pingId:a.pingId,receivedAt:Date.now()},origin:m,originCell:L0};j?.send(JSON.stringify(p))}if(c==="pong"&&a?.pingId){const p=I.get(a.pingId);if(p){clearTimeout(p.timeout);const _0=Date.now()-p.start;f(p.peerId,_0),p.resolve(_0),I.delete(a.pingId)}}if(c==="msg"&&s0!==m)R(a,s0,$0);if(v)return;if(!K.isBridge)return;if((Q0??0)<=0)return;const t0=(p,_0,pQ=null)=>{if(!p)return;const iQ={t:c,id:$0,ttl:pQ??(Q0??E())-1,data:a,origin:s0||m,originCell:t8||L0},C$=JSON.stringify(iQ);if(_0?.length){const rQ=new Set(Object.keys($.getPeers?.()||{})),k$=_0.filter((aQ)=>rQ.has(aQ));if(k$.length>0)p.send(C$,k$)}else p.send(C$)};if(B===z){for(let p of Z8(L0))t0(r0(p),null);return}if(!Z8(L0).map(r8).includes(B))return;const w0=t(L0);t0(j,w0);for(let p of Z8(L0))if(r8(p)!==B)t0(r0(p),null)},r0=(B)=>{const A=r8(B);if(V0.has(B))return V0.get(B);const P=$.channel(A);if(V0.set(B,P),!U0.has(A))U0.add(A),P.on("message",(v)=>i(A,v));return P},a0=()=>{if(!K.cellId)return;if(z=r8(K.cellId),j=$.channel(z),!U0.has(z))U0.add(z),j.on("message",(B)=>i(z,B));if(w=Date.now()+c1,K.isBridge)for(let B of Z8(K.cellId))r0(B);if(q0.length){const B=t(K.cellId);for(let A of q0.splice(0)){const P={t:"msg",id:H(),ttl:E(),data:A,origin:m,originCell:K.cellId},v=JSON.stringify(P);B.length?j.send(v,B):j.send(v),i(z,v)}}e()},X0=()=>{const B=Z0(),A=!K.cellId||K.cellId!==B.cellId||K.isBridge!==B.isBridge||JSON.stringify(K.bridges)!==JSON.stringify(B.bridges);if(K=B,C(m,B.cellId,B.bridges),A)a0();else e();W("mesh:state",B),b()};let A0="";const R0=()=>{return`${K.cellId}:${K.isBridge}:${K.bridges.join(",")}`},n0=()=>{if(L)return;L=setInterval(()=>{const B=R0();if(B!==A0)e(),A0=B;for(let[A,P]of S)if(A!==m&&P.isStale)k.delete(A),S.delete(A),G("Removed stale peer:",A)},o1)},H0=()=>{if(L)clearInterval(L),L=null},s8=(B)=>{return new Promise((A,P)=>{const v=`${Date.now()}-${Math.random().toString(36).slice(2,8)}`,c=Date.now(),$0=setTimeout(()=>{I.delete(v);const a=S.get(B);if(a)a.markUnresponsive();P(new Error("Ping timeout"))},l1);I.set(v,{start:c,resolve:A,reject:P,timeout:$0,peerId:B});const Q0={t:"ping",id:H(),ttl:E(),data:{pingId:v,target:B},origin:m,originCell:K.cellId};j?.send(JSON.stringify(Q0))})};if($.on?.("peer:join",(B)=>{if(!S.has(B))S.set(B,new a8(B));else S.get(B).markReconnect();X0()}),$.on?.("peer:leave",(B)=>{k.delete(B),X0()}),!S.has(m))S.set(m,new a8(m));return S.get(m).addConnectedCell(K.cellId||"cell-0"),X0(),n0(),{send:(B)=>{if(!K.cellId||!j)return q0.push(B);const A=t(K.cellId),P={t:"msg",id:H(),ttl:E(),data:B,origin:m,originCell:K.cellId},v=JSON.stringify(P);A.length?j.send(v,A):j.send(v),i(z,v)},on:(B,A)=>B==="message"?M(A):void 0,ping:s8,getState:()=>({...K,cellSize:N,health:_(K.cellId),dynamicTTL:E(),totalCells:Math.ceil(y().length/N),knownCells:j0.size}),getMetrics:h,getCellHealth:_,getPeerInfo:()=>new Map(k),getStableRoster:()=>y(),getKnownCells:()=>new Map(j0),getCellSize:()=>N,destroy:()=>{H0(),I.forEach((B)=>clearTimeout(B.timeout)),I.clear(),r.clear(),j0.clear()}}},U9=function($,J,q){const Q=dQ($,J,q),G=$.overlay||{},U=i1(Q,G),Y=new Map;return{on:(Z,X)=>Q.on(Z,X),off:(Z,X)=>Q.off?.(Z,X),channel:(Z)=>{if(Y.has(Z))return Y.get(Z);const X=Q.channel(Z),N={send:(K,w)=>{U.send({_ch:Z,_d:K,_t:w})},on:(K,w)=>{if(K==="message")U.on("message",(j,z)=>{if(j?._ch===Z)w(j._d,z)}),X.on(K,w);else X.on(K,w)},off:(K,w)=>X.off?.(K,w),_original:X};return Y.set(Z,N),N},get id(){return Q.id},get peers(){return Q.peers},getPeers:()=>Q.getPeers?.()||{},mesh:U,_room:Q,getState:()=>U.getState(),getMetrics:(Z)=>U.getMetrics(Z),getCellHealth:(Z)=>U.getCellHealth(Z),getPeerInfo:()=>U.getPeerInfo(),ping:(Z)=>U.ping(Z),destroy:()=>{U.destroy(),Y.clear()}}},h1={cellSize:"auto",bridgesPerEdge:2,maxCellSize:50,targetCells:100,debug:!1},oQ=5000,c1=500,l1=3000,d1=30000,o1=2000,n8=($)=>{const J=String($||"").match(/cell-(\d+)/);return J?Number(J[1]):null},Z8=($)=>{const J=n8($);if(J==null)return[];const q=[];if(J>0)q.push(`cell-${J-1}`);return q.push(`cell-${J+1}`),q},r8=($)=>`c${(n8($)||0).toString(36)}`,p1=($,J,q)=>{if($<10)return 2;const Q=Math.ceil($/J);return Math.max(2,Math.min(q,Q))};class a8{constructor($){this.peerId=$,this.joinedAt=Date.now(),this.lastSeen=Date.now(),this.rttSamples=[],this.stability=1,this.reconnects=0,this.isResponsive=!0,this.connectedCells=new Set}get uptime(){return Date.now()-this.joinedAt}get avgRtt(){if(this.rttSamples.length===0)return Infinity;return Math.round(this.rttSamples.reduce(($,J)=>$+J,0)/this.rttSamples.length)}get healthScore(){const $=this.avgRtt===Infinity?0.5:Math.max(0,100-this.avgRtt)/100,J=Math.min(1,this.uptime/60000),q=this.stability,Q=this.isResponsive?1:0.3;return $*0.25+J*0.25+q*0.3+Q*0.2}get isStale(){return Date.now()-this.lastSeen>d1}addRttSample($){if(this.rttSamples.push($),this.rttSamples.length>10)this.rttSamples.shift();this.lastSeen=Date.now(),this.isResponsive=!0}markReconnect(){this.reconnects++,this.stability=Math.max(0,1-this.reconnects*0.1)}markUnresponsive(){this.isResponsive=!1}markSeen(){this.lastSeen=Date.now()}addConnectedCell($){if($)this.connectedCells.add($)}}export{m as selfId,U9 as join,m1 as getRelaySockets,h1 as OVERLAY_DEFAULTS};
