var u0=typeof globalThis==="object"&&("crypto"in globalThis)?globalThis.crypto:void 0;function F0($){return $ instanceof Uint8Array||ArrayBuffer.isView($)&&$.constructor.name==="Uint8Array"}function X8($){if(!Number.isSafeInteger($)||$<0)throw new Error("positive integer expected, got "+$)}function B0($,...J){if(!F0($))throw new Error("Uint8Array expected");if(J.length>0&&!J.includes($.length))throw new Error("Uint8Array expected of length "+J+", got length="+$.length)}function A8($){if(typeof $!=="function"||typeof $.create!=="function")throw new Error("Hash should be wrapped by utils.createHasher");X8($.outputLen),X8($.blockLen)}function t0($,J=!0){if($.destroyed)throw new Error("Hash instance has been destroyed");if(J&&$.finished)throw new Error("Hash#digest() has already been called")}function k$($,J){B0($);const q=J.outputLen;if($.length<q)throw new Error("digestInto() expects output buffer of length at least "+q)}function m0(...$){for(let J=0;J<$.length;J++)$[J].fill(0)}function w8($){return new DataView($.buffer,$.byteOffset,$.byteLength)}function O0($,J){return $<<32-J|$>>>J}function w0($){if(B0($),S$)return $.toHex();let J="";for(let q=0;q<$.length;q++)J+=rQ[$[q]];return J}var C$=function($){if($>=A0._0&&$<=A0._9)return $-A0._0;if($>=A0.A&&$<=A0.F)return $-(A0.A-10);if($>=A0.a&&$<=A0.f)return $-(A0.a-10);return};function h0($){if(typeof $!=="string")throw new Error("hex string expected, got "+typeof $);if(S$)return Uint8Array.fromHex($);const J=$.length,q=J/2;if(J%2)throw new Error("hex string expected, got unpadded hex of length "+J);const Q=new Uint8Array(q);for(let G=0,Y=0;G<q;G++,Y+=2){const U=C$($.charCodeAt(Y)),X=C$($.charCodeAt(Y+1));if(U===void 0||X===void 0){const Z=$[Y]+$[Y+1];throw new Error('hex string expected, got non-hex character "'+Z+'" at index '+Y)}Q[G]=U*16+X}return Q}function C8($){if(typeof $!=="string")throw new Error("string expected");return new Uint8Array((new TextEncoder()).encode($))}function Z8($){if(typeof $==="string")$=C8($);return B0($),$}function z0(...$){let J=0;for(let Q=0;Q<$.length;Q++){const G=$[Q];B0(G),J+=G.length}const q=new Uint8Array(J);for(let Q=0,G=0;Q<$.length;Q++){const Y=$[Q];q.set(Y,G),G+=Y.length}return q}function P$($){const J=(Q)=>$().update(Z8(Q)).digest(),q=$();return J.outputLen=q.outputLen,J.blockLen=q.blockLen,J.create=()=>$(),J}function c0($=32){if(u0&&typeof u0.getRandomValues==="function")return u0.getRandomValues(new Uint8Array($));if(u0&&typeof u0.randomBytes==="function")return Uint8Array.from(u0.randomBytes($));throw new Error("crypto.getRandomValues must be defined")}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */var S$=(()=>typeof Uint8Array.from([]).toHex==="function"&&typeof Uint8Array.fromHex==="function")(),rQ=Array.from({length:256},($,J)=>J.toString(16).padStart(2,"0")),A0={_0:48,_9:57,A:65,F:70,a:97,f:102};class z8{}function aQ($,J,q,Q){if(typeof $.setBigUint64==="function")return $.setBigUint64(J,q,Q);const G=BigInt(32),Y=BigInt(4294967295),U=Number(q>>G&Y),X=Number(q&Y),Z=Q?4:0,B=Q?0:4;$.setUint32(J+Z,U,Q),$.setUint32(J+B,X,Q)}function I$($,J,q){return $&J^~$&q}function E$($,J,q){return $&J^$&q^J&q}class s8 extends z8{constructor($,J,q,Q){super();this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=$,this.outputLen=J,this.padOffset=q,this.isLE=Q,this.buffer=new Uint8Array($),this.view=w8(this.buffer)}update($){t0(this),$=Z8($),B0($);const{view:J,buffer:q,blockLen:Q}=this,G=$.length;for(let Y=0;Y<G;){const U=Math.min(Q-this.pos,G-Y);if(U===Q){const X=w8($);for(;Q<=G-Y;Y+=Q)this.process(X,Y);continue}if(q.set($.subarray(Y,Y+U),this.pos),this.pos+=U,Y+=U,this.pos===Q)this.process(J,0),this.pos=0}return this.length+=$.length,this.roundClean(),this}digestInto($){t0(this),k$($,this),this.finished=!0;const{buffer:J,view:q,blockLen:Q,isLE:G}=this;let{pos:Y}=this;if(J[Y++]=128,m0(this.buffer.subarray(Y)),this.padOffset>Q-Y)this.process(q,0),Y=0;for(let D=Y;D<Q;D++)J[D]=0;aQ(q,Q-8,BigInt(this.length*8),G),this.process(q,0);const U=w8($),X=this.outputLen;if(X%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const Z=X/4,B=this.get();if(Z>B.length)throw new Error("_sha2: outputLen bigger than state");for(let D=0;D<Z;D++)U.setUint32(4*D,B[D],G)}digest(){const{buffer:$,outputLen:J}=this;this.digestInto($);const q=$.slice(0,J);return this.destroy(),q}_cloneInto($){$||($=new this.constructor),$.set(...this.get());const{blockLen:J,buffer:q,length:Q,finished:G,destroyed:Y,pos:U}=this;if($.destroyed=Y,$.finished=G,$.length=Q,$.pos=U,Q%J)$.buffer.set(q);return $}clone(){return this._cloneInto()}}var C0=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]);var nQ=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),v0=new Uint32Array(64);class v$ extends s8{constructor($=32){super(64,$,8,!1);this.A=C0[0]|0,this.B=C0[1]|0,this.C=C0[2]|0,this.D=C0[3]|0,this.E=C0[4]|0,this.F=C0[5]|0,this.G=C0[6]|0,this.H=C0[7]|0}get(){const{A:$,B:J,C:q,D:Q,E:G,F:Y,G:U,H:X}=this;return[$,J,q,Q,G,Y,U,X]}set($,J,q,Q,G,Y,U,X){this.A=$|0,this.B=J|0,this.C=q|0,this.D=Q|0,this.E=G|0,this.F=Y|0,this.G=U|0,this.H=X|0}process($,J){for(let D=0;D<16;D++,J+=4)v0[D]=$.getUint32(J,!1);for(let D=16;D<64;D++){const w=v0[D-15],j=v0[D-2],z=O0(w,7)^O0(w,18)^w>>>3,L=O0(j,17)^O0(j,19)^j>>>10;v0[D]=L+v0[D-7]+z+v0[D-16]|0}let{A:q,B:Q,C:G,D:Y,E:U,F:X,G:Z,H:B}=this;for(let D=0;D<64;D++){const w=O0(U,6)^O0(U,11)^O0(U,25),j=B+w+I$(U,X,Z)+nQ[D]+v0[D]|0,L=(O0(q,2)^O0(q,13)^O0(q,22))+E$(q,Q,G)|0;B=Z,Z=X,X=U,U=Y+j|0,Y=G,G=Q,Q=q,q=j+L|0}q=q+this.A|0,Q=Q+this.B|0,G=G+this.C|0,Y=Y+this.D|0,U=U+this.E|0,X=X+this.F|0,Z=Z+this.G|0,B=B+this.H|0,this.set(q,Q,G,Y,U,X,Z,B)}roundClean(){m0(v0)}destroy(){this.set(0,0,0,0,0,0,0,0),m0(this.buffer)}}var k8=P$(()=>new v$);class t8 extends z8{constructor($,J){super();this.finished=!1,this.destroyed=!1,A8($);const q=Z8(J);if(this.iHash=$.create(),typeof this.iHash.update!=="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const Q=this.blockLen,G=new Uint8Array(Q);G.set(q.length>Q?$.create().update(q).digest():q);for(let Y=0;Y<G.length;Y++)G[Y]^=54;this.iHash.update(G),this.oHash=$.create();for(let Y=0;Y<G.length;Y++)G[Y]^=54^92;this.oHash.update(G),m0(G)}update($){return t0(this),this.iHash.update($),this}digestInto($){t0(this),B0($,this.outputLen),this.finished=!0,this.iHash.digestInto($),this.oHash.update($),this.oHash.digestInto($),this.destroy()}digest(){const $=new Uint8Array(this.oHash.outputLen);return this.digestInto($),$}_cloneInto($){$||($=Object.create(Object.getPrototypeOf(this),{}));const{oHash:J,iHash:q,finished:Q,destroyed:G,blockLen:Y,outputLen:U}=this;return $=$,$.finished=Q,$.destroyed=G,$.blockLen=Y,$.outputLen=U,$.oHash=J._cloneInto($.oHash),$.iHash=q._cloneInto($.iHash),$}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}var e8=($,J,q)=>new t8($,J).update(q).digest();e8.create=($,J)=>new t8($,J);function K8($,J=""){if(typeof $!=="boolean"){const q=J&&`"${J}"`;throw new Error(q+"expected boolean, got type="+typeof $)}return $}function _0($,J,q=""){const Q=F0($),G=$?.length,Y=J!==void 0;if(!Q||Y&&G!==J){const U=q&&`"${q}" `,X=Y?` of length ${J}`:"",Z=Q?`length=${G}`:`type=${typeof $}`;throw new Error(U+"expected Uint8Array"+X+", got "+Z)}return $}function D8($){const J=$.toString(16);return J.length&1?"0"+J:J}function _$($){if(typeof $!=="string")throw new Error("hex string expected, got "+typeof $);return $===""?J$:BigInt("0x"+$)}function k0($){return _$(w0($))}function q$($){return B0($),_$(w0(Uint8Array.from($).reverse()))}function e0($,J){return h0($.toString(16).padStart(J*2,"0"))}function G$($,J){return e0($,J).reverse()}function o($,J,q){let Q;if(typeof J==="string")try{Q=h0(J)}catch(Y){throw new Error($+" must be hex string or Uint8Array, cause: "+Y)}else if(F0(J))Q=Uint8Array.from(J);else throw new Error($+" must be hex string or Uint8Array");const G=Q.length;if(typeof q==="number"&&G!==q)throw new Error($+" of length "+q+" expected, got "+G);return Q}function W8($,J,q){return $$($)&&$$(J)&&$$(q)&&J<=$&&$<q}function f$($,J,q,Q){if(!W8(J,q,Q))throw new Error("expected valid "+$+": "+q+" <= n < "+Q+", got "+J)}function S8($){let J;for(J=0;$>J$;$>>=Q$,J+=1);return J}function b$($,J,q){if(typeof $!=="number"||$<2)throw new Error("hashLen must be a number");if(typeof J!=="number"||J<2)throw new Error("qByteLen must be a number");if(typeof q!=="function")throw new Error("hmacFn must be a function");const Q=(z)=>new Uint8Array(z),G=(z)=>Uint8Array.of(z);let Y=Q($),U=Q($),X=0;const Z=()=>{Y.fill(1),U.fill(0),X=0},B=(...z)=>q(U,Y,...z),D=(z=Q(0))=>{if(U=B(G(0),z),Y=B(),z.length===0)return;U=B(G(1),z),Y=B()},w=()=>{if(X++>=1000)throw new Error("drbg: tried 1000 values");let z=0;const L=[];while(z<J){Y=B();const k=Y.slice();L.push(k),z+=Y.length}return z0(...L)};return(z,L)=>{Z(),D(z);let k=void 0;while(!(k=L(w())))D();return Z(),k}}function M8($,J,q={}){if(!$||typeof $!=="object")throw new Error("expected valid options object");function Q(G,Y,U){const X=$[G];if(U&&X===void 0)return;const Z=typeof X;if(Z!==Y||X===null)throw new Error(`param "${G}" is invalid: expected ${Y}, got ${Z}`)}Object.entries(J).forEach(([G,Y])=>Q(G,Y,!1)),Object.entries(q).forEach(([G,Y])=>Q(G,Y,!0))}function Y$($){const J=new WeakMap;return(q,...Q)=>{const G=J.get(q);if(G!==void 0)return G;const Y=$(q,...Q);return J.set(q,Y),Y}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var J$=BigInt(0),Q$=BigInt(1),$$=($)=>typeof $==="bigint"&&J$<=$,f0=($)=>(Q$<<BigInt($))-Q$;function D0($,J){const q=$%J;return q>=U0?q:J+q}function W0($,J,q){let Q=$;while(J-- >U0)Q*=Q,Q%=q;return Q}function y$($,J){if($===U0)throw new Error("invert: expected non-zero number");if(J<=U0)throw new Error("invert: expected positive modulus, got "+J);let q=D0($,J),Q=J,G=U0,Y=G0,U=G0,X=U0;while(q!==U0){const B=Q/q,D=Q%q,w=G-U*B,j=Y-X*B;Q=q,q=D,G=U,Y=X,U=w,X=j}if(Q!==G0)throw new Error("invert: does not exist");return D0(G,J)}var U$=function($,J,q){if(!$.eql($.sqr(J),q))throw new Error("Cannot find square root")},l$=function($,J){const q=($.ORDER+G0)/F$,Q=$.pow(J,q);return U$($,Q,J),Q},eQ=function($,J){const q=($.ORDER-m$)/h$,Q=$.mul(J,l0),G=$.pow(Q,q),Y=$.mul(J,G),U=$.mul($.mul(Y,l0),G),X=$.mul(Y,$.sub(U,$.ONE));return U$($,X,J),X},$J=function($){const J=b0($),q=d$($),Q=q(J,J.neg(J.ONE)),G=q(J,Q),Y=q(J,J.neg(Q)),U=($+sQ)/c$;return(X,Z)=>{let B=X.pow(Z,U),D=X.mul(B,Q);const w=X.mul(B,G),j=X.mul(B,Y),z=X.eql(X.sqr(D),Z),L=X.eql(X.sqr(w),Z);B=X.cmov(B,D,z),D=X.cmov(j,w,L);const k=X.eql(X.sqr(D),Z),S=X.cmov(B,D,k);return U$(X,S,Z),S}};function d$($){if($<u$)throw new Error("sqrt is not defined for small field");let J=$-G0,q=0;while(J%l0===U0)J/=l0,q++;let Q=l0;const G=b0($);while(g$(G,Q)===1)if(Q++>1000)throw new Error("Cannot find square root: probably non-prime P");if(q===1)return l$;let Y=G.pow(Q,J);const U=(J+G0)/l0;return function X(Z,B){if(Z.is0(B))return B;if(g$(Z,B)!==1)throw new Error("Cannot find square root");let D=q,w=Z.mul(Z.ONE,Y),j=Z.pow(B,J),z=Z.pow(B,U);while(!Z.eql(j,Z.ONE)){if(Z.is0(j))return Z.ZERO;let L=1,k=Z.sqr(j);while(!Z.eql(k,Z.ONE))if(L++,k=Z.sqr(k),L===D)throw new Error("Cannot find square root");const S=G0<<BigInt(D-L-1),g=Z.pow(w,S);D=L,w=Z.sqr(g),j=Z.mul(j,w),z=Z.mul(z,g)}return z}}function QJ($){if($%F$===u$)return l$;if($%h$===m$)return eQ;if($%c$===tQ)return $J($);return d$($)}function j$($){const J={ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"},q=JJ.reduce((Q,G)=>{return Q[G]="function",Q},J);return M8($,q),$}function qJ($,J,q){if(q<U0)throw new Error("invalid exponent, negatives unsupported");if(q===U0)return $.ONE;if(q===G0)return J;let Q=$.ONE,G=J;while(q>U0){if(q&G0)Q=$.mul(Q,G);G=$.sqr(G),q>>=G0}return Q}function P8($,J,q=!1){const Q=new Array(J.length).fill(q?$.ZERO:void 0),G=J.reduce((U,X,Z)=>{if($.is0(X))return U;return Q[Z]=U,$.mul(U,X)},$.ONE),Y=$.inv(G);return J.reduceRight((U,X,Z)=>{if($.is0(X))return U;return Q[Z]=$.mul(U,Q[Z]),$.mul(U,X)},Y),Q}function g$($,J){const q=($.ORDER-G0)/l0,Q=$.pow(J,q),G=$.eql(Q,$.ONE),Y=$.eql(Q,$.ZERO),U=$.eql(Q,$.neg($.ONE));if(!G&&!Y&&!U)throw new Error("invalid Legendre symbol result");return G?1:Y?0:-1}function I8($,J){if(J!==void 0)X8(J);const q=J!==void 0?J:$.toString(2).length,Q=Math.ceil(q/8);return{nBitLength:q,nByteLength:Q}}function b0($,J,q=!1,Q={}){if($<=U0)throw new Error("invalid field: expected ORDER > 0, got "+$);let G=void 0,Y=void 0,U=!1,X=void 0;if(typeof J==="object"&&J!=null){if(Q.sqrt||q)throw new Error("cannot specify opts in two arguments");const j=J;if(j.BITS)G=j.BITS;if(j.sqrt)Y=j.sqrt;if(typeof j.isLE==="boolean")q=j.isLE;if(typeof j.modFromBytes==="boolean")U=j.modFromBytes;X=j.allowedLengths}else{if(typeof J==="number")G=J;if(Q.sqrt)Y=Q.sqrt}const{nBitLength:Z,nByteLength:B}=I8($,G);if(B>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let D;const w=Object.freeze({ORDER:$,isLE:q,BITS:Z,BYTES:B,MASK:f0(Z),ZERO:U0,ONE:G0,allowedLengths:X,create:(j)=>D0(j,$),isValid:(j)=>{if(typeof j!=="bigint")throw new Error("invalid field element: expected bigint, got "+typeof j);return U0<=j&&j<$},is0:(j)=>j===U0,isValidNot0:(j)=>!w.is0(j)&&w.isValid(j),isOdd:(j)=>(j&G0)===G0,neg:(j)=>D0(-j,$),eql:(j,z)=>j===z,sqr:(j)=>D0(j*j,$),add:(j,z)=>D0(j+z,$),sub:(j,z)=>D0(j-z,$),mul:(j,z)=>D0(j*z,$),pow:(j,z)=>qJ(w,j,z),div:(j,z)=>D0(j*y$(z,$),$),sqrN:(j)=>j*j,addN:(j,z)=>j+z,subN:(j,z)=>j-z,mulN:(j,z)=>j*z,inv:(j)=>y$(j,$),sqrt:Y||((j)=>{if(!D)D=QJ($);return D(w,j)}),toBytes:(j)=>q?G$(j,B):e0(j,B),fromBytes:(j,z=!0)=>{if(X){if(!X.includes(j.length)||j.length>B)throw new Error("Field.fromBytes: expected "+X+" bytes, got "+j.length);const k=new Uint8Array(B);k.set(j,q?0:k.length-j.length),j=k}if(j.length!==B)throw new Error("Field.fromBytes: expected "+B+" bytes, got "+j.length);let L=q?q$(j):k0(j);if(U)L=D0(L,$);if(!z){if(!w.isValid(L))throw new Error("invalid field element: outside of range 0..ORDER")}return L},invertBatch:(j)=>P8(w,j),cmov:(j,z,L)=>L?z:j});return Object.freeze(w)}function o$($){if(typeof $!=="bigint")throw new Error("field order must be bigint");const J=$.toString(2).length;return Math.ceil(J/8)}function X$($){const J=o$($);return J+Math.ceil(J/2)}function E8($,J,q=!1){const Q=$.length,G=o$(J),Y=X$(J);if(Q<16||Q<Y||Q>1024)throw new Error("expected "+Y+"-1024 bytes of input, got "+Q);const U=q?q$($):k0($),X=D0(U,J-G0)+G0;return q?G$(X,G):e0(X,G)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var U0=BigInt(0),G0=BigInt(1),l0=BigInt(2),u$=BigInt(3),F$=BigInt(4),m$=BigInt(5),sQ=BigInt(7),h$=BigInt(8),tQ=BigInt(9),c$=BigInt(16);var JJ=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function V8($,J){const q=J.negate();return $?q:J}function v8($,J){const q=P8($.Fp,J.map((Q)=>Q.Z));return J.map((Q,G)=>$.fromAffine(Q.toAffine(q[G])))}var a$=function($,J){if(!Number.isSafeInteger($)||$<=0||$>J)throw new Error("invalid window size, expected [1.."+J+"], got W="+$)},Z$=function($,J){a$($,J);const q=Math.ceil(J/$)+1,Q=2**($-1),G=2**$,Y=f0($),U=BigInt($);return{windows:q,windowSize:Q,mask:Y,maxNumber:G,shiftBy:U}},p$=function($,J,q){const{windowSize:Q,mask:G,maxNumber:Y,shiftBy:U}=q;let X=Number($&G),Z=$>>U;if(X>Q)X-=Y,Z+=d0;const B=J*Q,D=B+Math.abs(X)-1,w=X===0,j=X<0,z=J%2!==0;return{nextN:Z,offset:D,isZero:w,isNeg:j,isNegF:z,offsetF:B}},GJ=function($,J){if(!Array.isArray($))throw new Error("array expected");$.forEach((q,Q)=>{if(!(q instanceof J))throw new Error("invalid point at index "+Q)})},YJ=function($,J){if(!Array.isArray($))throw new Error("array of scalars expected");$.forEach((q,Q)=>{if(!J.isValid(q))throw new Error("invalid scalar at index "+Q)})},K$=function($){return n$.get($)||1},i$=function($){if($!==$8)throw new Error("invalid wNAF")};function s$($,J,q,Q){let G=J,Y=$.ZERO,U=$.ZERO;while(q>$8||Q>$8){if(q&d0)Y=Y.add(G);if(Q&d0)U=U.add(G);G=G.double(),q>>=d0,Q>>=d0}return{p1:Y,p2:U}}function t$($,J,q,Q){GJ(q,$),YJ(Q,J);const G=q.length,Y=Q.length;if(G!==Y)throw new Error("arrays of points and scalars must have equal length");const U=$.ZERO,X=S8(BigInt(G));let Z=1;if(X>12)Z=X-3;else if(X>4)Z=X-2;else if(X>0)Z=2;const B=f0(Z),D=new Array(Number(B)+1).fill(U),w=Math.floor((J.BITS-1)/Z)*Z;let j=U;for(let z=w;z>=0;z-=Z){D.fill(U);for(let k=0;k<Y;k++){const S=Q[k],g=Number(S>>BigInt(z)&B);D[g]=D[g].add(q[k])}let L=U;for(let k=D.length-1,S=U;k>0;k--)S=S.add(D[k]),L=L.add(S);if(j=j.add(L),z!==0)for(let k=0;k<Z;k++)j=j.double()}return j}var r$=function($,J,q){if(J){if(J.ORDER!==$)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return j$(J),J}else return b0($,{isLE:q})};function e$($,J,q={},Q){if(Q===void 0)Q=$==="edwards";if(!J||typeof J!=="object")throw new Error(`expected valid ${$} CURVE object`);for(let Z of["p","n","h"]){const B=J[Z];if(!(typeof B==="bigint"&&B>$8))throw new Error(`CURVE.${Z} must be positive bigint`)}const G=r$(J.p,q.Fp,Q),Y=r$(J.n,q.Fn,Q),X=["Gx","Gy","a",$==="weierstrass"?"b":"d"];for(let Z of X)if(!G.isValid(J[Z]))throw new Error(`CURVE.${Z} must be valid field element of CURVE.Fp`);return J=Object.freeze(Object.assign({},J)),{CURVE:J,Fp:G,Fn:Y}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var $8=BigInt(0),d0=BigInt(1),z$=new WeakMap,n$=new WeakMap;class D${constructor($,J){this.BASE=$.BASE,this.ZERO=$.ZERO,this.Fn=$.Fn,this.bits=J}_unsafeLadder($,J,q=this.ZERO){let Q=$;while(J>$8){if(J&d0)q=q.add(Q);Q=Q.double(),J>>=d0}return q}precomputeWindow($,J){const{windows:q,windowSize:Q}=Z$(J,this.bits),G=[];let Y=$,U=Y;for(let X=0;X<q;X++){U=Y,G.push(U);for(let Z=1;Z<Q;Z++)U=U.add(Y),G.push(U);Y=U.double()}return G}wNAF($,J,q){if(!this.Fn.isValid(q))throw new Error("invalid scalar");let Q=this.ZERO,G=this.BASE;const Y=Z$($,this.bits);for(let U=0;U<Y.windows;U++){const{nextN:X,offset:Z,isZero:B,isNeg:D,isNegF:w,offsetF:j}=p$(q,U,Y);if(q=X,B)G=G.add(V8(w,J[j]));else Q=Q.add(V8(D,J[Z]))}return i$(q),{p:Q,f:G}}wNAFUnsafe($,J,q,Q=this.ZERO){const G=Z$($,this.bits);for(let Y=0;Y<G.windows;Y++){if(q===$8)break;const{nextN:U,offset:X,isZero:Z,isNeg:B}=p$(q,Y,G);if(q=U,Z)continue;else{const D=J[X];Q=Q.add(B?D.negate():D)}}return i$(q),Q}getPrecomputes($,J,q){let Q=z$.get(J);if(!Q){if(Q=this.precomputeWindow(J,$),$!==1){if(typeof q==="function")Q=q(Q);z$.set(J,Q)}}return Q}cached($,J,q){const Q=K$($);return this.wNAF(Q,this.getPrecomputes(Q,$,q),J)}unsafe($,J,q,Q){const G=K$($);if(G===1)return this._unsafeLadder($,J,Q);return this.wNAFUnsafe(G,this.getPrecomputes(G,$,q),J,Q)}createCache($,J){a$(J,this.bits),n$.set($,J),z$.delete($)}hasCache($){return K$($)!==1}}function UJ($,J,q){const[[Q,G],[Y,U]]=J,X=$Q(U*$,q),Z=$Q(-G*$,q);let B=$-X*Q-Z*Y,D=-X*G-Z*U;const w=B<P0,j=D<P0;if(w)B=-B;if(j)D=-D;const z=f0(Math.ceil(S8(q)/2))+Q8;if(B<P0||B>=z||D<P0||D>=z)throw new Error("splitScalar (endomorphism): failed, k="+$);return{k1neg:w,k1:B,k2neg:j,k2:D}}var M$=function($){if(!["compact","recovered","der"].includes($))throw new Error('Signature format must be "compact", "recovered", or "der"');return $},W$=function($,J){const q={};for(let Q of Object.keys(J))q[Q]=$[Q]===void 0?J[Q]:$[Q];if(K8(q.lowS,"lowS"),K8(q.prehash,"prehash"),q.format!==void 0)M$(q.format);return q};function y0($,J){const{BYTES:q}=$;let Q;if(typeof J==="bigint")Q=J;else{let G=o("private key",J);try{Q=$.fromBytes(G)}catch(Y){throw new Error(`invalid private key: expected ui8a of size ${q}, got ${typeof J}`)}}if(!$.isValidNot0(Q))throw new Error("invalid private key: out of range [1..N-1]");return Q}function XJ($,J={}){const q=e$("weierstrass",$,J),{Fp:Q,Fn:G}=q;let Y=q.CURVE;const{h:U,n:X}=Y;M8(J,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:Z}=J;if(Z){if(!Q.is0(Y.a)||typeof Z.beta!=="bigint"||!Array.isArray(Z.basises))throw new Error('invalid endo: expected "beta": bigint and "basises": array')}const B=GQ(Q,G);function D(){if(!Q.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function w(V,T,M){const{x:R,y:K}=T.toAffine(),W=Q.toBytes(R);if(K8(M,"isCompressed"),M){D();const O=!Q.isOdd(K);return z0(qQ(O),W)}else return z0(Uint8Array.of(4),W,Q.toBytes(K))}function j(V){_0(V,void 0,"Point");const{publicKey:T,publicKeyUncompressed:M}=B,R=V.length,K=V[0],W=V.subarray(1);if(R===T&&(K===2||K===3)){const O=Q.fromBytes(W);if(!Q.isValid(O))throw new Error("bad point: is not on curve, wrong x");const H=k(O);let x;try{x=Q.sqrt(H)}catch(f){const _=f instanceof Error?": "+f.message:"";throw new Error("bad point: is not on curve, sqrt error"+_)}D();const C=Q.isOdd(x);if((K&1)===1!==C)x=Q.neg(x);return{x:O,y:x}}else if(R===M&&K===4){const O=Q.BYTES,H=Q.fromBytes(W.subarray(0,O)),x=Q.fromBytes(W.subarray(O,O*2));if(!S(H,x))throw new Error("bad point: is not on curve");return{x:H,y:x}}else throw new Error(`bad point: got length ${R}, expected compressed=${T} or uncompressed=${M}`)}const z=J.toBytes||w,L=J.fromBytes||j;function k(V){const T=Q.sqr(V),M=Q.mul(T,V);return Q.add(Q.add(M,Q.mul(V,Y.a)),Y.b)}function S(V,T){const M=Q.sqr(T),R=k(V);return Q.eql(M,R)}if(!S(Y.Gx,Y.Gy))throw new Error("bad curve params: generator point");const g=Q.mul(Q.pow(Y.a,_8),jJ),s=Q.mul(Q.sqr(Y.b),BigInt(27));if(Q.is0(Q.add(g,s)))throw new Error("bad curve params: a or b");function F(V,T,M=!1){if(!Q.isValid(T)||M&&Q.is0(T))throw new Error(`bad point coordinate ${V}`);return T}function r(V){if(!(V instanceof P))throw new Error("ProjectivePoint expected")}function J0(V){if(!Z||!Z.basises)throw new Error("no endo");return UJ(V,Z.basises,G.ORDER)}const q0=Y$((V,T)=>{const{X:M,Y:R,Z:K}=V;if(Q.eql(K,Q.ONE))return{x:M,y:R};const W=V.is0();if(T==null)T=W?Q.ONE:Q.inv(K);const O=Q.mul(M,T),H=Q.mul(R,T),x=Q.mul(K,T);if(W)return{x:Q.ZERO,y:Q.ZERO};if(!Q.eql(x,Q.ONE))throw new Error("invZ was invalid");return{x:O,y:H}}),V0=Y$((V)=>{if(V.is0()){if(J.allowInfinityPoint&&!Q.is0(V.Y))return;throw new Error("bad point: ZERO")}const{x:T,y:M}=V.toAffine();if(!Q.isValid(T)||!Q.isValid(M))throw new Error("bad point: x or y not field elements");if(!S(T,M))throw new Error("bad point: equation left != right");if(!V.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function Y0(V,T,M,R,K){return M=new P(Q.mul(M.X,V),M.Y,M.Z),T=V8(R,T),M=V8(K,M),T.add(M)}class P{constructor(V,T,M){this.X=F("x",V),this.Y=F("y",T,!0),this.Z=F("z",M),Object.freeze(this)}static CURVE(){return Y}static fromAffine(V){const{x:T,y:M}=V||{};if(!V||!Q.isValid(T)||!Q.isValid(M))throw new Error("invalid affine point");if(V instanceof P)throw new Error("projective point not allowed");if(Q.is0(T)&&Q.is0(M))return P.ZERO;return new P(T,M,Q.ONE)}static fromBytes(V){const T=P.fromAffine(L(_0(V,void 0,"point")));return T.assertValidity(),T}static fromHex(V){return P.fromBytes(o("pointHex",V))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(V=8,T=!0){if(I.createCache(this,V),!T)this.multiply(_8);return this}assertValidity(){V0(this)}hasEvenY(){const{y:V}=this.toAffine();if(!Q.isOdd)throw new Error("Field doesn't support isOdd");return!Q.isOdd(V)}equals(V){r(V);const{X:T,Y:M,Z:R}=this,{X:K,Y:W,Z:O}=V,H=Q.eql(Q.mul(T,O),Q.mul(K,R)),x=Q.eql(Q.mul(M,O),Q.mul(W,R));return H&&x}negate(){return new P(this.X,Q.neg(this.Y),this.Z)}double(){const{a:V,b:T}=Y,M=Q.mul(T,_8),{X:R,Y:K,Z:W}=this;let{ZERO:O,ZERO:H,ZERO:x}=Q,C=Q.mul(R,R),h=Q.mul(K,K),f=Q.mul(W,W),_=Q.mul(R,K);return _=Q.add(_,_),x=Q.mul(R,W),x=Q.add(x,x),O=Q.mul(V,x),H=Q.mul(M,f),H=Q.add(O,H),O=Q.sub(h,H),H=Q.add(h,H),H=Q.mul(O,H),O=Q.mul(_,O),x=Q.mul(M,x),f=Q.mul(V,f),_=Q.sub(C,f),_=Q.mul(V,_),_=Q.add(_,x),x=Q.add(C,C),C=Q.add(x,C),C=Q.add(C,f),C=Q.mul(C,_),H=Q.add(H,C),f=Q.mul(K,W),f=Q.add(f,f),C=Q.mul(f,_),O=Q.sub(O,C),x=Q.mul(f,h),x=Q.add(x,x),x=Q.add(x,x),new P(O,H,x)}add(V){r(V);const{X:T,Y:M,Z:R}=this,{X:K,Y:W,Z:O}=V;let{ZERO:H,ZERO:x,ZERO:C}=Q;const h=Y.a,f=Q.mul(Y.b,_8);let _=Q.mul(T,K),b=Q.mul(M,W),u=Q.mul(R,O),y=Q.add(T,M),l=Q.add(K,W);y=Q.mul(y,l),l=Q.add(_,b),y=Q.sub(y,l),l=Q.add(T,R);let d=Q.add(K,O);return l=Q.mul(l,d),d=Q.add(_,u),l=Q.sub(l,d),d=Q.add(M,R),H=Q.add(W,O),d=Q.mul(d,H),H=Q.add(b,u),d=Q.sub(d,H),C=Q.mul(h,l),H=Q.mul(f,u),C=Q.add(H,C),H=Q.sub(b,C),C=Q.add(b,C),x=Q.mul(H,C),b=Q.add(_,_),b=Q.add(b,_),u=Q.mul(h,u),l=Q.mul(f,l),b=Q.add(b,u),u=Q.sub(_,u),u=Q.mul(h,u),l=Q.add(l,u),_=Q.mul(b,l),x=Q.add(x,_),_=Q.mul(d,l),H=Q.mul(y,H),H=Q.sub(H,_),_=Q.mul(y,b),C=Q.mul(d,C),C=Q.add(C,_),new P(H,x,C)}subtract(V){return this.add(V.negate())}is0(){return this.equals(P.ZERO)}multiply(V){const{endo:T}=J;if(!G.isValidNot0(V))throw new Error("invalid scalar: out of range");let M,R;const K=(W)=>I.cached(this,W,(O)=>v8(P,O));if(T){const{k1neg:W,k1:O,k2neg:H,k2:x}=J0(V),{p:C,f:h}=K(O),{p:f,f:_}=K(x);R=h.add(_),M=Y0(T.beta,C,f,W,H)}else{const{p:W,f:O}=K(V);M=W,R=O}return v8(P,[M,R])[0]}multiplyUnsafe(V){const{endo:T}=J,M=this;if(!G.isValid(V))throw new Error("invalid scalar: out of range");if(V===P0||M.is0())return P.ZERO;if(V===Q8)return M;if(I.hasCache(this))return this.multiply(V);if(T){const{k1neg:R,k1:K,k2neg:W,k2:O}=J0(V),{p1:H,p2:x}=s$(P,M,K,O);return Y0(T.beta,H,x,R,W)}else return I.unsafe(M,V)}multiplyAndAddUnsafe(V,T,M){const R=this.multiplyUnsafe(T).add(V.multiplyUnsafe(M));return R.is0()?void 0:R}toAffine(V){return q0(this,V)}isTorsionFree(){const{isTorsionFree:V}=J;if(U===Q8)return!0;if(V)return V(P,this);return I.unsafe(this,X).is0()}clearCofactor(){const{clearCofactor:V}=J;if(U===Q8)return this;if(V)return V(P,this);return this.multiplyUnsafe(U)}isSmallOrder(){return this.multiplyUnsafe(U).is0()}toBytes(V=!0){return K8(V,"isCompressed"),this.assertValidity(),z(P,this,V)}toHex(V=!0){return w0(this.toBytes(V))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(V=!0){return this.toBytes(V)}_setWindowSize(V){this.precompute(V)}static normalizeZ(V){return v8(P,V)}static msm(V,T){return t$(P,G,V,T)}static fromPrivateKey(V){return P.BASE.multiply(y0(G,V))}}P.BASE=new P(Y.Gx,Y.Gy,Q.ONE),P.ZERO=new P(Q.ZERO,Q.ONE,Q.ZERO),P.Fp=Q,P.Fn=G;const j0=G.BITS,I=new D$(P,J.endo?Math.ceil(j0/2):j0);return P.BASE.precompute(8),P}var qQ=function($){return Uint8Array.of($?2:3)};var GQ=function($,J){return{secretKey:J.BYTES,publicKey:1+$.BYTES,publicKeyUncompressed:1+2*$.BYTES,publicKeyHasPrefix:!0,signature:2*J.BYTES}};function ZJ($,J={}){const{Fn:q}=$,Q=J.randomBytes||c0,G=Object.assign(GQ($.Fp,q),{seed:X$(q.ORDER)});function Y(z){try{return!!y0(q,z)}catch(L){return!1}}function U(z,L){const{publicKey:k,publicKeyUncompressed:S}=G;try{const g=z.length;if(L===!0&&g!==k)return!1;if(L===!1&&g!==S)return!1;return!!$.fromBytes(z)}catch(g){return!1}}function X(z=Q(G.seed)){return E8(_0(z,G.seed,"seed"),q.ORDER)}function Z(z,L=!0){return $.BASE.multiply(y0(q,z)).toBytes(L)}function B(z){const L=X(z);return{secretKey:L,publicKey:Z(L)}}function D(z){if(typeof z==="bigint")return!1;if(z instanceof $)return!0;const{secretKey:L,publicKey:k,publicKeyUncompressed:S}=G;if(q.allowedLengths||L===k)return;const g=o("key",z).length;return g===k||g===S}function w(z,L,k=!0){if(D(z)===!0)throw new Error("first arg must be private key");if(D(L)===!1)throw new Error("second arg must be public key");const S=y0(q,z);return $.fromHex(L).multiply(S).toBytes(k)}return Object.freeze({getPublicKey:Z,getSharedSecret:w,keygen:B,Point:$,utils:{isValidSecretKey:Y,isValidPublicKey:U,randomSecretKey:X,isValidPrivateKey:Y,randomPrivateKey:X,normPrivateKeyToScalar:(z)=>y0(q,z),precompute(z=8,L=$.BASE){return L.precompute(z,!1)}},lengths:G})}function zJ($,J,q={}){A8(J),M8(q,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const Q=q.randomBytes||c0,G=q.hmac||((M,...R)=>e8(J,M,z0(...R))),{Fp:Y,Fn:U}=$,{ORDER:X,BITS:Z}=U,{keygen:B,getPublicKey:D,getSharedSecret:w,utils:j,lengths:z}=ZJ($,q),L={prehash:!1,lowS:typeof q.lowS==="boolean"?q.lowS:!1,format:void 0,extraEntropy:!1},k="compact";function S(M){const R=X>>Q8;return M>R}function g(M,R){if(!U.isValidNot0(R))throw new Error(`invalid signature ${M}: out of range 1..Point.Fn.ORDER`);return R}function s(M,R){M$(R);const K=z.signature,W=R==="compact"?K:R==="recovered"?K+1:void 0;return _0(M,W,`${R} signature`)}class F{constructor(M,R,K){if(this.r=g("r",M),this.s=g("s",R),K!=null)this.recovery=K;Object.freeze(this)}static fromBytes(M,R=k){s(M,R);let K;if(R==="der"){const{r:x,s:C}=S0.toSig(_0(M));return new F(x,C)}if(R==="recovered")K=M[0],R="compact",M=M.subarray(1);const W=U.BYTES,O=M.subarray(0,W),H=M.subarray(W,W*2);return new F(U.fromBytes(O),U.fromBytes(H),K)}static fromHex(M,R){return this.fromBytes(h0(M),R)}addRecoveryBit(M){return new F(this.r,this.s,M)}recoverPublicKey(M){const R=Y.ORDER,{r:K,s:W,recovery:O}=this;if(O==null||![0,1,2,3].includes(O))throw new Error("recovery id invalid");if(X*JQ<R&&O>1)throw new Error("recovery id is ambiguous for h>1 curve");const x=O===2||O===3?K+X:K;if(!Y.isValid(x))throw new Error("recovery id 2 or 3 invalid");const C=Y.toBytes(x),h=$.fromBytes(z0(qQ((O&1)===0),C)),f=U.inv(x),_=J0(o("msgHash",M)),b=U.create(-_*f),u=U.create(W*f),y=$.BASE.multiplyUnsafe(b).add(h.multiplyUnsafe(u));if(y.is0())throw new Error("point at infinify");return y.assertValidity(),y}hasHighS(){return S(this.s)}toBytes(M=k){if(M$(M),M==="der")return h0(S0.hexFromSig(this));const R=U.toBytes(this.r),K=U.toBytes(this.s);if(M==="recovered"){if(this.recovery==null)throw new Error("recovery bit must be present");return z0(Uint8Array.of(this.recovery),R,K)}return z0(R,K)}toHex(M){return w0(this.toBytes(M))}assertValidity(){}static fromCompact(M){return F.fromBytes(o("sig",M),"compact")}static fromDER(M){return F.fromBytes(o("sig",M),"der")}normalizeS(){return this.hasHighS()?new F(this.r,U.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return w0(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return w0(this.toBytes("compact"))}}const r=q.bits2int||function M(R){if(R.length>8192)throw new Error("input is too large");const K=k0(R),W=R.length*8-Z;return W>0?K>>BigInt(W):K},J0=q.bits2int_modN||function M(R){return U.create(r(R))},q0=f0(Z);function V0(M){return f$("num < 2^"+Z,M,P0,q0),U.toBytes(M)}function Y0(M,R){return _0(M,void 0,"message"),R?_0(J(M),void 0,"prehashed message"):M}function P(M,R,K){if(["recovered","canonical"].some((u)=>(u in K)))throw new Error("sign() legacy options not supported");const{lowS:W,prehash:O,extraEntropy:H}=W$(K,L);M=Y0(M,O);const x=J0(M),C=y0(U,R),h=[V0(C),V0(x)];if(H!=null&&H!==!1){const u=H===!0?Q(z.secretKey):H;h.push(o("extraEntropy",u))}const f=z0(...h),_=x;function b(u){const y=r(u);if(!U.isValidNot0(y))return;const l=U.inv(y),d=$.BASE.multiply(y).toAffine(),n=U.create(d.x);if(n===P0)return;const X0=U.create(l*U.create(_+n*C));if(X0===P0)return;let t=(d.x===n?0:2)|Number(d.y&Q8),e=X0;if(W&&S(X0))e=U.neg(X0),t^=1;return new F(n,e,t)}return{seed:f,k2sig:b}}function j0(M,R,K={}){M=o("message",M);const{seed:W,k2sig:O}=P(M,R,K);return b$(J.outputLen,U.BYTES,G)(W,O)}function I(M){let R=void 0;const K=typeof M==="string"||F0(M),W=!K&&M!==null&&typeof M==="object"&&typeof M.r==="bigint"&&typeof M.s==="bigint";if(!K&&!W)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(W)R=new F(M.r,M.s);else if(K){try{R=F.fromBytes(o("sig",M),"der")}catch(O){if(!(O instanceof S0.Err))throw O}if(!R)try{R=F.fromBytes(o("sig",M),"compact")}catch(O){return!1}}if(!R)return!1;return R}function V(M,R,K,W={}){const{lowS:O,prehash:H,format:x}=W$(W,L);if(K=o("publicKey",K),R=Y0(o("message",R),H),("strict"in W))throw new Error("options.strict was renamed to lowS");const C=x===void 0?I(M):F.fromBytes(o("sig",M),x);if(C===!1)return!1;try{const h=$.fromBytes(K);if(O&&C.hasHighS())return!1;const{r:f,s:_}=C,b=J0(R),u=U.inv(_),y=U.create(b*u),l=U.create(f*u),d=$.BASE.multiplyUnsafe(y).add(h.multiplyUnsafe(l));if(d.is0())return!1;return U.create(d.x)===f}catch(h){return!1}}function T(M,R,K={}){const{prehash:W}=W$(K,L);return R=Y0(R,W),F.fromBytes(M,"recovered").recoverPublicKey(R).toBytes()}return Object.freeze({keygen:B,getPublicKey:D,getSharedSecret:w,utils:j,lengths:z,Point:$,sign:j0,verify:V,recoverPublicKey:T,Signature:F,hash:J})}var KJ=function($){const J={a:$.a,b:$.b,p:$.Fp.ORDER,n:$.n,h:$.h,Gx:$.Gx,Gy:$.Gy},q=$.Fp;let Q=$.allowedPrivateKeyLengths?Array.from(new Set($.allowedPrivateKeyLengths.map((U)=>Math.ceil(U/2)))):void 0;const G=b0(J.n,{BITS:$.nBitLength,allowedLengths:Q,modFromBytes:$.wrapPrivateKey}),Y={Fp:q,Fn:G,allowInfinityPoint:$.allowInfinityPoint,endo:$.endo,isTorsionFree:$.isTorsionFree,clearCofactor:$.clearCofactor,fromBytes:$.fromBytes,toBytes:$.toBytes};return{CURVE:J,curveOpts:Y}},DJ=function($){const{CURVE:J,curveOpts:q}=KJ($),Q={hmac:$.hmac,randomBytes:$.randomBytes,lowS:$.lowS,bits2int:$.bits2int,bits2int_modN:$.bits2int_modN};return{CURVE:J,curveOpts:q,hash:$.hash,ecdsaOpts:Q}};var WJ=function($,J){const q=J.Point;return Object.assign({},J,{ProjectivePoint:q,CURVE:Object.assign({},$,I8(q.Fn.ORDER,q.Fn.BITS))})};function YQ($){const{CURVE:J,curveOpts:q,hash:Q,ecdsaOpts:G}=DJ($),Y=XJ(J,q),U=zJ(Y,Q,G);return WJ($,U)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var $Q=($,J)=>($+($>=0?J:-J)/JQ)/J;class QQ extends Error{constructor($=""){super($)}}var S0={Err:QQ,_tlv:{encode:($,J)=>{const{Err:q}=S0;if($<0||$>256)throw new q("tlv.encode: wrong tag");if(J.length&1)throw new q("tlv.encode: unpadded data");const Q=J.length/2,G=D8(Q);if(G.length/2&128)throw new q("tlv.encode: long form length too big");const Y=Q>127?D8(G.length/2|128):"";return D8($)+Y+G+J},decode($,J){const{Err:q}=S0;let Q=0;if($<0||$>256)throw new q("tlv.encode: wrong tag");if(J.length<2||J[Q++]!==$)throw new q("tlv.decode: wrong tlv");const G=J[Q++],Y=!!(G&128);let U=0;if(!Y)U=G;else{const Z=G&127;if(!Z)throw new q("tlv.decode(long): indefinite length not supported");if(Z>4)throw new q("tlv.decode(long): byte length is too big");const B=J.subarray(Q,Q+Z);if(B.length!==Z)throw new q("tlv.decode: length bytes not complete");if(B[0]===0)throw new q("tlv.decode(long): zero leftmost byte");for(let D of B)U=U<<8|D;if(Q+=Z,U<128)throw new q("tlv.decode(long): not minimal encoding")}const X=J.subarray(Q,Q+U);if(X.length!==U)throw new q("tlv.decode: wrong value length");return{v:X,l:J.subarray(Q+U)}}},_int:{encode($){const{Err:J}=S0;if($<P0)throw new J("integer: negative integers are not allowed");let q=D8($);if(Number.parseInt(q[0],16)&8)q="00"+q;if(q.length&1)throw new J("unexpected DER parsing assertion: unpadded hex");return q},decode($){const{Err:J}=S0;if($[0]&128)throw new J("invalid signature integer: negative");if($[0]===0&&!($[1]&128))throw new J("invalid signature integer: unnecessary leading zero");return k0($)}},toSig($){const{Err:J,_int:q,_tlv:Q}=S0,G=o("signature",$),{v:Y,l:U}=Q.decode(48,G);if(U.length)throw new J("invalid signature: left bytes after parsing");const{v:X,l:Z}=Q.decode(2,Y),{v:B,l:D}=Q.decode(2,Z);if(D.length)throw new J("invalid signature: left bytes after parsing");return{r:q.decode(X),s:q.decode(B)}},hexFromSig($){const{_tlv:J,_int:q}=S0,Q=J.encode(2,q.encode($.r)),G=J.encode(2,q.encode($.s)),Y=Q+G;return J.encode(48,Y)}},P0=BigInt(0),Q8=BigInt(1),JQ=BigInt(2),_8=BigInt(3),jJ=BigInt(4);function UQ($,J){const q=(Q)=>YQ({...$,hash:Q});return{...q(J),create:q}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var NJ=function($){const J=J8.p,q=BigInt(3),Q=BigInt(6),G=BigInt(11),Y=BigInt(22),U=BigInt(23),X=BigInt(44),Z=BigInt(88),B=$*$*$%J,D=B*B*$%J,w=W0(D,q,J)*D%J,j=W0(w,q,J)*D%J,z=W0(j,V$,J)*B%J,L=W0(z,G,J)*z%J,k=W0(L,Y,J)*L%J,S=W0(k,X,J)*k%J,g=W0(S,Z,J)*S%J,s=W0(g,X,J)*k%J,F=W0(s,q,J)*D%J,r=W0(F,U,J)*L%J,J0=W0(r,Q,J)*B%J,q0=W0(J0,V$,J);if(!f8.eql(f8.sqr(q0),$))throw new Error("Cannot find square root");return q0},b8=function($,...J){let q=XQ[$];if(q===void 0){const Q=k8(C8($));q=z0(Q,Q),XQ[$]=q}return k8(z0(q,...J))},N$=function($){const{Fn:J,BASE:q}=q8,Q=y0(J,$),G=q.multiply(Q);return{scalar:O$(G.y)?Q:J.neg(Q),bytes:B$(G)}},KQ=function($){const J=f8;if(!J.isValidNot0($))throw new Error("invalid x: Fail if x \u2265 p");const q=J.create($*$),Q=J.create(q*$+BigInt(7));let G=J.sqrt(Q);if(!O$(G))G=J.neg(G);const Y=q8.fromAffine({x:$,y:G});return Y.assertValidity(),Y},DQ=function(...$){return q8.Fn.create(N8(b8("BIP0340/challenge",...$)))},ZQ=function($){return N$($).bytes},BJ=function($,J,q=c0(32)){const{Fn:Q}=q8,G=o("message",$),{bytes:Y,scalar:U}=N$(J),X=o("auxRand",q,32),Z=Q.toBytes(U^N8(b8("BIP0340/aux",X))),B=b8("BIP0340/nonce",Z,Y,G),{bytes:D,scalar:w}=N$(B),j=DQ(D,Y,G),z=new Uint8Array(64);if(z.set(D,0),z.set(Q.toBytes(Q.create(w+j*U)),32),!WQ(z,G,Y))throw new Error("sign: Invalid signature produced");return z},WQ=function($,J,q){const{Fn:Q,BASE:G}=q8,Y=o("signature",$,64),U=o("message",J),X=o("publicKey",q,32);try{const Z=KQ(N8(X)),B=N8(Y.subarray(0,32));if(!W8(B,jQ,J8.p))return!1;const D=N8(Y.subarray(32,64));if(!W8(D,jQ,J8.n))return!1;const w=DQ(Q.toBytes(B),B$(Z),U),j=G.multiplyUnsafe(D).add(Z.multiplyUnsafe(Q.neg(w))),{x:z,y:L}=j.toAffine();if(j.is0()||!O$(L)||z!==B)return!1;return!0}catch(Z){return!1}};/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var J8={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},MJ={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},VJ=BigInt(0),jQ=BigInt(1),V$=BigInt(2),f8=b0(J8.p,{sqrt:NJ}),zQ=UQ({...J8,Fp:f8,lowS:!0,endo:MJ},k8),XQ={},B$=($)=>$.toBytes(!0).slice(1),q8=(()=>zQ.Point)(),O$=($)=>$%V$===VJ,N8=k0,y8=(()=>{const q=(G=c0(48))=>{return E8(G,J8.n)};zQ.utils.randomSecretKey;function Q(G){const Y=q(G);return{secretKey:Y,publicKey:ZQ(Y)}}return{keygen:Q,getPublicKey:ZQ,sign:BJ,verify:WQ,Point:q8,utils:{randomSecretKey:q,randomPrivateKey:q,taggedHash:b8,lift_x:KQ,pointToBytes:B$,numberToBytesBE:e0,bytesToNumberBE:k0,mod:D0},lengths:{secretKey:32,publicKey:32,publicKeyHasPrefix:!1,signature:64,seed:48}}})();var OJ=new TextEncoder,xJ=new TextDecoder,H0=($)=>OJ.encode($),o0=($)=>xJ.decode($),g8=($)=>Array.from($,(J)=>J.toString(16).padStart(2,"0")).join(""),N0=JSON.stringify,p0=JSON.parse,u8=($,J=Number.MAX_SAFE_INTEGER)=>$.split("").reduce((q,Q)=>q+Q.charCodeAt(0),0)%J;var x$="AES-GCM",RJ={},MQ="$",VQ=",",HJ=($)=>{const J=new Uint8Array($);let Q="";for(let G=0;G<J.length;G+=32768)Q+=String.fromCharCode(...J.subarray(G,G+32768));return btoa(Q)},LJ=($)=>Uint8Array.from(atob($),(J)=>J.charCodeAt(0)).buffer,B8=($)=>RJ[$]??=crypto.subtle.digest("SHA-1",H0($)).then((J)=>{const q=new Uint8Array(J);let Q="";for(let G of q)Q+=G.toString(36);return Q}),NQ=async($,J,q)=>{const Q=await crypto.subtle.digest("SHA-256",H0(`${$}:${J}:${q}`));return crypto.subtle.importKey("raw",Q,{name:x$},!1,["encrypt","decrypt"])},BQ=async($,J)=>{const q=crypto.getRandomValues(new Uint8Array(12)),Q=await $,G=await crypto.subtle.encrypt({name:x$,iv:q},Q,H0(J));return`${q.join(VQ)}${MQ}${HJ(G)}`},OQ=async($,J)=>{const[q,Q]=J.split(MQ);if(!q||!Q)throw new Error("Invalid encrypted payload format");const G=Uint8Array.from(q.split(VQ),Number),Y=await $,U=await crypto.subtle.decrypt({name:x$,iv:G},Y,LJ(Q));return o0(U)};var M0="GenosRTC",G8=($,J)=>Array.from({length:$},J);var O8=($)=>Array.from(crypto.getRandomValues(new Uint8Array($)),(J)=>"0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz"[J%"0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz".length]).join(""),m=O8(20),I0=Promise.all.bind(Promise),xQ=typeof window!=="undefined",{entries:RQ,fromEntries:F8,keys:f1}=Object,HQ=()=>{},x0=($)=>new Error(`GenosRTC: ${$}`),x8=(...$)=>$.join("@"),LQ=($,J)=>{const q=[...$];let Q=q.length;const G=()=>{const Y=Math.sin(J++)*1e4;return Y-Math.floor(Y)};while(Q){const Y=Math.floor(G()*Q--);[q[Q],q[Y]]=[q[Y],q[Q]]}return q};var TJ=5000,TQ="icegatheringstatechange",AQ="offer",AJ="answer",wJ=[...G8(3,($,J)=>`stun:stun${J||""}.l.google.com:19302`),"stun:stun.cloudflare.com:3478"].map(($)=>({urls:$})),m8=($,{rtcConfig:J,rtcPolyfill:q,turnConfig:Q})=>{const G=new(q||RTCPeerConnection)({iceServers:[...wJ,...Q||[]],...J}),Y={};let U=!1,X=!1,Z;const B=(j)=>Object.assign(j,{binaryType:"arraybuffer",bufferedAmountLowThreshold:65535,onmessage:(z)=>Y.data?.(z.data),onopen:()=>Y.connect?.(),onclose:()=>Y.close?.(),onerror:(z)=>!z?.error?.message?.includes("User-Initiated Abort")&&Y.error?.(z)}),D=()=>Promise.race([new Promise((j)=>{const z=()=>{if(G.iceGatheringState==="complete")G.removeEventListener(TQ,z),j()};G.addEventListener(TQ,z),z()}),new Promise((j)=>setTimeout(j,TJ))]).then(()=>({type:G.localDescription.type,sdp:G.localDescription.sdp.replace(/a=ice-options:trickle\s\n/g,"")}));if($?B(Z=G.createDataChannel("data")):G.ondatachannel=({channel:j})=>B(Z=j),G.onnegotiationneeded=async()=>{try{U=!0,await G.setLocalDescription(),Y.signal?.(await D())}catch(j){Y.error?.(j)}finally{U=!1}},G.onconnectionstatechange=()=>{if(["disconnected","failed","closed"].includes(G.connectionState))Y.close?.()},G.ontrack=(j)=>{Y.track?.(j.track,j.streams[0]),Y.stream?.(j.streams[0])},G.onremovestream=(j)=>Y.stream?.(j.stream),$&&!G.canTrickleIceCandidates)G.onnegotiationneeded();const w=()=>G.getSenders();return{created:Date.now(),connection:G,get channel(){return Z},get isDead(){return G.connectionState==="closed"},async signal(j){if(Z?.readyState==="open"&&!j.sdp?.includes("a=rtpmap"))return;try{if(j.type===AQ){if(U||G.signalingState!=="stable"&&!X){if($)return;await I0([G.setLocalDescription({type:"rollback"}),G.setRemoteDescription(j)])}else await G.setRemoteDescription(j);await G.setLocalDescription();const z=await D();return Y.signal?.(z),z}if(j.type===AJ){X=!0;try{await G.setRemoteDescription(j)}finally{X=!1}}}catch(z){Y.error?.(z)}},sendData:(j)=>Z.send(j),destroy:()=>{Z?.close(),G.close(),U=X=!1},setHandlers:(j)=>Object.assign(Y,j),offerPromise:$?new Promise((j)=>Y.signal=(z)=>z.type===AQ&&j(z)):Promise.resolve(),addStream:(j)=>j.getTracks().forEach((z)=>G.addTrack(z,j)),removeStream:(j)=>w().filter((z)=>j.getTracks().includes(z.track)).forEach((z)=>G.removeTrack(z)),addTrack:(j,z)=>G.addTrack(j,z),removeTrack:(j)=>{const z=w().find((L)=>L.track===j);if(z)G.removeTrack(z)},replaceTrack:(j,z)=>w().find((L)=>L.track===j)?.replaceTrack(z)}};var CJ=Object.getPrototypeOf(Uint8Array),c8=12,wQ=0,l8=wQ+c8,d8=l8+1,H8=d8+1,L8=H8+1,R8=16384-L8,h8=255,R$="bufferedamountlow",Y8=($)=>`@_${$}`,H$=100,kJ=3,SJ=200,CQ=($,J,q)=>{const Q=new Map,G=new Map,Y=new Map,U={},X={},Z={},B={},D=new Map,w=(K,W)=>{if(!D.has(K))D.set(K,new Set);D.get(K).add(W)},j=(K,W)=>D.get(K)?.delete(W),z=(K,...W)=>D.get(K)?.forEach((O)=>O(...W)),L=(K,W)=>{const O=K?Array.isArray(K)?K:[K]:Q.keys();return Array.from(O,(H)=>{const x=Q.get(H);if(!x)return console.warn(`${M0}: no peer with id ${H}`),null;return W(H,x)}).filter(Boolean)},k=(K)=>{if(!Q.has(K))return;Q.delete(K),delete U[K],delete X[K],delete Z[K],delete B[K],z("peer:leave",K),J(K)},S=(K)=>new Promise((W,O)=>{let H=setTimeout(()=>{K.removeEventListener(R$,x),O(new Error(`${M0}: bufferLow timeout`))},5000);function x(){clearTimeout(H),K.removeEventListener(R$,x),W()}K.addEventListener(R$,x)}),g=(K)=>{if(Y.has(K))return Y.get(K);if(!K)throw x0("action type is required");const W=H0(K);if(W.byteLength>c8)throw x0(`\u274C "${K}" exceeds ${c8} bytes. Use a shorter name.`);const O=new Uint8Array(c8).map((b,u)=>W[u]||0);let H=0;const x=new Map([["message",new Set],["progress",new Set]]),C=(b,u)=>x.get(b)?.add(u),h=(b,u)=>x.get(b)?.delete(u),f=async(b,u,y,l)=>{if(y&&typeof y!=="object")throw x0("meta must be object");if(b===void 0)throw x0("data cannot be undefined");const d=b instanceof Blob,n=d||b instanceof ArrayBuffer||b instanceof CJ,X0=typeof b!=="string";if(y&&!n)throw x0("meta only allowed with binary");const t=n?new Uint8Array(d?await b.arrayBuffer():b):H0(X0?N0(b):b),e=y?H0(N0(y)):null,i=Math.ceil(t.byteLength/R8)+(y?1:0)||1;if(i>H$)throw x0(`Message too large, exceeds max chunks ${H$}`);const i0=G8(i,(r0,Z0)=>{const g0=Z0===i-1,L0=y&&Z0===0,a0=L0?e:t.subarray(y?(Z0-1)*R8:Z0*R8,y?Z0*R8:(Z0+1)*R8),N=new Uint8Array(L8+a0.byteLength);return N.set(O),N.set([H],l8),N.set([g0|L0<<1|n<<2|X0<<3],d8),N.set([Math.round((Z0+1)/i*h8)],H8),N.set(a0,L8),N});return H=H+1&h8,I0(L(u,async(r0,Z0)=>{const{channel:g0}=Z0;for(let L0=0;L0<i;L0++){let a0=0;while(g0.bufferedAmount>g0.bufferedAmountLowThreshold){if(a0++>kJ)throw x0(`${M0}: send buffer full, max retries reached for peer ${r0}`);try{await S(g0)}catch(N){console.warn(N.message),await new Promise((A)=>setTimeout(A,SJ))}}if(!Q.has(r0))break;Z0.sendData(i0[L0]),l?.(i0[L0][H8]/h8,r0,y)}}))};G.set(K,{listeners:x,send:f});const _={send:f,on:C,off:h};return Y.set(K,_),_},s=(K,W)=>{try{const O=new Uint8Array(W),H=o0(O.subarray(wQ,l8)).replace(/ /g,"");if(!G.has(H))return console.warn(`${M0}: unregistered type (${H})`);const[x]=O.subarray(l8,d8),[C]=O.subarray(d8,H8),[h]=O.subarray(H8,L8),f=O.subarray(L8),_=Boolean(C&1),b=Boolean(C&2),u=Boolean(C&4),y=Boolean(C&8),l=G.get(H),d=(U[K]||={})[H]||={};if(d[x]?.chunks?.length>H$){console.warn(`${M0}: peer ${K} sent too many chunks for nonce ${x}, ignoring.`);return}const n=d[x]||={chunks:[]};if(b)try{n.meta=p0(o0(f))}catch{console.warn(`${M0}: failed to parse meta from peer ${K} for type ${H}`);return}else n.chunks.push(f);if(l.listeners.get("progress").forEach((e)=>{try{e(h/h8,K,n.meta)}catch(i){console.error(i)}}),!_)return;const X0=new Uint8Array(n.chunks.reduce((e,i)=>e+i.byteLength,0));n.chunks.reduce((e,i)=>(X0.set(i,e),e+i.byteLength),0),delete d[x];let t;if(u)t=X0;else if(y)try{t=p0(o0(X0))}catch{console.warn(`${M0}: failed to parse JSON message data from peer ${K} for type ${H}`);return}else t=o0(X0);l.listeners.get("message").forEach((e)=>{try{e(t,K,n.meta)}catch(i){console.error(i)}})}catch(O){console.error(`${M0}: error handling data from peer ${K}:`,O)}},F=async()=>{try{await M(""),await new Promise((K)=>setTimeout(K,99))}catch(K){console.warn(`${M0}: error sending leave`,K)}for(let[K,W]of Q){try{W.destroy()}catch{}Q.delete(K)}q()},{send:r,on:J0}=g(Y8("ping")),{send:q0,on:V0}=g(Y8("pong")),{send:Y0,on:P}=g(Y8("signal")),{send:j0,on:I}=g(Y8("stream")),{send:V,on:T}=g(Y8("track")),{send:M,on:R}=g(Y8("leave"));if($((K,W)=>{if(Q.has(W))return;Q.set(W,K),K.setHandlers({data:(O)=>s(W,O),stream:(O)=>{z("stream:add",O,W,Z[W]),delete Z[W]},track:(O,H)=>{z("track:add",O,H,W,B[W]),delete B[W]},signal:(O)=>Y0(O,W),close:()=>k(W),error:(O)=>{console.error(`${M0}: peer error for ${W}`,O),k(W)}}),z("peer:join",W)}),J0("message",(K,W)=>q0("",W)),V0("message",(K,W)=>{X[W]?.(),delete X[W]}),P("message",(K,W)=>Q.get(W)?.signal(K)),I("message",(K,W)=>Z[W]=K),T("message",(K,W)=>B[W]=K),R("message",(K,W)=>k(W)),xQ)addEventListener("beforeunload",F);return{on:w,off:j,channel:g,leave:F,ping:async(K)=>{if(!K)throw x0("ping() requires target peer ID");const W=Date.now();return r("",K),await new Promise((O)=>X[K]=O),Date.now()-W},getPeers:()=>F8(Array.from(Q,([K,W])=>[K,W.connection])),addStream:(K,W,O)=>L(W,async(H,x)=>{if(O)await j0(O,H);x.addStream(K)}),removeStream:(K,W)=>L(W,(O,H)=>H.removeStream(K)),addTrack:(K,W,O,H)=>L(O,async(x,C)=>{if(H)await V(H,x);C.addTrack(K,W)}),removeTrack:(K,W)=>L(W,(O,H)=>H.removeTrack(K)),replaceTrack:(K,W,O,H)=>L(O,async(x,C)=>{if(H)await V(H,x);C.replaceTrack(K,W)})}};var PJ=20,IJ=5333,kQ=57333,SQ=({init:$,subscribe:J,announce:q})=>{const Q={};let G=!1,Y,U;return(X,Z,B)=>{const{appId:D}=X;if(Q[D]?.[Z])return Q[D][Z];if(!X||!Z||!D&&!X.firebaseApp)throw x0(!X?"config required":!Z?"roomId required":"appId missing");let w=HQ;if(!G){const I=$(X);U=G8(PJ,()=>m8(!0,X)),Y=Array.isArray(I)?I:[I];const V=setInterval(()=>{U=U.filter((T)=>{const M=Date.now()-T.created<kQ;if(!M)T.destroy();return M})},kQ);Q.offerCleanupTimer||=V,G=!0}const j={},z={},L=x8(M0,D,Z),k=B8(L),S=B8(x8(L,m)),g=NQ(X.password||"",D,Z),s=(I)=>async(V)=>({type:V.type,sdp:await I(g,V.sdp)}),F=s(OQ),r=s(BQ),J0=(I,V)=>{if(z[V]===I)return;z[V]?.destroy(),z[V]=I,w(I,V),j[V]?.forEach((T)=>T!==I&&T.destroy()),delete j[V]},q0=(I,V)=>{if(z[V]===I)delete z[V]},V0=(I)=>async(V,T,M)=>{const[R,K]=await I0([k,S]);if(V!==R&&V!==K)return;const{peerId:W,offer:O,answer:H}=typeof T==="string"?p0(T):T;if(W===m||z[W])return;if(O){if(j[W]?.[I]&&m>W)return;const x=m8(!1,X);x.setHandlers({connect:()=>J0(x,W),close:()=>q0(x,W)});try{const C=await F(O);if(x.isDead)return;const[h,f]=await I0([B8(x8(L,W)),x.signal(C).then(r)]);M(h,N0({peerId:m,answer:f}))}catch{B?.({error:"decryption failed (offer)",appId:D,peerId:W,roomId:Z})}}else if(H){const x=j[W]?.[I];if(!x||x.isDead)return;x.setHandlers({connect:()=>J0(x,W),close:()=>q0(x,W)});try{x.signal(await F(H))}catch{B?.({error:"decryption failed (answer)",appId:D,peerId:W,roomId:Z})}}else{if(j[W]?.[I])return;const x=U.pop()||m8(!0,X),[C,{offer:h}]=await I0([B8(x8(L,W)),x.offerPromise.then(r).then((f)=>({offer:f}))]);j[W]||=[],j[W][I]=x,x.setHandlers({connect:()=>J0(x,W),close:()=>q0(x,W)}),M(C,N0({peerId:m,offer:h,peer:x}))}},Y0=I0(Y.map(async(I,V)=>J(await I,await k,await S,V0(V)))),P=[];Y0.then((I)=>{Y.forEach((V,T)=>{const M=async()=>{const R=await q(await V,await k,await S);P[T]=setTimeout(M,typeof R==="number"?R:IJ)};M()}),Q[D][Z].onCleanup=()=>{if(delete Q[D][Z],P.forEach(clearTimeout),I.forEach((V)=>V()),Object.keys(Q).length===0)clearInterval(Q.offerCleanupTimer),delete Q.offerCleanupTimer}}),Q[D]||={};const j0=CQ((I)=>w=I,(I)=>delete z[I],()=>j0.onCleanup?.());return Q[D][Z]=j0}};var PQ=3333,o8={},IQ={},EQ=($,J)=>{const q={};let Q=null;const G=()=>{if(Q)clearTimeout(Q),Q=null;const Y=new WebSocket($);Y.onclose=()=>{o8[$]??=PQ,Q=setTimeout(G,o8[$]),o8[$]*=2},Y.onmessage=(U)=>J(U.data),q.socket=Y,q.url=Y.url,q.ready=new Promise((U)=>{Y.onopen=()=>{o8[$]=PQ,U(q)}}),q.send=(U)=>{if(Y.readyState===1)Y.send(U)}};return q.forceReconnect=G,G(),IQ[$]=q,q};if(typeof window!=="undefined"){const $=()=>{console.info("\u26A1 [GenosRTC] Network event detected. Forcing reconnection\u2026"),Object.values(IQ).forEach((J)=>{if(J.socket&&J.socket.readyState!==WebSocket.OPEN&&J.socket.readyState!==WebSocket.CONNECTING)J.forceReconnect()})};window.addEventListener("online",()=>{console.info("\u2705 Reconnected to the network."),$()}),window.addEventListener("offline",async()=>{console.info("\u274C Disconnected from the network.")}),document.addEventListener("visibilitychange",()=>{if(document.visibilityState==="visible")$()})}var vQ=($)=>()=>F8(RQ($).map(([J,q])=>[J,q.socket])),_Q=($,J,q,Q)=>($.relayUrls??(Q?LQ(J,u8($.appId)):J)).slice(0,$.relayUrls?.length??$.relayRedundancy??q);var U8={},EJ=5,gQ="x",uQ="EVENT",vJ=/pow:\s*(\d+)\s*bits needed\.?/i,L$=new Set,FQ=y8.utils.randomSecretKey(),_J=g8(y8.getPublicKey(FQ)),T$={},T8={},fJ={},mQ=()=>Math.floor(Date.now()/1000),hQ=($)=>fJ[$]??=u8($,1e4)+20000,p8=($)=>$.replace(/\/$/,""),bJ=["wss://black.nostrcity.club","wss://eu.purplerelay.com","wss://ftp.halifax.rwth-aachen.de/nostr","wss://nostr.data.haus","wss://nostr.mom","wss://nostr.oxtr.dev","wss://nostr.sathoarder.com","wss://nostr.vulpem.com","wss://relay.agorist.space","wss://relay.binaryrobot.com","wss://relay.fountain.fm","wss://relay.mostro.network","wss://relay.nostrdice.com","wss://relay.nostromo.social","wss://sendit.nosflare.com","wss://yabu.me/v2","wss://relay.damus.io"],yJ=($,J)=>{const[q,Q,G,Y]=p0(J);if(q===uQ)return T8[Q]?.(T$[Q],G.content);if(q==="NOTICE"||q==="OK"&&!G){if(+((q==="NOTICE"?Q:Y).match(vJ)?.[1]??0)>0){const X=p8($);L$.add(X),U8[X]?.close?.(),delete U8[X]}}},gJ=($)=>{const J=p8($);if(U8[J])return U8[J];const q=EQ(J,(Q)=>yJ(J,Q));return U8[J]=q},fQ=async($,J)=>{const q={kind:hQ($),content:J,pubkey:_J,created_at:mQ(),tags:[[gQ,$]]},Q=H0(N0([0,q.pubkey,q.created_at,q.kind,q.tags,q.content])),G=new Uint8Array(await crypto.subtle.digest("SHA-256",Q)),Y=y8.sign(G,FQ);return N0([uQ,{...q,id:g8(G),sig:g8(Y)}])},bQ=($,J)=>{return T$[$]=J,N0(["REQ",$,{kinds:[hQ(J)],since:mQ(),["#"+gQ]:[J]}])},yQ=($)=>{return delete T$[$],N0(["CLOSE",$])},cQ=SQ({init:($)=>{const q=($?.relayUrls?.length?$.relayUrls:null)??bJ;return _Q($,q,EJ,!0).map(gJ).map((G)=>G.ready.then(()=>G).catch(()=>null))},subscribe:($,J,q,Q)=>{const G=O8(64),Y=O8(64);return T8[G]=T8[Y]=(U,X)=>Q(U,X,async(Z,B)=>{if(L$.has(p8($.url)))return;$.send(await fQ(Z,B))}),$.send(bQ(G,J)),$.send(bQ(Y,q)),()=>{$.send(yQ(G)),$.send(yQ(Y)),delete T8[G],delete T8[Y]}},announce:async($,J)=>{if(L$.has(p8($.url)))return;$.send(await fQ(J,N0({peerId:m})))}}),uJ=vQ(U8);var oJ=function($,J={}){const q={...FJ,...J},Q=!!q.debug,G=(...N)=>Q&&console.debug("[cells]",...N),Y=Math.max(0,q.bridgesPerEdge|0),U=Math.max(5,q.maxCellSize|0),X=Math.max(10,q.targetCells|0),Z=q.cellSize==="auto";let B=Z?2:Math.max(1,q.cellSize|0),D={cellId:null,bridges:[],isBridge:!1},w=0,j=null,z=null,L=null;const k=new Map,S=new Map,g=new Set,s=new Map,F=new Set,r=new Set;let J0=0;const q0=[],V0=new Map,Y0=new Set,P=new Map,j0=new Map,I=()=>{const N=Math.ceil(y().length/B);return Math.min(150,N+3)},V=$.on?.bind($),T=$.off?.bind($);if(V)$.on=(N,A)=>String(N).startsWith("mesh:")?K(N,A):V(N,A);if(T)$.off=(N,A)=>String(N).startsWith("mesh:")?s.get(N)?.delete(A):T(N,A);const M=(N)=>(g.add(N),()=>g.delete(N)),R=(N,A,E)=>{if(r.has(E))return;if(r.add(E),r.size>lQ){const v=r.values().next().value;r.delete(v)}for(let v of g)try{v(N,A)}catch(c){G("Error in deliver handler:",c)}},K=(N,A)=>{if(!s.has(N))s.set(N,new Set);return s.get(N).add(A),()=>s.get(N)?.delete(A)},W=(N,...A)=>{const E=s.get(N);if(E)for(let v of E)try{v(...A)}catch{}},O=(N)=>{try{return typeof N==="string"?JSON.parse(N):N}catch{return null}},H=()=>`${m}:${Date.now().toString(36)}:${(J0++&65535).toString(36)}`,x=()=>{if(F.size>lQ)F.delete(F.values().next().value)},C=(N,A,E=[])=>{if(!N||!A)return;if(k.set(N,{cell:A,isBridge:E.length>0,bridges:[...E]}),!S.has(N))S.set(N,new r8(N));const v=S.get(N);if(v.markSeen(),v.addConnectedCell(A),j0.set(A,{lastSeen:Date.now(),peerId:N}),E.length>0)for(let c of j8(A))v.addConnectedCell(c)},h=(N)=>S.get(N),f=(N,A)=>{const E=S.get(N);if(E)E.addRttSample(A)},_=(N)=>{const A=t(N);if(A.length===0)return null;let E=0,v=0;for(let $0 of A){const Q0=S.get($0);if(Q0&&!Q0.isStale){if(E+=Q0.healthScore,Q0.isResponsive)v++}}const c=A.filter(($0)=>{const Q0=S.get($0);return Q0&&!Q0.isStale});return{cellId:N,memberCount:c.length,avgHealth:c.length>0?E/c.length:0,responsiveRatio:c.length>0?v/c.length:0}},b=()=>{const N=_(D.cellId);W("mesh:health",{...D,health:N})},u=()=>{const N=Object.keys($.getPeers?.()||{}),A=[...N,m].sort();return{peers:N,all:A}},y=()=>{const{all:N}=u();return N.filter((A)=>{if(A===m)return!0;const E=S.get(A);return E&&!E.isStale})},l=()=>{if(!Z)return;const N=y().length,A=dJ(N,X,U);if(A!==B)G("cellSize changed:",B,"->",A),B=A},d=(N,A)=>{if(Y===0)return[];const E=a8(N),v=a8(A);if(E==null||v==null)return[];const c=y(),$0=Math.min(E,v)*B,Q0=(Math.max(E,v)+1)*B,a=c.slice($0,Q0);if(!a.length)return[];const n0=new Set(t(N)),n8=new Set(t(A)),R0=a.filter((K0)=>{if(K0===m)return!0;const T0=S.get(K0);if(!T0||T0.isStale)return!1;const p=n0.has(K0)||T0.connectedCells.has(N),E0=n8.has(K0)||T0.connectedCells.has(A);return p||E0});if(!R0.length)R0.push(...a);const s0=R0.map((K0)=>({id:K0,score:S.get(K0)?.healthScore||0.5}));return s0.sort((K0,T0)=>{const p=T0.score-K0.score;return p!==0?p:K0.id.localeCompare(T0.id)}),s0.slice(0,Y).map((K0)=>K0.id)},n=(N,A)=>{if(Y===0)return[];const E=j8(A),v=[];for(let c of E)if(d(A,c).includes(N))v.push(c);return v},X0=()=>{l();const N=y(),A=N.indexOf(m),v=`cell-${Math.max(0,Math.floor(A/B))}`,c=n(m,v),$0=c.length>0,Q0=Math.ceil(N.length/B)||1;return G("computeState",{self:m,myCell:v,isBridge:$0,bridgeEdges:c,cellSize:B,rosterSize:N.length,totalCells:Q0,dynamicTTL:I()}),{cellId:v,isBridge:$0,bridges:c,cellSize:B,dynamicTTL:I(),totalCells:Q0}},t=(N)=>{const A=[],E=new Set(Object.keys($.getPeers?.()||{}));for(let[v,c]of k)if(c.cell===N){const $0=S.get(v);if(E.has(v)&&(!$0||!$0.isStale))A.push(v)}return A.sort(),A},e=()=>{if(!j)return;const N={t:"state",id:H(),ttl:I(),data:{id:m,cell:D.cellId,bridges:D.bridges,health:S.get(m)?.healthScore||0.5,timestamp:Date.now()},origin:m,originCell:D.cellId},A=JSON.stringify(N);j.send(A),i(z,A)},i=(N,A)=>{const E=O(A);if(!E?.id||!E?.t)return;const v=F.has(E.id);if(!v)F.add(E.id),x();const{t:c,id:$0,ttl:Q0,data:a,origin:n0,originCell:n8}=E,R0=D.cellId;if(c==="state"&&a)C(a.id,a.cell,a.bridges),W("mesh:peer-state",a);if(c==="ping"&&a?.pingId&&n0!==m){const p={t:"pong",id:H(),ttl:I(),data:{pingId:a.pingId,receivedAt:Date.now()},origin:m,originCell:R0};j?.send(JSON.stringify(p))}if(c==="pong"&&a?.pingId){const p=P.get(a.pingId);if(p){clearTimeout(p.timeout);const E0=Date.now()-p.start;f(p.peerId,E0),p.resolve(E0),P.delete(a.pingId)}}if(c==="msg"&&n0!==m)R(a,n0,$0);if(v)return;if(!D.isBridge)return;if((Q0??0)<=0)return;const s0=(p,E0,dQ=null)=>{if(!p)return;const oQ={t:c,id:$0,ttl:dQ??(Q0??I())-1,data:a,origin:n0||m,originCell:n8||R0},A$=JSON.stringify(oQ);if(E0?.length){const pQ=new Set(Object.keys($.getPeers?.()||{})),w$=E0.filter((iQ)=>pQ.has(iQ));if(w$.length>0)p.send(A$,w$)}else p.send(A$)};if(N===z){for(let p of j8(R0))s0(i0(p),null);return}if(!j8(R0).map(i8).includes(N))return;const T0=t(R0);s0(j,T0);for(let p of j8(R0))if(i8(p)!==N)s0(i0(p),null)},i0=(N)=>{const A=i8(N);if(V0.has(N))return V0.get(N);const E=$.channel(A);if(V0.set(N,E),!Y0.has(A))Y0.add(A),setTimeout(()=>{E.on("message",(v)=>i(A,v))},0);return E},r0=()=>{if(!D.cellId)return;if(z=i8(D.cellId),j=$.channel(z),!Y0.has(z))Y0.add(z),j.on("message",(N)=>i(z,N));if(w=Date.now()+mJ,D.isBridge)for(let N of j8(D.cellId))i0(N);if(q0.length){const N=t(D.cellId);for(let A of q0.splice(0)){const E={t:"msg",id:H(),ttl:I(),data:A,origin:m,originCell:D.cellId},v=JSON.stringify(E);N.length?j.send(v,N):j.send(v),i(z,v)}}e()},Z0=()=>{const N=X0(),A=!D.cellId||D.cellId!==N.cellId||D.isBridge!==N.isBridge||JSON.stringify(D.bridges)!==JSON.stringify(N.bridges);if(D=N,C(m,N.cellId,N.bridges),A)r0();else e();W("mesh:state",N),b()},g0=()=>{if(L)return;L=setInterval(()=>{e();for(let[N,A]of S)if(N!==m&&A.isStale)k.delete(N),S.delete(N)},lJ)},L0=()=>{if(L)clearInterval(L),L=null},a0=(N)=>{return new Promise((A,E)=>{const v=`${Date.now()}-${Math.random().toString(36).slice(2,8)}`,c=Date.now(),$0=setTimeout(()=>{P.delete(v);const a=S.get(N);if(a)a.markUnresponsive();E(new Error("Ping timeout"))},hJ);P.set(v,{start:c,resolve:A,reject:E,timeout:$0,peerId:N});const Q0={t:"ping",id:H(),ttl:I(),data:{pingId:v,target:N},origin:m,originCell:D.cellId};j?.send(JSON.stringify(Q0))})};if($.on?.("peer:join",(N)=>{if(!S.has(N))S.set(N,new r8(N));else S.get(N).markReconnect();Z0()}),$.on?.("peer:leave",(N)=>{k.delete(N),Z0()}),!S.has(m))S.set(m,new r8(m));return S.get(m).addConnectedCell(D.cellId||"cell-0"),Z0(),g0(),{send:(N)=>{if(!D.cellId||!j)return q0.push(N);const A=t(D.cellId),E={t:"msg",id:H(),ttl:I(),data:N,origin:m,originCell:D.cellId},v=JSON.stringify(E);A.length?j.send(v,A):j.send(v),i(z,v)},on:(N,A)=>N==="message"?M(A):void 0,ping:a0,getState:()=>({...D,cellSize:B,health:_(D.cellId),dynamicTTL:I(),totalCells:Math.ceil(y().length/B),knownCells:j0.size}),getMetrics:h,getCellHealth:_,getPeerInfo:()=>new Map(k),getStableRoster:()=>y(),getKnownCells:()=>new Map(j0),getCellSize:()=>B,destroy:()=>{L0(),P.forEach((N)=>clearTimeout(N.timeout)),P.clear(),r.clear(),j0.clear()}}},q9=function($,J,q){const Q=cQ($,J,q),G=$.overlay||{},Y=oJ(Q,G),U=new Map;return{on:(X,Z)=>Q.on(X,Z),off:(X,Z)=>Q.off?.(X,Z),channel:(X)=>{if(U.has(X))return U.get(X);const Z=Q.channel(X),B={send:(D,w)=>{Y.send({_ch:X,_d:D,_t:w})},on:(D,w)=>{if(D==="message")Y.on("message",(j,z)=>{if(j?._ch===X)w(j._d,z)}),Z.on(D,w);else Z.on(D,w)},off:(D,w)=>Z.off?.(D,w),_original:Z};return U.set(X,B),B},get id(){return Q.id},get peers(){return Q.peers},getPeers:()=>Q.getPeers?.()||{},mesh:Y,_room:Q,getState:()=>Y.getState(),getMetrics:(X)=>Y.getMetrics(X),getCellHealth:(X)=>Y.getCellHealth(X),getPeerInfo:()=>Y.getPeerInfo(),ping:(X)=>Y.ping(X),destroy:()=>{Y.destroy(),U.clear()}}},FJ={cellSize:"auto",bridgesPerEdge:2,maxCellSize:50,targetCells:100,debug:!1},lQ=5000,mJ=1500,hJ=3000,cJ=30000,lJ=5000,a8=($)=>{const J=String($||"").match(/cell-(\d+)/);return J?Number(J[1]):null},j8=($)=>{const J=a8($);if(J==null)return[];const q=[];if(J>0)q.push(`cell-${J-1}`);return q.push(`cell-${J+1}`),q},i8=($)=>`c${(a8($)||0).toString(36)}`,dJ=($,J,q)=>{if($<10)return 2;const Q=Math.ceil($/J);return Math.max(2,Math.min(q,Q))};class r8{constructor($){this.peerId=$,this.joinedAt=Date.now(),this.lastSeen=Date.now(),this.rttSamples=[],this.stability=1,this.reconnects=0,this.isResponsive=!0,this.connectedCells=new Set}get uptime(){return Date.now()-this.joinedAt}get avgRtt(){if(this.rttSamples.length===0)return Infinity;return Math.round(this.rttSamples.reduce(($,J)=>$+J,0)/this.rttSamples.length)}get healthScore(){const $=this.avgRtt===Infinity?0.5:Math.max(0,100-this.avgRtt)/100,J=Math.min(1,this.uptime/60000),q=this.stability,Q=this.isResponsive?1:0.3;return $*0.25+J*0.25+q*0.3+Q*0.2}get isStale(){return Date.now()-this.lastSeen>cJ}addRttSample($){if(this.rttSamples.push($),this.rttSamples.length>10)this.rttSamples.shift();this.lastSeen=Date.now(),this.isResponsive=!0}markReconnect(){this.reconnects++,this.stability=Math.max(0,1-this.reconnects*0.1)}markUnresponsive(){this.isResponsive=!1}markSeen(){this.lastSeen=Date.now()}addConnectedCell($){if($)this.connectedCells.add($)}}export{m as selfId,q9 as join,uJ as getRelaySockets,FJ as OVERLAY_DEFAULTS};
