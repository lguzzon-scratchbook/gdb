var F0=typeof globalThis==="object"&&("crypto"in globalThis)?globalThis.crypto:void 0;function m0($){return $ instanceof Uint8Array||ArrayBuffer.isView($)&&$.constructor.name==="Uint8Array"}function Z8($){if(!Number.isSafeInteger($)||$<0)throw new Error("positive integer expected, got "+$)}function O0($,...J){if(!m0($))throw new Error("Uint8Array expected");if(J.length>0&&!J.includes($.length))throw new Error("Uint8Array expected of length "+J+", got length="+$.length)}function k8($){if(typeof $!=="function"||typeof $.create!=="function")throw new Error("Hash should be wrapped by utils.createHasher");Z8($.outputLen),Z8($.blockLen)}function e0($,J=!0){if($.destroyed)throw new Error("Hash instance has been destroyed");if(J&&$.finished)throw new Error("Hash#digest() has already been called")}function P$($,J){O0($);const q=J.outputLen;if($.length<q)throw new Error("digestInto() expects output buffer of length at least "+q)}function h0(...$){for(let J=0;J<$.length;J++)$[J].fill(0)}function C8($){return new DataView($.buffer,$.byteOffset,$.byteLength)}function R0($,J){return $<<32-J|$>>>J}function C0($){if(O0($),I$)return $.toHex();let J="";for(let q=0;q<$.length;q++)J+=sQ[$[q]];return J}var S$=function($){if($>=k0._0&&$<=k0._9)return $-k0._0;if($>=k0.A&&$<=k0.F)return $-(k0.A-10);if($>=k0.a&&$<=k0.f)return $-(k0.a-10);return};function c0($){if(typeof $!=="string")throw new Error("hex string expected, got "+typeof $);if(I$)return Uint8Array.fromHex($);const J=$.length,q=J/2;if(J%2)throw new Error("hex string expected, got unpadded hex of length "+J);const Q=new Uint8Array(q);for(let G=0,U=0;G<q;G++,U+=2){const Y=S$($.charCodeAt(U)),X=S$($.charCodeAt(U+1));if(Y===void 0||X===void 0){const Z=$[U]+$[U+1];throw new Error('hex string expected, got non-hex character "'+Z+'" at index '+U)}Q[G]=Y*16+X}return Q}function S8($){if(typeof $!=="string")throw new Error("string expected");return new Uint8Array((new TextEncoder()).encode($))}function z8($){if(typeof $==="string")$=S8($);return O0($),$}function z0(...$){let J=0;for(let Q=0;Q<$.length;Q++){const G=$[Q];O0(G),J+=G.length}const q=new Uint8Array(J);for(let Q=0,G=0;Q<$.length;Q++){const U=$[Q];q.set(U,G),G+=U.length}return q}function E$($){const J=(Q)=>$().update(z8(Q)).digest(),q=$();return J.outputLen=q.outputLen,J.blockLen=q.blockLen,J.create=()=>$(),J}function d0($=32){if(F0&&typeof F0.getRandomValues==="function")return F0.getRandomValues(new Uint8Array($));if(F0&&typeof F0.randomBytes==="function")return Uint8Array.from(F0.randomBytes($));throw new Error("crypto.getRandomValues must be defined")}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */var I$=(()=>typeof Uint8Array.from([]).toHex==="function"&&typeof Uint8Array.fromHex==="function")(),sQ=Array.from({length:256},($,J)=>J.toString(16).padStart(2,"0")),k0={_0:48,_9:57,A:65,F:70,a:97,f:102};class K8{}function tQ($,J,q,Q){if(typeof $.setBigUint64==="function")return $.setBigUint64(J,q,Q);const G=BigInt(32),U=BigInt(4294967295),Y=Number(q>>G&U),X=Number(q&U),Z=Q?4:0,N=Q?0:4;$.setUint32(J+Z,Y,Q),$.setUint32(J+N,X,Q)}function v$($,J,q){return $&J^~$&q}function _$($,J,q){return $&J^$&q^J&q}class e8 extends K8{constructor($,J,q,Q){super();this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=$,this.outputLen=J,this.padOffset=q,this.isLE=Q,this.buffer=new Uint8Array($),this.view=C8(this.buffer)}update($){e0(this),$=z8($),O0($);const{view:J,buffer:q,blockLen:Q}=this,G=$.length;for(let U=0;U<G;){const Y=Math.min(Q-this.pos,G-U);if(Y===Q){const X=C8($);for(;Q<=G-U;U+=Q)this.process(X,U);continue}if(q.set($.subarray(U,U+Y),this.pos),this.pos+=Y,U+=Y,this.pos===Q)this.process(J,0),this.pos=0}return this.length+=$.length,this.roundClean(),this}digestInto($){e0(this),P$($,this),this.finished=!0;const{buffer:J,view:q,blockLen:Q,isLE:G}=this;let{pos:U}=this;if(J[U++]=128,h0(this.buffer.subarray(U)),this.padOffset>Q-U)this.process(q,0),U=0;for(let z=U;z<Q;z++)J[z]=0;tQ(q,Q-8,BigInt(this.length*8),G),this.process(q,0);const Y=C8($),X=this.outputLen;if(X%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const Z=X/4,N=this.get();if(Z>N.length)throw new Error("_sha2: outputLen bigger than state");for(let z=0;z<Z;z++)Y.setUint32(4*z,N[z],G)}digest(){const{buffer:$,outputLen:J}=this;this.digestInto($);const q=$.slice(0,J);return this.destroy(),q}_cloneInto($){$||($=new this.constructor),$.set(...this.get());const{blockLen:J,buffer:q,length:Q,finished:G,destroyed:U,pos:Y}=this;if($.destroyed=U,$.finished=G,$.length=Q,$.pos=Y,Q%J)$.buffer.set(q);return $}clone(){return this._cloneInto()}}var S0=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]);var eQ=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),f0=new Uint32Array(64);class f$ extends e8{constructor($=32){super(64,$,8,!1);this.A=S0[0]|0,this.B=S0[1]|0,this.C=S0[2]|0,this.D=S0[3]|0,this.E=S0[4]|0,this.F=S0[5]|0,this.G=S0[6]|0,this.H=S0[7]|0}get(){const{A:$,B:J,C:q,D:Q,E:G,F:U,G:Y,H:X}=this;return[$,J,q,Q,G,U,Y,X]}set($,J,q,Q,G,U,Y,X){this.A=$|0,this.B=J|0,this.C=q|0,this.D=Q|0,this.E=G|0,this.F=U|0,this.G=Y|0,this.H=X|0}process($,J){for(let z=0;z<16;z++,J+=4)f0[z]=$.getUint32(J,!1);for(let z=16;z<64;z++){const A=f0[z-15],j=f0[z-2],D=R0(A,7)^R0(A,18)^A>>>3,L=R0(j,17)^R0(j,19)^j>>>10;f0[z]=L+f0[z-7]+D+f0[z-16]|0}let{A:q,B:Q,C:G,D:U,E:Y,F:X,G:Z,H:N}=this;for(let z=0;z<64;z++){const A=R0(Y,6)^R0(Y,11)^R0(Y,25),j=N+A+v$(Y,X,Z)+eQ[z]+f0[z]|0,L=(R0(q,2)^R0(q,13)^R0(q,22))+_$(q,Q,G)|0;N=Z,Z=X,X=Y,Y=U+j|0,U=G,G=Q,Q=q,q=j+L|0}q=q+this.A|0,Q=Q+this.B|0,G=G+this.C|0,U=U+this.D|0,Y=Y+this.E|0,X=X+this.F|0,Z=Z+this.G|0,N=N+this.H|0,this.set(q,Q,G,U,Y,X,Z,N)}roundClean(){h0(f0)}destroy(){this.set(0,0,0,0,0,0,0,0),h0(this.buffer)}}var P8=E$(()=>new f$);class $$ extends K8{constructor($,J){super();this.finished=!1,this.destroyed=!1,k8($);const q=z8(J);if(this.iHash=$.create(),typeof this.iHash.update!=="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const Q=this.blockLen,G=new Uint8Array(Q);G.set(q.length>Q?$.create().update(q).digest():q);for(let U=0;U<G.length;U++)G[U]^=54;this.iHash.update(G),this.oHash=$.create();for(let U=0;U<G.length;U++)G[U]^=54^92;this.oHash.update(G),h0(G)}update($){return e0(this),this.iHash.update($),this}digestInto($){e0(this),O0($,this.outputLen),this.finished=!0,this.iHash.digestInto($),this.oHash.update($),this.oHash.digestInto($),this.destroy()}digest(){const $=new Uint8Array(this.oHash.outputLen);return this.digestInto($),$}_cloneInto($){$||($=Object.create(Object.getPrototypeOf(this),{}));const{oHash:J,iHash:q,finished:Q,destroyed:G,blockLen:U,outputLen:Y}=this;return $=$,$.finished=Q,$.destroyed=G,$.blockLen=U,$.outputLen=Y,$.oHash=J._cloneInto($.oHash),$.iHash=q._cloneInto($.iHash),$}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}var Q$=($,J,q)=>new $$($,J).update(q).digest();Q$.create=($,J)=>new $$($,J);function D8($,J=""){if(typeof $!=="boolean"){const q=J&&`"${J}"`;throw new Error(q+"expected boolean, got type="+typeof $)}return $}function b0($,J,q=""){const Q=m0($),G=$?.length,U=J!==void 0;if(!Q||U&&G!==J){const Y=q&&`"${q}" `,X=U?` of length ${J}`:"",Z=Q?`length=${G}`:`type=${typeof $}`;throw new Error(Y+"expected Uint8Array"+X+", got "+Z)}return $}function W8($){const J=$.toString(16);return J.length&1?"0"+J:J}function b$($){if(typeof $!=="string")throw new Error("hex string expected, got "+typeof $);return $===""?G$:BigInt("0x"+$)}function P0($){return b$(C0($))}function U$($){return O0($),b$(C0(Uint8Array.from($).reverse()))}function $8($,J){return c0($.toString(16).padStart(J*2,"0"))}function Y$($,J){return $8($,J).reverse()}function p($,J,q){let Q;if(typeof J==="string")try{Q=c0(J)}catch(U){throw new Error($+" must be hex string or Uint8Array, cause: "+U)}else if(m0(J))Q=Uint8Array.from(J);else throw new Error($+" must be hex string or Uint8Array");const G=Q.length;if(typeof q==="number"&&G!==q)throw new Error($+" of length "+q+" expected, got "+G);return Q}function M8($,J,q){return J$($)&&J$(J)&&J$(q)&&J<=$&&$<q}function y$($,J,q,Q){if(!M8(J,q,Q))throw new Error("expected valid "+$+": "+q+" <= n < "+Q+", got "+J)}function I8($){let J;for(J=0;$>G$;$>>=q$,J+=1);return J}function u$($,J,q){if(typeof $!=="number"||$<2)throw new Error("hashLen must be a number");if(typeof J!=="number"||J<2)throw new Error("qByteLen must be a number");if(typeof q!=="function")throw new Error("hmacFn must be a function");const Q=(D)=>new Uint8Array(D),G=(D)=>Uint8Array.of(D);let U=Q($),Y=Q($),X=0;const Z=()=>{U.fill(1),Y.fill(0),X=0},N=(...D)=>q(Y,U,...D),z=(D=Q(0))=>{if(Y=N(G(0),D),U=N(),D.length===0)return;Y=N(G(1),D),U=N()},A=()=>{if(X++>=1000)throw new Error("drbg: tried 1000 values");let D=0;const L=[];while(D<J){U=N();const w=U.slice();L.push(w),D+=U.length}return z0(...L)};return(D,L)=>{Z(),z(D);let w=void 0;while(!(w=L(A())))z();return Z(),w}}function V8($,J,q={}){if(!$||typeof $!=="object")throw new Error("expected valid options object");function Q(G,U,Y){const X=$[G];if(Y&&X===void 0)return;const Z=typeof X;if(Z!==U||X===null)throw new Error(`param "${G}" is invalid: expected ${U}, got ${Z}`)}Object.entries(J).forEach(([G,U])=>Q(G,U,!1)),Object.entries(q).forEach(([G,U])=>Q(G,U,!0))}function j$($){const J=new WeakMap;return(q,...Q)=>{const G=J.get(q);if(G!==void 0)return G;const U=$(q,...Q);return J.set(q,U),U}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var G$=BigInt(0),q$=BigInt(1),J$=($)=>typeof $==="bigint"&&G$<=$,y0=($)=>(q$<<BigInt($))-q$;function W0($,J){const q=$%J;return q>=U0?q:J+q}function M0($,J,q){let Q=$;while(J-- >U0)Q*=Q,Q%=q;return Q}function g$($,J){if($===U0)throw new Error("invert: expected non-zero number");if(J<=U0)throw new Error("invert: expected positive modulus, got "+J);let q=W0($,J),Q=J,G=U0,U=G0,Y=G0,X=U0;while(q!==U0){const N=Q/q,z=Q%q,A=G-Y*N,j=U-X*N;Q=q,q=z,G=Y,U=X,Y=A,X=j}if(Q!==G0)throw new Error("invert: does not exist");return W0(G,J)}var X$=function($,J,q){if(!$.eql($.sqr(J),q))throw new Error("Cannot find square root")},o$=function($,J){const q=($.ORDER+G0)/h$,Q=$.pow(J,q);return X$($,Q,J),Q},JJ=function($,J){const q=($.ORDER-c$)/d$,Q=$.mul(J,l0),G=$.pow(Q,q),U=$.mul(J,G),Y=$.mul($.mul(U,l0),G),X=$.mul(U,$.sub(Y,$.ONE));return X$($,X,J),X},qJ=function($){const J=u0($),q=p$($),Q=q(J,J.neg(J.ONE)),G=q(J,Q),U=q(J,J.neg(Q)),Y=($+$J)/l$;return(X,Z)=>{let N=X.pow(Z,Y),z=X.mul(N,Q);const A=X.mul(N,G),j=X.mul(N,U),D=X.eql(X.sqr(z),Z),L=X.eql(X.sqr(A),Z);N=X.cmov(N,z,D),z=X.cmov(j,A,L);const w=X.eql(X.sqr(z),Z),y=X.cmov(N,z,w);return X$(X,y,Z),y}};function p$($){if($<m$)throw new Error("sqrt is not defined for small field");let J=$-G0,q=0;while(J%l0===U0)J/=l0,q++;let Q=l0;const G=u0($);while(F$(G,Q)===1)if(Q++>1000)throw new Error("Cannot find square root: probably non-prime P");if(q===1)return o$;let U=G.pow(Q,J);const Y=(J+G0)/l0;return function X(Z,N){if(Z.is0(N))return N;if(F$(Z,N)!==1)throw new Error("Cannot find square root");let z=q,A=Z.mul(Z.ONE,U),j=Z.pow(N,J),D=Z.pow(N,Y);while(!Z.eql(j,Z.ONE)){if(Z.is0(j))return Z.ZERO;let L=1,w=Z.sqr(j);while(!Z.eql(w,Z.ONE))if(L++,w=Z.sqr(w),L===z)throw new Error("Cannot find square root");const y=G0<<BigInt(z-L-1),b=Z.pow(A,y);z=L,A=Z.sqr(b),j=Z.mul(j,A),D=Z.mul(D,b)}return D}}function GJ($){if($%h$===m$)return o$;if($%d$===c$)return JJ;if($%l$===QJ)return qJ($);return p$($)}function Z$($){const J={ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"},q=UJ.reduce((Q,G)=>{return Q[G]="function",Q},J);return V8($,q),$}function YJ($,J,q){if(q<U0)throw new Error("invalid exponent, negatives unsupported");if(q===U0)return $.ONE;if(q===G0)return J;let Q=$.ONE,G=J;while(q>U0){if(q&G0)Q=$.mul(Q,G);G=$.sqr(G),q>>=G0}return Q}function E8($,J,q=!1){const Q=new Array(J.length).fill(q?$.ZERO:void 0),G=J.reduce((Y,X,Z)=>{if($.is0(X))return Y;return Q[Z]=Y,$.mul(Y,X)},$.ONE),U=$.inv(G);return J.reduceRight((Y,X,Z)=>{if($.is0(X))return Y;return Q[Z]=$.mul(Y,Q[Z]),$.mul(Y,X)},U),Q}function F$($,J){const q=($.ORDER-G0)/l0,Q=$.pow(J,q),G=$.eql(Q,$.ONE),U=$.eql(Q,$.ZERO),Y=$.eql(Q,$.neg($.ONE));if(!G&&!U&&!Y)throw new Error("invalid Legendre symbol result");return G?1:U?0:-1}function v8($,J){if(J!==void 0)Z8(J);const q=J!==void 0?J:$.toString(2).length,Q=Math.ceil(q/8);return{nBitLength:q,nByteLength:Q}}function u0($,J,q=!1,Q={}){if($<=U0)throw new Error("invalid field: expected ORDER > 0, got "+$);let G=void 0,U=void 0,Y=!1,X=void 0;if(typeof J==="object"&&J!=null){if(Q.sqrt||q)throw new Error("cannot specify opts in two arguments");const j=J;if(j.BITS)G=j.BITS;if(j.sqrt)U=j.sqrt;if(typeof j.isLE==="boolean")q=j.isLE;if(typeof j.modFromBytes==="boolean")Y=j.modFromBytes;X=j.allowedLengths}else{if(typeof J==="number")G=J;if(Q.sqrt)U=Q.sqrt}const{nBitLength:Z,nByteLength:N}=v8($,G);if(N>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let z;const A=Object.freeze({ORDER:$,isLE:q,BITS:Z,BYTES:N,MASK:y0(Z),ZERO:U0,ONE:G0,allowedLengths:X,create:(j)=>W0(j,$),isValid:(j)=>{if(typeof j!=="bigint")throw new Error("invalid field element: expected bigint, got "+typeof j);return U0<=j&&j<$},is0:(j)=>j===U0,isValidNot0:(j)=>!A.is0(j)&&A.isValid(j),isOdd:(j)=>(j&G0)===G0,neg:(j)=>W0(-j,$),eql:(j,D)=>j===D,sqr:(j)=>W0(j*j,$),add:(j,D)=>W0(j+D,$),sub:(j,D)=>W0(j-D,$),mul:(j,D)=>W0(j*D,$),pow:(j,D)=>YJ(A,j,D),div:(j,D)=>W0(j*g$(D,$),$),sqrN:(j)=>j*j,addN:(j,D)=>j+D,subN:(j,D)=>j-D,mulN:(j,D)=>j*D,inv:(j)=>g$(j,$),sqrt:U||((j)=>{if(!z)z=GJ($);return z(A,j)}),toBytes:(j)=>q?Y$(j,N):$8(j,N),fromBytes:(j,D=!0)=>{if(X){if(!X.includes(j.length)||j.length>N)throw new Error("Field.fromBytes: expected "+X+" bytes, got "+j.length);const w=new Uint8Array(N);w.set(j,q?0:w.length-j.length),j=w}if(j.length!==N)throw new Error("Field.fromBytes: expected "+N+" bytes, got "+j.length);let L=q?U$(j):P0(j);if(Y)L=W0(L,$);if(!D){if(!A.isValid(L))throw new Error("invalid field element: outside of range 0..ORDER")}return L},invertBatch:(j)=>E8(A,j),cmov:(j,D,L)=>L?D:j});return Object.freeze(A)}function i$($){if(typeof $!=="bigint")throw new Error("field order must be bigint");const J=$.toString(2).length;return Math.ceil(J/8)}function z$($){const J=i$($);return J+Math.ceil(J/2)}function _8($,J,q=!1){const Q=$.length,G=i$(J),U=z$(J);if(Q<16||Q<U||Q>1024)throw new Error("expected "+U+"-1024 bytes of input, got "+Q);const Y=q?U$($):P0($),X=W0(Y,J-G0)+G0;return q?Y$(X,G):$8(X,G)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var U0=BigInt(0),G0=BigInt(1),l0=BigInt(2),m$=BigInt(3),h$=BigInt(4),c$=BigInt(5),$J=BigInt(7),d$=BigInt(8),QJ=BigInt(9),l$=BigInt(16);var UJ=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function N8($,J){const q=J.negate();return $?q:J}function f8($,J){const q=E8($.Fp,J.map((Q)=>Q.Z));return J.map((Q,G)=>$.fromAffine(Q.toAffine(q[G])))}var s$=function($,J){if(!Number.isSafeInteger($)||$<=0||$>J)throw new Error("invalid window size, expected [1.."+J+"], got W="+$)},K$=function($,J){s$($,J);const q=Math.ceil(J/$)+1,Q=2**($-1),G=2**$,U=y0($),Y=BigInt($);return{windows:q,windowSize:Q,mask:U,maxNumber:G,shiftBy:Y}},r$=function($,J,q){const{windowSize:Q,mask:G,maxNumber:U,shiftBy:Y}=q;let X=Number($&G),Z=$>>Y;if(X>Q)X-=U,Z+=o0;const N=J*Q,z=N+Math.abs(X)-1,A=X===0,j=X<0,D=J%2!==0;return{nextN:Z,offset:z,isZero:A,isNeg:j,isNegF:D,offsetF:N}},jJ=function($,J){if(!Array.isArray($))throw new Error("array expected");$.forEach((q,Q)=>{if(!(q instanceof J))throw new Error("invalid point at index "+Q)})},XJ=function($,J){if(!Array.isArray($))throw new Error("array of scalars expected");$.forEach((q,Q)=>{if(!J.isValid(q))throw new Error("invalid scalar at index "+Q)})},W$=function($){return t$.get($)||1},a$=function($){if($!==Q8)throw new Error("invalid wNAF")};function e$($,J,q,Q){let G=J,U=$.ZERO,Y=$.ZERO;while(q>Q8||Q>Q8){if(q&o0)U=U.add(G);if(Q&o0)Y=Y.add(G);G=G.double(),q>>=o0,Q>>=o0}return{p1:U,p2:Y}}function $Q($,J,q,Q){jJ(q,$),XJ(Q,J);const G=q.length,U=Q.length;if(G!==U)throw new Error("arrays of points and scalars must have equal length");const Y=$.ZERO,X=I8(BigInt(G));let Z=1;if(X>12)Z=X-3;else if(X>4)Z=X-2;else if(X>0)Z=2;const N=y0(Z),z=new Array(Number(N)+1).fill(Y),A=Math.floor((J.BITS-1)/Z)*Z;let j=Y;for(let D=A;D>=0;D-=Z){z.fill(Y);for(let w=0;w<U;w++){const y=Q[w],b=Number(y>>BigInt(D)&N);z[b]=z[b].add(q[w])}let L=Y;for(let w=z.length-1,y=Y;w>0;w--)y=y.add(z[w]),L=L.add(y);if(j=j.add(L),D!==0)for(let w=0;w<Z;w++)j=j.double()}return j}var n$=function($,J,q){if(J){if(J.ORDER!==$)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return Z$(J),J}else return u0($,{isLE:q})};function QQ($,J,q={},Q){if(Q===void 0)Q=$==="edwards";if(!J||typeof J!=="object")throw new Error(`expected valid ${$} CURVE object`);for(let Z of["p","n","h"]){const N=J[Z];if(!(typeof N==="bigint"&&N>Q8))throw new Error(`CURVE.${Z} must be positive bigint`)}const G=n$(J.p,q.Fp,Q),U=n$(J.n,q.Fn,Q),X=["Gx","Gy","a",$==="weierstrass"?"b":"d"];for(let Z of X)if(!G.isValid(J[Z]))throw new Error(`CURVE.${Z} must be valid field element of CURVE.Fp`);return J=Object.freeze(Object.assign({},J)),{CURVE:J,Fp:G,Fn:U}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var Q8=BigInt(0),o0=BigInt(1),D$=new WeakMap,t$=new WeakMap;class M${constructor($,J){this.BASE=$.BASE,this.ZERO=$.ZERO,this.Fn=$.Fn,this.bits=J}_unsafeLadder($,J,q=this.ZERO){let Q=$;while(J>Q8){if(J&o0)q=q.add(Q);Q=Q.double(),J>>=o0}return q}precomputeWindow($,J){const{windows:q,windowSize:Q}=K$(J,this.bits),G=[];let U=$,Y=U;for(let X=0;X<q;X++){Y=U,G.push(Y);for(let Z=1;Z<Q;Z++)Y=Y.add(U),G.push(Y);U=Y.double()}return G}wNAF($,J,q){if(!this.Fn.isValid(q))throw new Error("invalid scalar");let Q=this.ZERO,G=this.BASE;const U=K$($,this.bits);for(let Y=0;Y<U.windows;Y++){const{nextN:X,offset:Z,isZero:N,isNeg:z,isNegF:A,offsetF:j}=r$(q,Y,U);if(q=X,N)G=G.add(N8(A,J[j]));else Q=Q.add(N8(z,J[Z]))}return a$(q),{p:Q,f:G}}wNAFUnsafe($,J,q,Q=this.ZERO){const G=K$($,this.bits);for(let U=0;U<G.windows;U++){if(q===Q8)break;const{nextN:Y,offset:X,isZero:Z,isNeg:N}=r$(q,U,G);if(q=Y,Z)continue;else{const z=J[X];Q=Q.add(N?z.negate():z)}}return a$(q),Q}getPrecomputes($,J,q){let Q=D$.get(J);if(!Q){if(Q=this.precomputeWindow(J,$),$!==1){if(typeof q==="function")Q=q(Q);D$.set(J,Q)}}return Q}cached($,J,q){const Q=W$($);return this.wNAF(Q,this.getPrecomputes(Q,$,q),J)}unsafe($,J,q,Q){const G=W$($);if(G===1)return this._unsafeLadder($,J,Q);return this.wNAFUnsafe(G,this.getPrecomputes(G,$,q),J,Q)}createCache($,J){s$(J,this.bits),t$.set($,J),D$.delete($)}hasCache($){return W$($)!==1}}function ZJ($,J,q){const[[Q,G],[U,Y]]=J,X=JQ(Y*$,q),Z=JQ(-G*$,q);let N=$-X*Q-Z*U,z=-X*G-Z*Y;const A=N<E0,j=z<E0;if(A)N=-N;if(j)z=-z;const D=y0(Math.ceil(I8(q)/2))+J8;if(N<E0||N>=D||z<E0||z>=D)throw new Error("splitScalar (endomorphism): failed, k="+$);return{k1neg:A,k1:N,k2neg:j,k2:z}}var N$=function($){if(!["compact","recovered","der"].includes($))throw new Error('Signature format must be "compact", "recovered", or "der"');return $},V$=function($,J){const q={};for(let Q of Object.keys(J))q[Q]=$[Q]===void 0?J[Q]:$[Q];if(D8(q.lowS,"lowS"),D8(q.prehash,"prehash"),q.format!==void 0)N$(q.format);return q};function g0($,J){const{BYTES:q}=$;let Q;if(typeof J==="bigint")Q=J;else{let G=p("private key",J);try{Q=$.fromBytes(G)}catch(U){throw new Error(`invalid private key: expected ui8a of size ${q}, got ${typeof J}`)}}if(!$.isValidNot0(Q))throw new Error("invalid private key: out of range [1..N-1]");return Q}function KJ($,J={}){const q=QQ("weierstrass",$,J),{Fp:Q,Fn:G}=q;let U=q.CURVE;const{h:Y,n:X}=U;V8(J,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:Z}=J;if(Z){if(!Q.is0(U.a)||typeof Z.beta!=="bigint"||!Array.isArray(Z.basises))throw new Error('invalid endo: expected "beta": bigint and "basises": array')}const N=YQ(Q,G);function z(){if(!Q.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function A(V,k,W){const{x,y:K}=k.toAffine(),M=Q.toBytes(x);if(D8(W,"isCompressed"),W){z();const O=!Q.isOdd(K);return z0(UQ(O),M)}else return z0(Uint8Array.of(4),M,Q.toBytes(K))}function j(V){b0(V,void 0,"Point");const{publicKey:k,publicKeyUncompressed:W}=N,x=V.length,K=V[0],M=V.subarray(1);if(x===k&&(K===2||K===3)){const O=Q.fromBytes(M);if(!Q.isValid(O))throw new Error("bad point: is not on curve, wrong x");const H=w(O);let R;try{R=Q.sqrt(H)}catch(E){const v=E instanceof Error?": "+E.message:"";throw new Error("bad point: is not on curve, sqrt error"+v)}z();const C=Q.isOdd(R);if((K&1)===1!==C)R=Q.neg(R);return{x:O,y:R}}else if(x===W&&K===4){const O=Q.BYTES,H=Q.fromBytes(M.subarray(0,O)),R=Q.fromBytes(M.subarray(O,O*2));if(!y(H,R))throw new Error("bad point: is not on curve");return{x:H,y:R}}else throw new Error(`bad point: got length ${x}, expected compressed=${k} or uncompressed=${W}`)}const D=J.toBytes||A,L=J.fromBytes||j;function w(V){const k=Q.sqr(V),W=Q.mul(k,V);return Q.add(Q.add(W,Q.mul(V,U.a)),U.b)}function y(V,k){const W=Q.sqr(k),x=w(V);return Q.eql(W,x)}if(!y(U.Gx,U.Gy))throw new Error("bad curve params: generator point");const b=Q.mul(Q.pow(U.a,b8),zJ),J0=Q.mul(Q.sqr(U.b),BigInt(27));if(Q.is0(Q.add(b,J0)))throw new Error("bad curve params: a or b");function g(V,k,W=!1){if(!Q.isValid(k)||W&&Q.is0(k))throw new Error(`bad point coordinate ${V}`);return k}function Y0(V){if(!(V instanceof I))throw new Error("ProjectivePoint expected")}function s(V){if(!Z||!Z.basises)throw new Error("no endo");return ZJ(V,Z.basises,G.ORDER)}const q0=j$((V,k)=>{const{X:W,Y:x,Z:K}=V;if(Q.eql(K,Q.ONE))return{x:W,y:x};const M=V.is0();if(k==null)k=M?Q.ONE:Q.inv(K);const O=Q.mul(W,k),H=Q.mul(x,k),R=Q.mul(K,k);if(M)return{x:Q.ZERO,y:Q.ZERO};if(!Q.eql(R,Q.ONE))throw new Error("invZ was invalid");return{x:O,y:H}}),K0=j$((V)=>{if(V.is0()){if(J.allowInfinityPoint&&!Q.is0(V.Y))return;throw new Error("bad point: ZERO")}const{x:k,y:W}=V.toAffine();if(!Q.isValid(k)||!Q.isValid(W))throw new Error("bad point: x or y not field elements");if(!y(k,W))throw new Error("bad point: equation left != right");if(!V.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function e(V,k,W,x,K){return W=new I(Q.mul(W.X,V),W.Y,W.Z),k=N8(x,k),W=N8(K,W),k.add(W)}class I{constructor(V,k,W){this.X=g("x",V),this.Y=g("y",k,!0),this.Z=g("z",W),Object.freeze(this)}static CURVE(){return U}static fromAffine(V){const{x:k,y:W}=V||{};if(!V||!Q.isValid(k)||!Q.isValid(W))throw new Error("invalid affine point");if(V instanceof I)throw new Error("projective point not allowed");if(Q.is0(k)&&Q.is0(W))return I.ZERO;return new I(k,W,Q.ONE)}static fromBytes(V){const k=I.fromAffine(L(b0(V,void 0,"point")));return k.assertValidity(),k}static fromHex(V){return I.fromBytes(p("pointHex",V))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(V=8,k=!0){if(f.createCache(this,V),!k)this.multiply(b8);return this}assertValidity(){K0(this)}hasEvenY(){const{y:V}=this.toAffine();if(!Q.isOdd)throw new Error("Field doesn't support isOdd");return!Q.isOdd(V)}equals(V){Y0(V);const{X:k,Y:W,Z:x}=this,{X:K,Y:M,Z:O}=V,H=Q.eql(Q.mul(k,O),Q.mul(K,x)),R=Q.eql(Q.mul(W,O),Q.mul(M,x));return H&&R}negate(){return new I(this.X,Q.neg(this.Y),this.Z)}double(){const{a:V,b:k}=U,W=Q.mul(k,b8),{X:x,Y:K,Z:M}=this;let{ZERO:O,ZERO:H,ZERO:R}=Q,C=Q.mul(x,x),c=Q.mul(K,K),E=Q.mul(M,M),v=Q.mul(x,K);return v=Q.add(v,v),R=Q.mul(x,M),R=Q.add(R,R),O=Q.mul(V,R),H=Q.mul(W,E),H=Q.add(O,H),O=Q.sub(c,H),H=Q.add(c,H),H=Q.mul(O,H),O=Q.mul(v,O),R=Q.mul(W,R),E=Q.mul(V,E),v=Q.sub(C,E),v=Q.mul(V,v),v=Q.add(v,R),R=Q.add(C,C),C=Q.add(R,C),C=Q.add(C,E),C=Q.mul(C,v),H=Q.add(H,C),E=Q.mul(K,M),E=Q.add(E,E),C=Q.mul(E,v),O=Q.sub(O,C),R=Q.mul(E,c),R=Q.add(R,R),R=Q.add(R,R),new I(O,H,R)}add(V){Y0(V);const{X:k,Y:W,Z:x}=this,{X:K,Y:M,Z:O}=V;let{ZERO:H,ZERO:R,ZERO:C}=Q;const c=U.a,E=Q.mul(U.b,b8);let v=Q.mul(k,K),u=Q.mul(W,M),_=Q.mul(x,O),h=Q.add(k,W),d=Q.add(K,M);h=Q.mul(h,d),d=Q.add(v,u),h=Q.sub(h,d),d=Q.add(k,x);let l=Q.add(K,O);return d=Q.mul(d,l),l=Q.add(v,_),d=Q.sub(d,l),l=Q.add(W,x),H=Q.add(M,O),l=Q.mul(l,H),H=Q.add(u,_),l=Q.sub(l,H),C=Q.mul(c,d),H=Q.mul(E,_),C=Q.add(H,C),H=Q.sub(u,C),C=Q.add(u,C),R=Q.mul(H,C),u=Q.add(v,v),u=Q.add(u,v),_=Q.mul(c,_),d=Q.mul(E,d),u=Q.add(u,_),_=Q.sub(v,_),_=Q.mul(c,_),d=Q.add(d,_),v=Q.mul(u,d),R=Q.add(R,v),v=Q.mul(l,d),H=Q.mul(h,H),H=Q.sub(H,v),v=Q.mul(h,u),C=Q.mul(l,C),C=Q.add(C,v),new I(H,R,C)}subtract(V){return this.add(V.negate())}is0(){return this.equals(I.ZERO)}multiply(V){const{endo:k}=J;if(!G.isValidNot0(V))throw new Error("invalid scalar: out of range");let W,x;const K=(M)=>f.cached(this,M,(O)=>f8(I,O));if(k){const{k1neg:M,k1:O,k2neg:H,k2:R}=s(V),{p:C,f:c}=K(O),{p:E,f:v}=K(R);x=c.add(v),W=e(k.beta,C,E,M,H)}else{const{p:M,f:O}=K(V);W=M,x=O}return f8(I,[W,x])[0]}multiplyUnsafe(V){const{endo:k}=J,W=this;if(!G.isValid(V))throw new Error("invalid scalar: out of range");if(V===E0||W.is0())return I.ZERO;if(V===J8)return W;if(f.hasCache(this))return this.multiply(V);if(k){const{k1neg:x,k1:K,k2neg:M,k2:O}=s(V),{p1:H,p2:R}=e$(I,W,K,O);return e(k.beta,H,R,x,M)}else return f.unsafe(W,V)}multiplyAndAddUnsafe(V,k,W){const x=this.multiplyUnsafe(k).add(V.multiplyUnsafe(W));return x.is0()?void 0:x}toAffine(V){return q0(this,V)}isTorsionFree(){const{isTorsionFree:V}=J;if(Y===J8)return!0;if(V)return V(I,this);return f.unsafe(this,X).is0()}clearCofactor(){const{clearCofactor:V}=J;if(Y===J8)return this;if(V)return V(I,this);return this.multiplyUnsafe(Y)}isSmallOrder(){return this.multiplyUnsafe(Y).is0()}toBytes(V=!0){return D8(V,"isCompressed"),this.assertValidity(),D(I,this,V)}toHex(V=!0){return C0(this.toBytes(V))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(V=!0){return this.toBytes(V)}_setWindowSize(V){this.precompute(V)}static normalizeZ(V){return f8(I,V)}static msm(V,k){return $Q(I,G,V,k)}static fromPrivateKey(V){return I.BASE.multiply(g0(G,V))}}I.BASE=new I(U.Gx,U.Gy,Q.ONE),I.ZERO=new I(Q.ZERO,Q.ONE,Q.ZERO),I.Fp=Q,I.Fn=G;const r=G.BITS,f=new M$(I,J.endo?Math.ceil(r/2):r);return I.BASE.precompute(8),I}var UQ=function($){return Uint8Array.of($?2:3)};var YQ=function($,J){return{secretKey:J.BYTES,publicKey:1+$.BYTES,publicKeyUncompressed:1+2*$.BYTES,publicKeyHasPrefix:!0,signature:2*J.BYTES}};function DJ($,J={}){const{Fn:q}=$,Q=J.randomBytes||d0,G=Object.assign(YQ($.Fp,q),{seed:z$(q.ORDER)});function U(D){try{return!!g0(q,D)}catch(L){return!1}}function Y(D,L){const{publicKey:w,publicKeyUncompressed:y}=G;try{const b=D.length;if(L===!0&&b!==w)return!1;if(L===!1&&b!==y)return!1;return!!$.fromBytes(D)}catch(b){return!1}}function X(D=Q(G.seed)){return _8(b0(D,G.seed,"seed"),q.ORDER)}function Z(D,L=!0){return $.BASE.multiply(g0(q,D)).toBytes(L)}function N(D){const L=X(D);return{secretKey:L,publicKey:Z(L)}}function z(D){if(typeof D==="bigint")return!1;if(D instanceof $)return!0;const{secretKey:L,publicKey:w,publicKeyUncompressed:y}=G;if(q.allowedLengths||L===w)return;const b=p("key",D).length;return b===w||b===y}function A(D,L,w=!0){if(z(D)===!0)throw new Error("first arg must be private key");if(z(L)===!1)throw new Error("second arg must be public key");const y=g0(q,D);return $.fromHex(L).multiply(y).toBytes(w)}return Object.freeze({getPublicKey:Z,getSharedSecret:A,keygen:N,Point:$,utils:{isValidSecretKey:U,isValidPublicKey:Y,randomSecretKey:X,isValidPrivateKey:U,randomPrivateKey:X,normPrivateKeyToScalar:(D)=>g0(q,D),precompute(D=8,L=$.BASE){return L.precompute(D,!1)}},lengths:G})}function WJ($,J,q={}){k8(J),V8(q,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const Q=q.randomBytes||d0,G=q.hmac||((W,...x)=>Q$(J,W,z0(...x))),{Fp:U,Fn:Y}=$,{ORDER:X,BITS:Z}=Y,{keygen:N,getPublicKey:z,getSharedSecret:A,utils:j,lengths:D}=DJ($,q),L={prehash:!1,lowS:typeof q.lowS==="boolean"?q.lowS:!1,format:void 0,extraEntropy:!1},w="compact";function y(W){const x=X>>J8;return W>x}function b(W,x){if(!Y.isValidNot0(x))throw new Error(`invalid signature ${W}: out of range 1..Point.Fn.ORDER`);return x}function J0(W,x){N$(x);const K=D.signature,M=x==="compact"?K:x==="recovered"?K+1:void 0;return b0(W,M,`${x} signature`)}class g{constructor(W,x,K){if(this.r=b("r",W),this.s=b("s",x),K!=null)this.recovery=K;Object.freeze(this)}static fromBytes(W,x=w){J0(W,x);let K;if(x==="der"){const{r:R,s:C}=I0.toSig(b0(W));return new g(R,C)}if(x==="recovered")K=W[0],x="compact",W=W.subarray(1);const M=Y.BYTES,O=W.subarray(0,M),H=W.subarray(M,M*2);return new g(Y.fromBytes(O),Y.fromBytes(H),K)}static fromHex(W,x){return this.fromBytes(c0(W),x)}addRecoveryBit(W){return new g(this.r,this.s,W)}recoverPublicKey(W){const x=U.ORDER,{r:K,s:M,recovery:O}=this;if(O==null||![0,1,2,3].includes(O))throw new Error("recovery id invalid");if(X*GQ<x&&O>1)throw new Error("recovery id is ambiguous for h>1 curve");const R=O===2||O===3?K+X:K;if(!U.isValid(R))throw new Error("recovery id 2 or 3 invalid");const C=U.toBytes(R),c=$.fromBytes(z0(UQ((O&1)===0),C)),E=Y.inv(R),v=s(p("msgHash",W)),u=Y.create(-v*E),_=Y.create(M*E),h=$.BASE.multiplyUnsafe(u).add(c.multiplyUnsafe(_));if(h.is0())throw new Error("point at infinify");return h.assertValidity(),h}hasHighS(){return y(this.s)}toBytes(W=w){if(N$(W),W==="der")return c0(I0.hexFromSig(this));const x=Y.toBytes(this.r),K=Y.toBytes(this.s);if(W==="recovered"){if(this.recovery==null)throw new Error("recovery bit must be present");return z0(Uint8Array.of(this.recovery),x,K)}return z0(x,K)}toHex(W){return C0(this.toBytes(W))}assertValidity(){}static fromCompact(W){return g.fromBytes(p("sig",W),"compact")}static fromDER(W){return g.fromBytes(p("sig",W),"der")}normalizeS(){return this.hasHighS()?new g(this.r,Y.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return C0(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return C0(this.toBytes("compact"))}}const Y0=q.bits2int||function W(x){if(x.length>8192)throw new Error("input is too large");const K=P0(x),M=x.length*8-Z;return M>0?K>>BigInt(M):K},s=q.bits2int_modN||function W(x){return Y.create(Y0(x))},q0=y0(Z);function K0(W){return y$("num < 2^"+Z,W,E0,q0),Y.toBytes(W)}function e(W,x){return b0(W,void 0,"message"),x?b0(J(W),void 0,"prehashed message"):W}function I(W,x,K){if(["recovered","canonical"].some((_)=>(_ in K)))throw new Error("sign() legacy options not supported");const{lowS:M,prehash:O,extraEntropy:H}=V$(K,L);W=e(W,O);const R=s(W),C=g0(Y,x),c=[K0(C),K0(R)];if(H!=null&&H!==!1){const _=H===!0?Q(D.secretKey):H;c.push(p("extraEntropy",_))}const E=z0(...c),v=R;function u(_){const h=Y0(_);if(!Y.isValidNot0(h))return;const d=Y.inv(h),l=$.BASE.multiply(h).toAffine(),t=Y.create(l.x);if(t===E0)return;const j0=Y.create(d*Y.create(v+t*C));if(j0===E0)return;let $0=(l.x===t?0:2)|Number(l.y&J8),Q0=j0;if(M&&y(j0))Q0=Y.neg(j0),$0^=1;return new g(t,Q0,$0)}return{seed:E,k2sig:u}}function r(W,x,K={}){W=p("message",W);const{seed:M,k2sig:O}=I(W,x,K);return u$(J.outputLen,Y.BYTES,G)(M,O)}function f(W){let x=void 0;const K=typeof W==="string"||m0(W),M=!K&&W!==null&&typeof W==="object"&&typeof W.r==="bigint"&&typeof W.s==="bigint";if(!K&&!M)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(M)x=new g(W.r,W.s);else if(K){try{x=g.fromBytes(p("sig",W),"der")}catch(O){if(!(O instanceof I0.Err))throw O}if(!x)try{x=g.fromBytes(p("sig",W),"compact")}catch(O){return!1}}if(!x)return!1;return x}function V(W,x,K,M={}){const{lowS:O,prehash:H,format:R}=V$(M,L);if(K=p("publicKey",K),x=e(p("message",x),H),("strict"in M))throw new Error("options.strict was renamed to lowS");const C=R===void 0?f(W):g.fromBytes(p("sig",W),R);if(C===!1)return!1;try{const c=$.fromBytes(K);if(O&&C.hasHighS())return!1;const{r:E,s:v}=C,u=s(x),_=Y.inv(v),h=Y.create(u*_),d=Y.create(E*_),l=$.BASE.multiplyUnsafe(h).add(c.multiplyUnsafe(d));if(l.is0())return!1;return Y.create(l.x)===E}catch(c){return!1}}function k(W,x,K={}){const{prehash:M}=V$(K,L);return x=e(x,M),g.fromBytes(W,"recovered").recoverPublicKey(x).toBytes()}return Object.freeze({keygen:N,getPublicKey:z,getSharedSecret:A,utils:j,lengths:D,Point:$,sign:r,verify:V,recoverPublicKey:k,Signature:g,hash:J})}var MJ=function($){const J={a:$.a,b:$.b,p:$.Fp.ORDER,n:$.n,h:$.h,Gx:$.Gx,Gy:$.Gy},q=$.Fp;let Q=$.allowedPrivateKeyLengths?Array.from(new Set($.allowedPrivateKeyLengths.map((Y)=>Math.ceil(Y/2)))):void 0;const G=u0(J.n,{BITS:$.nBitLength,allowedLengths:Q,modFromBytes:$.wrapPrivateKey}),U={Fp:q,Fn:G,allowInfinityPoint:$.allowInfinityPoint,endo:$.endo,isTorsionFree:$.isTorsionFree,clearCofactor:$.clearCofactor,fromBytes:$.fromBytes,toBytes:$.toBytes};return{CURVE:J,curveOpts:U}},VJ=function($){const{CURVE:J,curveOpts:q}=MJ($),Q={hmac:$.hmac,randomBytes:$.randomBytes,lowS:$.lowS,bits2int:$.bits2int,bits2int_modN:$.bits2int_modN};return{CURVE:J,curveOpts:q,hash:$.hash,ecdsaOpts:Q}};var NJ=function($,J){const q=J.Point;return Object.assign({},J,{ProjectivePoint:q,CURVE:Object.assign({},$,v8(q.Fn.ORDER,q.Fn.BITS))})};function jQ($){const{CURVE:J,curveOpts:q,hash:Q,ecdsaOpts:G}=VJ($),U=KJ(J,q),Y=WJ(U,Q,G);return NJ($,Y)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var JQ=($,J)=>($+($>=0?J:-J)/GQ)/J;class qQ extends Error{constructor($=""){super($)}}var I0={Err:qQ,_tlv:{encode:($,J)=>{const{Err:q}=I0;if($<0||$>256)throw new q("tlv.encode: wrong tag");if(J.length&1)throw new q("tlv.encode: unpadded data");const Q=J.length/2,G=W8(Q);if(G.length/2&128)throw new q("tlv.encode: long form length too big");const U=Q>127?W8(G.length/2|128):"";return W8($)+U+G+J},decode($,J){const{Err:q}=I0;let Q=0;if($<0||$>256)throw new q("tlv.encode: wrong tag");if(J.length<2||J[Q++]!==$)throw new q("tlv.decode: wrong tlv");const G=J[Q++],U=!!(G&128);let Y=0;if(!U)Y=G;else{const Z=G&127;if(!Z)throw new q("tlv.decode(long): indefinite length not supported");if(Z>4)throw new q("tlv.decode(long): byte length is too big");const N=J.subarray(Q,Q+Z);if(N.length!==Z)throw new q("tlv.decode: length bytes not complete");if(N[0]===0)throw new q("tlv.decode(long): zero leftmost byte");for(let z of N)Y=Y<<8|z;if(Q+=Z,Y<128)throw new q("tlv.decode(long): not minimal encoding")}const X=J.subarray(Q,Q+Y);if(X.length!==Y)throw new q("tlv.decode: wrong value length");return{v:X,l:J.subarray(Q+Y)}}},_int:{encode($){const{Err:J}=I0;if($<E0)throw new J("integer: negative integers are not allowed");let q=W8($);if(Number.parseInt(q[0],16)&8)q="00"+q;if(q.length&1)throw new J("unexpected DER parsing assertion: unpadded hex");return q},decode($){const{Err:J}=I0;if($[0]&128)throw new J("invalid signature integer: negative");if($[0]===0&&!($[1]&128))throw new J("invalid signature integer: unnecessary leading zero");return P0($)}},toSig($){const{Err:J,_int:q,_tlv:Q}=I0,G=p("signature",$),{v:U,l:Y}=Q.decode(48,G);if(Y.length)throw new J("invalid signature: left bytes after parsing");const{v:X,l:Z}=Q.decode(2,U),{v:N,l:z}=Q.decode(2,Z);if(z.length)throw new J("invalid signature: left bytes after parsing");return{r:q.decode(X),s:q.decode(N)}},hexFromSig($){const{_tlv:J,_int:q}=I0,Q=J.encode(2,q.encode($.r)),G=J.encode(2,q.encode($.s)),U=Q+G;return J.encode(48,U)}},E0=BigInt(0),J8=BigInt(1),GQ=BigInt(2),b8=BigInt(3),zJ=BigInt(4);function XQ($,J){const q=(Q)=>jQ({...$,hash:Q});return{...q(J),create:q}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var RJ=function($){const J=q8.p,q=BigInt(3),Q=BigInt(6),G=BigInt(11),U=BigInt(22),Y=BigInt(23),X=BigInt(44),Z=BigInt(88),N=$*$*$%J,z=N*N*$%J,A=M0(z,q,J)*z%J,j=M0(A,q,J)*z%J,D=M0(j,B$,J)*N%J,L=M0(D,G,J)*D%J,w=M0(L,U,J)*L%J,y=M0(w,X,J)*w%J,b=M0(y,Z,J)*y%J,J0=M0(b,X,J)*w%J,g=M0(J0,q,J)*z%J,Y0=M0(g,Y,J)*L%J,s=M0(Y0,Q,J)*N%J,q0=M0(s,B$,J);if(!y8.eql(y8.sqr(q0),$))throw new Error("Cannot find square root");return q0},u8=function($,...J){let q=zQ[$];if(q===void 0){const Q=P8(S8($));q=z0(Q,Q),zQ[$]=q}return P8(z0(q,...J))},O$=function($){const{Fn:J,BASE:q}=G8,Q=g0(J,$),G=q.multiply(Q);return{scalar:x$(G.y)?Q:J.neg(Q),bytes:R$(G)}},WQ=function($){const J=y8;if(!J.isValidNot0($))throw new Error("invalid x: Fail if x \u2265 p");const q=J.create($*$),Q=J.create(q*$+BigInt(7));let G=J.sqrt(Q);if(!x$(G))G=J.neg(G);const U=G8.fromAffine({x:$,y:G});return U.assertValidity(),U},MQ=function(...$){return G8.Fn.create(B8(u8("BIP0340/challenge",...$)))},KQ=function($){return O$($).bytes},xJ=function($,J,q=d0(32)){const{Fn:Q}=G8,G=p("message",$),{bytes:U,scalar:Y}=O$(J),X=p("auxRand",q,32),Z=Q.toBytes(Y^B8(u8("BIP0340/aux",X))),N=u8("BIP0340/nonce",Z,U,G),{bytes:z,scalar:A}=O$(N),j=MQ(z,U,G),D=new Uint8Array(64);if(D.set(z,0),D.set(Q.toBytes(Q.create(A+j*Y)),32),!VQ(D,G,U))throw new Error("sign: Invalid signature produced");return D},VQ=function($,J,q){const{Fn:Q,BASE:G}=G8,U=p("signature",$,64),Y=p("message",J),X=p("publicKey",q,32);try{const Z=WQ(B8(X)),N=B8(U.subarray(0,32));if(!M8(N,ZQ,q8.p))return!1;const z=B8(U.subarray(32,64));if(!M8(z,ZQ,q8.n))return!1;const A=MQ(Q.toBytes(N),R$(Z),Y),j=G.multiplyUnsafe(z).add(Z.multiplyUnsafe(Q.neg(A))),{x:D,y:L}=j.toAffine();if(j.is0()||!x$(L)||D!==N)return!1;return!0}catch(Z){return!1}};/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var q8={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},BJ={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},OJ=BigInt(0),ZQ=BigInt(1),B$=BigInt(2),y8=u0(q8.p,{sqrt:RJ}),DQ=XQ({...q8,Fp:y8,lowS:!0,endo:BJ},P8),zQ={},R$=($)=>$.toBytes(!0).slice(1),G8=(()=>DQ.Point)(),x$=($)=>$%B$===OJ,B8=P0,g8=(()=>{const q=(G=d0(48))=>{return _8(G,q8.n)};DQ.utils.randomSecretKey;function Q(G){const U=q(G);return{secretKey:U,publicKey:KQ(U)}}return{keygen:Q,getPublicKey:KQ,sign:xJ,verify:VQ,Point:G8,utils:{randomSecretKey:q,randomPrivateKey:q,taggedHash:u8,lift_x:WQ,pointToBytes:R$,numberToBytesBE:$8,bytesToNumberBE:P0,mod:W0},lengths:{secretKey:32,publicKey:32,publicKeyHasPrefix:!1,signature:64,seed:48}}})();var HJ=new TextEncoder,LJ=new TextDecoder,T0=($)=>HJ.encode($),p0=($)=>LJ.decode($),F8=($)=>Array.from($,(J)=>J.toString(16).padStart(2,"0")).join(""),N0=JSON.stringify,i0=JSON.parse,m8=($,J=Number.MAX_SAFE_INTEGER)=>$.split("").reduce((q,Q)=>q+Q.charCodeAt(0),0)%J;var H$="AES-GCM",TJ={},NQ="$",BQ=",",AJ=($)=>{const J=new Uint8Array($);let Q="";for(let G=0;G<J.length;G+=32768)Q+=String.fromCharCode(...J.subarray(G,G+32768));return btoa(Q)},wJ=($)=>Uint8Array.from(atob($),(J)=>J.charCodeAt(0)).buffer,O8=($)=>TJ[$]??=crypto.subtle.digest("SHA-1",T0($)).then((J)=>{const q=new Uint8Array(J);let Q="";for(let G of q)Q+=G.toString(36);return Q}),OQ=async($,J,q)=>{const Q=await crypto.subtle.digest("SHA-256",T0(`${$}:${J}:${q}`));return crypto.subtle.importKey("raw",Q,{name:H$},!1,["encrypt","decrypt"])},RQ=async($,J)=>{const q=crypto.getRandomValues(new Uint8Array(12)),Q=await $,G=await crypto.subtle.encrypt({name:H$,iv:q},Q,T0(J));return`${q.join(BQ)}${NQ}${AJ(G)}`},xQ=async($,J)=>{const[q,Q]=J.split(NQ);if(!q||!Q)throw new Error("Invalid encrypted payload format");const G=Uint8Array.from(q.split(BQ),Number),U=await $,Y=await crypto.subtle.decrypt({name:H$,iv:G},U,wJ(Q));return p0(Y)};var V0="GenosRTC",U8=($,J)=>Array.from({length:$},J);var R8=($)=>Array.from(crypto.getRandomValues(new Uint8Array($)),(J)=>"0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz"[J%"0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz".length]).join(""),m=R8(20),v0=Promise.all.bind(Promise),HQ=typeof window!=="undefined",{entries:LQ,fromEntries:h8,keys:u1}=Object,TQ=()=>{},x0=($)=>new Error(`GenosRTC: ${$}`),x8=(...$)=>$.join("@"),AQ=($,J)=>{const q=[...$];let Q=q.length;const G=()=>{const U=Math.sin(J++)*1e4;return U-Math.floor(U)};while(Q){const U=Math.floor(G()*Q--);[q[Q],q[U]]=[q[U],q[Q]]}return q};var kJ=5000,wQ="icegatheringstatechange",kQ="offer",CJ="answer",SJ=[...U8(3,($,J)=>`stun:stun${J||""}.l.google.com:19302`),"stun:stun.cloudflare.com:3478"].map(($)=>({urls:$})),c8=($,{rtcConfig:J,rtcPolyfill:q,turnConfig:Q})=>{const G=new(q||RTCPeerConnection)({iceServers:[...SJ,...Q||[]],...J}),U={};let Y=!1,X=!1,Z;const N=(j)=>Object.assign(j,{binaryType:"arraybuffer",bufferedAmountLowThreshold:65535,onmessage:(D)=>U.data?.(D.data),onopen:()=>U.connect?.(),onclose:()=>U.close?.(),onerror:(D)=>!D?.error?.message?.includes("User-Initiated Abort")&&U.error?.(D)}),z=()=>Promise.race([new Promise((j)=>{const D=()=>{if(G.iceGatheringState==="complete")G.removeEventListener(wQ,D),j()};G.addEventListener(wQ,D),D()}),new Promise((j)=>setTimeout(j,kJ))]).then(()=>({type:G.localDescription.type,sdp:G.localDescription.sdp.replace(/a=ice-options:trickle\s\n/g,"")}));if($?N(Z=G.createDataChannel("data")):G.ondatachannel=({channel:j})=>N(Z=j),G.onnegotiationneeded=async()=>{try{Y=!0,await G.setLocalDescription(),U.signal?.(await z())}catch(j){U.error?.(j)}finally{Y=!1}},G.onconnectionstatechange=()=>{if(["disconnected","failed","closed"].includes(G.connectionState))U.close?.()},G.ontrack=(j)=>{U.track?.(j.track,j.streams[0]),U.stream?.(j.streams[0])},G.onremovestream=(j)=>U.stream?.(j.stream),$&&!G.canTrickleIceCandidates)G.onnegotiationneeded();const A=()=>G.getSenders();return{created:Date.now(),connection:G,get channel(){return Z},get isDead(){return G.connectionState==="closed"},async signal(j){if(Z?.readyState==="open"&&!j.sdp?.includes("a=rtpmap"))return;try{if(j.type===kQ){if(Y||G.signalingState!=="stable"&&!X){if($)return;await v0([G.setLocalDescription({type:"rollback"}),G.setRemoteDescription(j)])}else await G.setRemoteDescription(j);await G.setLocalDescription();const D=await z();return U.signal?.(D),D}if(j.type===CJ){X=!0;try{await G.setRemoteDescription(j)}finally{X=!1}}}catch(D){U.error?.(D)}},sendData:(j)=>Z.send(j),destroy:()=>{Z?.close(),G.close(),Y=X=!1},setHandlers:(j)=>Object.assign(U,j),offerPromise:$?new Promise((j)=>U.signal=(D)=>D.type===kQ&&j(D)):Promise.resolve(),addStream:(j)=>j.getTracks().forEach((D)=>G.addTrack(D,j)),removeStream:(j)=>A().filter((D)=>j.getTracks().includes(D.track)).forEach((D)=>G.removeTrack(D)),addTrack:(j,D)=>G.addTrack(j,D),removeTrack:(j)=>{const D=A().find((L)=>L.track===j);if(D)G.removeTrack(D)},replaceTrack:(j,D)=>A().find((L)=>L.track===j)?.replaceTrack(D)}};var PJ=Object.getPrototypeOf(Uint8Array),l8=12,CQ=0,o8=CQ+l8,p8=o8+1,L8=p8+1,T8=L8+1,H8=16384-T8,d8=255,L$="bufferedamountlow",Y8=($)=>`@_${$}`,T$=100,IJ=3,EJ=200,SQ=($,J,q)=>{const Q=new Map,G=new Map,U=new Map,Y={},X={},Z={},N={},z=new Map,A=(K,M)=>{if(!z.has(K))z.set(K,new Set);z.get(K).add(M)},j=(K,M)=>z.get(K)?.delete(M),D=(K,...M)=>z.get(K)?.forEach((O)=>O(...M)),L=(K,M)=>{const O=K?Array.isArray(K)?K:[K]:Q.keys();return Array.from(O,(H)=>{const R=Q.get(H);if(!R)return console.warn(`${V0}: no peer with id ${H}`),null;return M(H,R)}).filter(Boolean)},w=(K)=>{if(!Q.has(K))return;Q.delete(K),delete Y[K],delete X[K],delete Z[K],delete N[K],D("peer:leave",K),J(K)},y=(K)=>new Promise((M,O)=>{let H=setTimeout(()=>{K.removeEventListener(L$,R),O(new Error(`${V0}: bufferLow timeout`))},5000);function R(){clearTimeout(H),K.removeEventListener(L$,R),M()}K.addEventListener(L$,R)}),b=(K)=>{if(U.has(K))return U.get(K);if(!K)throw x0("action type is required");const M=T0(K);if(M.byteLength>l8)throw x0(`\u274C "${K}" exceeds ${l8} bytes. Use a shorter name.`);const O=new Uint8Array(l8).map((u,_)=>M[_]||0);let H=0;const R=new Map([["message",new Set],["progress",new Set]]),C=(u,_)=>R.get(u)?.add(_),c=(u,_)=>R.get(u)?.delete(_),E=async(u,_,h,d)=>{if(h&&typeof h!=="object")throw x0("meta must be object");if(u===void 0)throw x0("data cannot be undefined");const l=u instanceof Blob,t=l||u instanceof ArrayBuffer||u instanceof PJ,j0=typeof u!=="string";if(h&&!t)throw x0("meta only allowed with binary");const $0=t?new Uint8Array(l?await u.arrayBuffer():u):T0(j0?N0(u):u),Q0=h?T0(N0(h)):null,i=Math.ceil($0.byteLength/H8)+(h?1:0)||1;if(i>T$)throw x0(`Message too large, exceeds max chunks ${T$}`);const r0=U8(i,(a0,X0)=>{const A0=X0===i-1,H0=h&&X0===0,n0=H0?Q0:$0.subarray(h?(X0-1)*H8:X0*H8,h?X0*H8:(X0+1)*H8),L0=new Uint8Array(T8+n0.byteLength);return L0.set(O),L0.set([H],o8),L0.set([A0|H0<<1|t<<2|j0<<3],p8),L0.set([Math.round((X0+1)/i*d8)],L8),L0.set(n0,T8),L0});return H=H+1&d8,v0(L(_,async(a0,X0)=>{const{channel:A0}=X0;for(let H0=0;H0<i;H0++){let n0=0;while(A0.bufferedAmount>A0.bufferedAmountLowThreshold){if(n0++>IJ)throw x0(`${V0}: send buffer full, max retries reached for peer ${a0}`);try{await y(A0)}catch(L0){console.warn(L0.message),await new Promise((t8)=>setTimeout(t8,EJ))}}if(!Q.has(a0))break;X0.sendData(r0[H0]),d?.(r0[H0][L8]/d8,a0,h)}}))};G.set(K,{listeners:R,send:E});const v={send:E,on:C,off:c};return U.set(K,v),v},J0=(K,M)=>{try{const O=new Uint8Array(M),H=p0(O.subarray(CQ,o8)).replace(/ /g,"");if(!G.has(H))return console.warn(`${V0}: unregistered type (${H})`);const[R]=O.subarray(o8,p8),[C]=O.subarray(p8,L8),[c]=O.subarray(L8,T8),E=O.subarray(T8),v=Boolean(C&1),u=Boolean(C&2),_=Boolean(C&4),h=Boolean(C&8),d=G.get(H),l=(Y[K]||={})[H]||={};if(l[R]?.chunks?.length>T$){console.warn(`${V0}: peer ${K} sent too many chunks for nonce ${R}, ignoring.`);return}const t=l[R]||={chunks:[]};if(u)try{t.meta=i0(p0(E))}catch{console.warn(`${V0}: failed to parse meta from peer ${K} for type ${H}`);return}else t.chunks.push(E);if(d.listeners.get("progress").forEach((Q0)=>{try{Q0(c/d8,K,t.meta)}catch(i){console.error(i)}}),!v)return;const j0=new Uint8Array(t.chunks.reduce((Q0,i)=>Q0+i.byteLength,0));t.chunks.reduce((Q0,i)=>(j0.set(i,Q0),Q0+i.byteLength),0),delete l[R];let $0;if(_)$0=j0;else if(h)try{$0=i0(p0(j0))}catch{console.warn(`${V0}: failed to parse JSON message data from peer ${K} for type ${H}`);return}else $0=p0(j0);d.listeners.get("message").forEach((Q0)=>{try{Q0($0,K,t.meta)}catch(i){console.error(i)}})}catch(O){console.error(`${V0}: error handling data from peer ${K}:`,O)}},g=async()=>{try{await W(""),await new Promise((K)=>setTimeout(K,99))}catch(K){console.warn(`${V0}: error sending leave`,K)}for(let[K,M]of Q){try{M.destroy()}catch{}Q.delete(K)}q()},{send:Y0,on:s}=b(Y8("ping")),{send:q0,on:K0}=b(Y8("pong")),{send:e,on:I}=b(Y8("signal")),{send:r,on:f}=b(Y8("stream")),{send:V,on:k}=b(Y8("track")),{send:W,on:x}=b(Y8("leave"));if($((K,M)=>{if(Q.has(M))return;Q.set(M,K),K.setHandlers({data:(O)=>J0(M,O),stream:(O)=>{D("stream:add",O,M,Z[M]),delete Z[M]},track:(O,H)=>{D("track:add",O,H,M,N[M]),delete N[M]},signal:(O)=>e(O,M),close:()=>w(M),error:(O)=>{console.error(`${V0}: peer error for ${M}`,O),w(M)}}),D("peer:join",M)}),s("message",(K,M)=>q0("",M)),K0("message",(K,M)=>{X[M]?.(),delete X[M]}),I("message",(K,M)=>Q.get(M)?.signal(K)),f("message",(K,M)=>Z[M]=K),k("message",(K,M)=>N[M]=K),x("message",(K,M)=>w(M)),HQ)addEventListener("beforeunload",g);return{on:A,off:j,channel:b,leave:g,ping:async(K)=>{if(!K)throw x0("ping() requires target peer ID");const M=Date.now();return Y0("",K),await new Promise((O)=>X[K]=O),Date.now()-M},getPeers:()=>h8(Array.from(Q,([K,M])=>[K,M.connection])),addStream:(K,M,O)=>L(M,async(H,R)=>{if(O)await r(O,H);R.addStream(K)}),removeStream:(K,M)=>L(M,(O,H)=>H.removeStream(K)),addTrack:(K,M,O,H)=>L(O,async(R,C)=>{if(H)await V(H,R);C.addTrack(K,M)}),removeTrack:(K,M)=>L(M,(O,H)=>H.removeTrack(K)),replaceTrack:(K,M,O,H)=>L(O,async(R,C)=>{if(H)await V(H,R);C.replaceTrack(K,M)})}};var vJ=20,_J=5333,PQ=57333,IQ=({init:$,subscribe:J,announce:q})=>{const Q={};let G=!1,U,Y;return(X,Z,N)=>{const{appId:z}=X;if(Q[z]?.[Z])return Q[z][Z];if(!X||!Z||!z&&!X.firebaseApp)throw x0(!X?"config required":!Z?"roomId required":"appId missing");let A=TQ;if(!G){const f=$(X);Y=U8(vJ,()=>c8(!0,X)),U=Array.isArray(f)?f:[f];const V=setInterval(()=>{Y=Y.filter((k)=>{const W=Date.now()-k.created<PQ;if(!W)k.destroy();return W})},PQ);Q.offerCleanupTimer||=V,G=!0}const j={},D={},L=x8(V0,z,Z),w=O8(L),y=O8(x8(L,m)),b=OQ(X.password||"",z,Z),J0=(f)=>async(V)=>({type:V.type,sdp:await f(b,V.sdp)}),g=J0(xQ),Y0=J0(RQ),s=(f,V)=>{if(D[V]===f)return;D[V]?.destroy(),D[V]=f,A(f,V),j[V]?.forEach((k)=>k!==f&&k.destroy()),delete j[V]},q0=(f,V)=>{if(D[V]===f)delete D[V]},K0=(f)=>async(V,k,W)=>{const[x,K]=await v0([w,y]);if(V!==x&&V!==K)return;const{peerId:M,offer:O,answer:H}=typeof k==="string"?i0(k):k;if(M===m||D[M])return;if(O){if(j[M]?.[f]&&m>M)return;const R=c8(!1,X);R.setHandlers({connect:()=>s(R,M),close:()=>q0(R,M)});try{const C=await g(O);if(R.isDead)return;const[c,E]=await v0([O8(x8(L,M)),R.signal(C).then(Y0)]);W(c,N0({peerId:m,answer:E}))}catch{N?.({error:"decryption failed (offer)",appId:z,peerId:M,roomId:Z})}}else if(H){const R=j[M]?.[f];if(!R||R.isDead)return;R.setHandlers({connect:()=>s(R,M),close:()=>q0(R,M)});try{R.signal(await g(H))}catch{N?.({error:"decryption failed (answer)",appId:z,peerId:M,roomId:Z})}}else{if(j[M]?.[f])return;const R=Y.pop()||c8(!0,X),[C,{offer:c}]=await v0([O8(x8(L,M)),R.offerPromise.then(Y0).then((E)=>({offer:E}))]);j[M]||=[],j[M][f]=R,R.setHandlers({connect:()=>s(R,M),close:()=>q0(R,M)}),W(C,N0({peerId:m,offer:c,peer:R}))}},e=v0(U.map(async(f,V)=>J(await f,await w,await y,K0(V)))),I=[];e.then((f)=>{U.forEach((V,k)=>{const W=async()=>{const x=await q(await V,await w,await y);I[k]=setTimeout(W,typeof x==="number"?x:_J)};W()}),Q[z][Z].onCleanup=()=>{if(delete Q[z][Z],I.forEach(clearTimeout),f.forEach((V)=>V()),Object.keys(Q).length===0)clearInterval(Q.offerCleanupTimer),delete Q.offerCleanupTimer}}),Q[z]||={};const r=SQ((f)=>A=f,(f)=>delete D[f],()=>r.onCleanup?.());return Q[z][Z]=r}};var EQ=3333,i8={},vQ={},_Q=($,J)=>{const q={};let Q=null;const G=()=>{if(Q)clearTimeout(Q),Q=null;const U=new WebSocket($);U.onclose=()=>{i8[$]??=EQ,Q=setTimeout(G,i8[$]),i8[$]*=2},U.onmessage=(Y)=>J(Y.data),q.socket=U,q.url=U.url,q.ready=new Promise((Y)=>{U.onopen=()=>{i8[$]=EQ,Y(q)}}),q.send=(Y)=>{if(U.readyState===1)U.send(Y)}};return q.forceReconnect=G,G(),vQ[$]=q,q};if(typeof window!=="undefined"){const $=()=>{console.info("\u26A1 [GenosRTC] Network event detected. Forcing reconnection\u2026"),Object.values(vQ).forEach((J)=>{if(J.socket&&J.socket.readyState!==WebSocket.OPEN&&J.socket.readyState!==WebSocket.CONNECTING)J.forceReconnect()})};window.addEventListener("online",()=>{console.info("\u2705 Reconnected to the network."),$()}),window.addEventListener("offline",async()=>{console.info("\u274C Disconnected from the network.")}),document.addEventListener("visibilitychange",()=>{if(document.visibilityState==="visible")$()})}var fQ=($)=>()=>h8(LQ($).map(([J,q])=>[J,q.socket])),bQ=($,J,q,Q)=>($.relayUrls??(Q?AQ(J,m8($.appId)):J)).slice(0,$.relayUrls?.length??$.relayRedundancy??q);var j8={},fJ=5,FQ="x",mQ="EVENT",bJ=/pow:\s*(\d+)\s*bits needed\.?/i,A$=new Set,hQ=g8.utils.randomSecretKey(),yJ=F8(g8.getPublicKey(hQ)),w$={},A8={},uJ={},cQ=()=>Math.floor(Date.now()/1000),dQ=($)=>uJ[$]??=m8($,1e4)+20000,r8=($)=>$.replace(/\/$/,""),gJ=["wss://black.nostrcity.club","wss://eu.purplerelay.com","wss://ftp.halifax.rwth-aachen.de/nostr","wss://nostr.data.haus","wss://nostr.mom","wss://nostr.oxtr.dev","wss://nostr.sathoarder.com","wss://nostr.vulpem.com","wss://relay.agorist.space","wss://relay.binaryrobot.com","wss://relay.fountain.fm","wss://relay.mostro.network","wss://relay.nostrdice.com","wss://sendit.nosflare.com","wss://yabu.me/v2","wss://relay.damus.io"],FJ=($,J)=>{const[q,Q,G,U]=i0(J);if(q===mQ)return A8[Q]?.(w$[Q],G.content);if(q==="NOTICE"||q==="OK"&&!G){if(+((q==="NOTICE"?Q:U).match(bJ)?.[1]??0)>0){const X=r8($);A$.add(X),j8[X]?.close?.(),delete j8[X]}}},mJ=($)=>{const J=r8($);if(j8[J])return j8[J];const q=_Q(J,(Q)=>FJ(J,Q));return j8[J]=q},yQ=async($,J)=>{const q={kind:dQ($),content:J,pubkey:yJ,created_at:cQ(),tags:[[FQ,$]]},Q=T0(N0([0,q.pubkey,q.created_at,q.kind,q.tags,q.content])),G=new Uint8Array(await crypto.subtle.digest("SHA-256",Q)),U=g8.sign(G,hQ);return N0([mQ,{...q,id:F8(G),sig:F8(U)}])},uQ=($,J)=>{return w$[$]=J,N0(["REQ",$,{kinds:[dQ(J)],since:cQ(),["#"+FQ]:[J]}])},gQ=($)=>{return delete w$[$],N0(["CLOSE",$])},lQ=IQ({init:($)=>{const q=($?.relayUrls?.length?$.relayUrls:null)??gJ;return bQ($,q,fJ,!0).map(mJ).map((G)=>G.ready.then(()=>G).catch(()=>null))},subscribe:($,J,q,Q)=>{const G=R8(64),U=R8(64);return A8[G]=A8[U]=(Y,X)=>Q(Y,X,async(Z,N)=>{if(A$.has(r8($.url)))return;$.send(await yQ(Z,N))}),$.send(uQ(G,J)),$.send(uQ(U,q)),()=>{$.send(gQ(G)),$.send(gQ(U)),delete A8[G],delete A8[U]}},announce:async($,J)=>{if(A$.has(r8($.url)))return;$.send(await yQ(J,N0({peerId:m})))}}),hJ=fQ(j8);var rJ=function($,J={}){const q={...cJ,...J},Q=!!q.debug,G=(...B)=>Q&&console.debug("[cells]",...B),U=Math.max(0,q.bridgesPerEdge|0),Y=Math.max(5,q.maxCellSize|0),X=Math.max(10,q.targetCells|0),Z=q.cellSize==="auto";let N=Z?2:Math.max(1,q.cellSize|0),z={cellId:null,bridges:[],isBridge:!1},A=null,j=null,D=null;const L=new Map,w=new Map,y=new Set,b=new Map,J0=new Set,g=new Set;let Y0=0;const s=[],q0=new Map,K0=new Set,e=new Map,I=new Map,r=()=>{const B=Math.ceil(_().length/N);return Math.min(150,B+3)},f=$.on?.bind($),V=$.off?.bind($);if(f)$.on=(B,T)=>String(B).startsWith("mesh:")?x(B,T):f(B,T);if(V)$.off=(B,T)=>String(B).startsWith("mesh:")?b.get(B)?.delete(T):V(B,T);const k=(B)=>(y.add(B),()=>y.delete(B)),W=(B,T,S)=>{if(g.has(S))return;if(g.add(S),g.size>oQ){const P=g.values().next().value;g.delete(P)}for(let P of y)try{P(B,T)}catch(F){G("Error in deliver handler:",F)}},x=(B,T)=>{if(!b.has(B))b.set(B,new Set);return b.get(B).add(T),()=>b.get(B)?.delete(T)},K=(B,...T)=>{const S=b.get(B);if(S)for(let P of S)try{P(...T)}catch{}},M=(B)=>{try{return typeof B==="string"?JSON.parse(B):B}catch{return null}},O=()=>`${m}:${Date.now().toString(36)}:${(Y0++&65535).toString(36)}`,H=()=>{if(J0.size>oQ)J0.delete(J0.values().next().value)},R=(B,T,S=[])=>{if(!B||!T)return;if(L.set(B,{cell:T,isBridge:S.length>0,bridges:[...S]}),!w.has(B))w.set(B,new n8(B));const P=w.get(B);if(P.markSeen(),P.addConnectedCell(T),I.set(T,{lastSeen:Date.now(),peerId:B}),S.length>0)for(let F of X8(T))P.addConnectedCell(F)},C=(B)=>w.get(B),c=(B,T)=>{const S=w.get(B);if(S)S.addRttSample(T)},E=(B)=>{const T=$0(B);if(T.length===0)return null;let S=0,P=0;for(let a of T){const Z0=w.get(a);if(Z0&&!Z0.isStale){if(S+=Z0.healthScore,Z0.isResponsive)P++}}const F=T.filter((a)=>{const Z0=w.get(a);return Z0&&!Z0.isStale});return{cellId:B,memberCount:F.length,avgHealth:F.length>0?S/F.length:0,responsiveRatio:F.length>0?P/F.length:0}},v=()=>{const B=E(z.cellId);K("mesh:health",{...z,health:B})},u=()=>{const B=Object.keys($.getPeers?.()||{}),T=[...B,m].sort();return{peers:B,all:T}},_=()=>{const{all:B}=u();return B.filter((T)=>{if(T===m)return!0;const S=w.get(T);return S&&!S.isStale})},h=()=>{if(!Z)return;const B=_().length,T=pJ(B,X,Y);if(T!==N)G("cellSize changed:",N,"->",T),N=T},d=(B,T)=>{const S=pQ(T.length,N),P=Math.ceil(T.length/S),F=B*P,a=Math.min(F+P,T.length);return T.slice(F,a)},l=(B,T)=>{if(U===0)return[];const S=s8(B),P=s8(T);if(S==null||P==null)return[];const F=_(),a=d(S,F),Z0=d(P,F),n=[...new Set([...a,...Z0])];if(!n.length)return[];const s0=new Set($0(B)),w8=new Set($0(T)),B0=n.filter((D0)=>{if(D0===m)return!0;const w0=w.get(D0);if(!w0||w0.isStale)return!1;const o=s0.has(D0)||w0.connectedCells.has(B),_0=w8.has(D0)||w0.connectedCells.has(T);return o||_0});if(!B0.length)B0.push(...n);const t0=B0.map((D0)=>({id:D0,score:w.get(D0)?.healthScore||0.5}));return t0.sort((D0,w0)=>{const o=w0.score-D0.score;return o!==0?o:D0.id.localeCompare(w0.id)}),t0.slice(0,U).map((D0)=>D0.id)},t=(B,T)=>{if(U===0)return[];const S=X8(T),P=[];for(let F of S)if(l(T,F).includes(B))P.push(F);return P},j0=()=>{h();const B=_(),T=iJ(m,B,N),S=pQ(B.length,N),P=`cell-${T}`,F=t(m,P),a=F.length>0;return G("computeState",{self:m,myCell:P,isBridge:a,bridgeEdges:F,cellSize:N,rosterSize:B.length,totalCells:S,dynamicTTL:r()}),{cellId:P,isBridge:a,bridges:F,cellSize:N,dynamicTTL:r(),totalCells:S}},$0=(B)=>{const T=[],S=new Set(Object.keys($.getPeers?.()||{}));for(let[P,F]of L)if(F.cell===B){const a=w.get(P);if(S.has(P)&&(!a||!a.isStale))T.push(P)}return T.sort(),T},Q0=()=>{if(!A)return;A0=H0();const B={t:"state",id:O(),ttl:r(),data:{id:m,cell:z.cellId,bridges:z.bridges,health:w.get(m)?.healthScore||0.5,timestamp:Date.now()},origin:m,originCell:z.cellId},T=JSON.stringify(B);A.send(T),i(j,T)},i=(B,T)=>{const S=M(T);if(!S?.id||!S?.t)return;const P=J0.has(S.id);if(!P)J0.add(S.id),H();const{t:F,id:a,ttl:Z0,data:n,origin:s0,originCell:w8}=S,B0=z.cellId;if(F==="state"&&n)R(n.id,n.cell,n.bridges),K("mesh:peer-state",n);if(F==="ping"&&n?.pingId&&s0!==m){const o={t:"pong",id:O(),ttl:r(),data:{pingId:n.pingId,receivedAt:Date.now()},origin:m,originCell:B0};A?.send(JSON.stringify(o))}if(F==="pong"&&n?.pingId){const o=e.get(n.pingId);if(o){clearTimeout(o.timeout);const _0=Date.now()-o.start;c(o.peerId,_0),o.resolve(_0),e.delete(n.pingId)}}if(F==="msg"&&s0!==m){if(w8===B0||U>0)W(n,s0,a)}if(P)return;if(!z.isBridge)return;if((Z0??0)<=0)return;const t0=(o,_0,iQ=null)=>{if(!o)return;const rQ={t:F,id:a,ttl:iQ??(Z0??r())-1,data:n,origin:s0||m,originCell:w8||B0},k$=JSON.stringify(rQ);if(_0?.length){const aQ=new Set(Object.keys($.getPeers?.()||{})),C$=_0.filter((nQ)=>aQ.has(nQ));if(C$.length>0)o.send(k$,C$)}else o.send(k$)};if(B===j){for(let o of X8(B0))t0(r0(o),null);return}if(!X8(B0).map(a8).includes(B))return;const w0=$0(B0);t0(A,w0);for(let o of X8(B0))if(a8(o)!==B)t0(r0(o),null)},r0=(B)=>{const T=a8(B);if(q0.has(B))return q0.get(B);const S=$.channel(T);if(q0.set(B,S),!K0.has(T))K0.add(T),S.on("message",(P)=>i(T,P));return S},a0=()=>{if(!z.cellId)return;if(j=a8(z.cellId),A=$.channel(j),!K0.has(j))K0.add(j),A.on("message",(B)=>i(j,B));if(z.isBridge)for(let B of X8(z.cellId))r0(B);if(s.length){const B=$0(z.cellId);for(let T of s.splice(0)){const S={t:"msg",id:O(),ttl:r(),data:T,origin:m,originCell:z.cellId},P=JSON.stringify(S);B.length?A.send(P,B):A.send(P),i(j,P)}}Q0()},X0=()=>{const B=j0(),T=!z.cellId||z.cellId!==B.cellId||z.isBridge!==B.isBridge||JSON.stringify(z.bridges)!==JSON.stringify(B.bridges);if(z=B,R(m,B.cellId,B.bridges),T)a0();else Q0();K("mesh:state",B),v()};let A0="";const H0=()=>{return`${z.cellId}:${z.isBridge}:${z.bridges.join(",")}`},n0=()=>{if(D)return;D=setInterval(()=>{const B=H0();if(B!==A0)Q0(),A0=B;for(let[T,S]of w)if(T!==m&&S.isStale)L.delete(T),w.delete(T),G("Removed stale peer:",T)},oJ)},L0=()=>{if(D)clearInterval(D),D=null},t8=(B)=>{return new Promise((T,S)=>{const P=`${Date.now()}-${Math.random().toString(36).slice(2,8)}`,F=Date.now(),a=setTimeout(()=>{e.delete(P);const n=w.get(B);if(n)n.markUnresponsive();S(new Error("Ping timeout"))},dJ);e.set(P,{start:F,resolve:T,reject:S,timeout:a,peerId:B});const Z0={t:"ping",id:O(),ttl:r(),data:{pingId:P,target:B},origin:m,originCell:z.cellId};A?.send(JSON.stringify(Z0))})};if($.on?.("peer:join",(B)=>{if(!w.has(B))w.set(B,new n8(B));else w.get(B).markReconnect();X0()}),$.on?.("peer:leave",(B)=>{L.delete(B),X0()}),!w.has(m))w.set(m,new n8(m));return w.get(m).addConnectedCell(z.cellId||"cell-0"),X0(),n0(),{send:(B)=>{if(!z.cellId||!A)return s.push(B);const T=$0(z.cellId),S={t:"msg",id:O(),ttl:r(),data:B,origin:m,originCell:z.cellId},P=JSON.stringify(S);T.length?A.send(P,T):A.send(P),i(j,P)},on:(B,T)=>B==="message"?k(T):void 0,ping:t8,getState:()=>({...z,cellSize:N,health:E(z.cellId),dynamicTTL:r(),totalCells:Math.ceil(_().length/N),knownCells:I.size}),getMetrics:C,getCellHealth:E,getPeerInfo:()=>new Map(L),getStableRoster:()=>_(),getKnownCells:()=>new Map(I),getCellSize:()=>N,destroy:()=>{L0(),e.forEach((B)=>clearTimeout(B.timeout)),e.clear(),g.clear(),I.clear()}}},Y9=function($,J,q){const Q=lQ($,J,q),G=$.overlay||{},U=rJ(Q,G),Y=new Map;return{on:(X,Z)=>Q.on(X,Z),off:(X,Z)=>Q.off?.(X,Z),channel:(X)=>{if(Y.has(X))return Y.get(X);const Z=Q.channel(X),N={send:(z,A)=>{U.send({_ch:X,_d:z,_t:A})},on:(z,A)=>{if(z==="message")U.on("message",(j,D)=>{if(j?._ch===X)A(j._d,D)}),Z.on(z,A);else Z.on(z,A)},off:(z,A)=>Z.off?.(z,A),_original:Z};return Y.set(X,N),N},get id(){return Q.id},get peers(){return Q.peers},getPeers:()=>Q.getPeers?.()||{},mesh:U,_room:Q,getState:()=>U.getState(),getMetrics:(X)=>U.getMetrics(X),getCellHealth:(X)=>U.getCellHealth(X),getPeerInfo:()=>U.getPeerInfo(),ping:(X)=>U.ping(X),destroy:()=>{U.destroy(),Y.clear()}}},cJ={cellSize:"auto",bridgesPerEdge:2,maxCellSize:50,targetCells:100,debug:!1},oQ=5000,dJ=3000,lJ=30000,oJ=2000,s8=($)=>{const J=String($||"").match(/cell-(\d+)/);return J?Number(J[1]):null},X8=($)=>{const J=s8($);if(J==null)return[];const q=[];if(J>0)q.push(`cell-${J-1}`);return q.push(`cell-${J+1}`),q},a8=($)=>`c${(s8($)||0).toString(36)}`,pJ=($,J,q)=>{if($<=10)return Math.max(2,$);const G=10,U=Math.ceil($/J);return Math.max(G,Math.min(q,U))},pQ=($,J)=>{return Math.max(1,Math.ceil($/J))},iJ=($,J,q)=>{const Q=Math.max(1,Math.ceil(J.length/q)),G=Math.ceil(J.length/Q),U=J.indexOf($);if(U<0)return 0;return Math.floor(U/G)};class n8{constructor($){this.peerId=$,this.joinedAt=Date.now(),this.lastSeen=Date.now(),this.rttSamples=[],this.stability=1,this.reconnects=0,this.isResponsive=!0,this.connectedCells=new Set}get uptime(){return Date.now()-this.joinedAt}get avgRtt(){if(this.rttSamples.length===0)return Infinity;return Math.round(this.rttSamples.reduce(($,J)=>$+J,0)/this.rttSamples.length)}get healthScore(){const $=this.avgRtt===Infinity?0.5:Math.max(0,100-this.avgRtt)/100,J=Math.min(1,this.uptime/60000),q=this.stability,Q=this.isResponsive?1:0.3;return $*0.25+J*0.25+q*0.3+Q*0.2}get isStale(){return Date.now()-this.lastSeen>lJ}addRttSample($){if(this.rttSamples.push($),this.rttSamples.length>10)this.rttSamples.shift();this.lastSeen=Date.now(),this.isResponsive=!0}markReconnect(){this.reconnects++,this.stability=Math.max(0,1-this.reconnects*0.1)}markUnresponsive(){this.isResponsive=!1}markSeen(){this.lastSeen=Date.now()}addConnectedCell($){if($)this.connectedCells.add($)}}export{m as selfId,Y9 as join,hJ as getRelaySockets,cJ as OVERLAY_DEFAULTS};
